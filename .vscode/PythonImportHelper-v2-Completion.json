[
    {
        "label": "register_atoms",
        "importPath": "hyperon.ext",
        "description": "hyperon.ext",
        "isExtraImport": true,
        "detail": "hyperon.ext",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon.ext",
        "description": "hyperon.ext",
        "isExtraImport": true,
        "detail": "hyperon.ext",
        "documentation": {}
    },
    {
        "label": "register_atoms",
        "importPath": "hyperon.ext",
        "description": "hyperon.ext",
        "isExtraImport": true,
        "detail": "hyperon.ext",
        "documentation": {}
    },
    {
        "label": "register_atoms",
        "importPath": "hyperon.ext",
        "description": "hyperon.ext",
        "isExtraImport": true,
        "detail": "hyperon.ext",
        "documentation": {}
    },
    {
        "label": "register_atoms",
        "importPath": "hyperon.ext",
        "description": "hyperon.ext",
        "isExtraImport": true,
        "detail": "hyperon.ext",
        "documentation": {}
    },
    {
        "label": "register_atoms",
        "importPath": "hyperon.ext",
        "description": "hyperon.ext",
        "isExtraImport": true,
        "detail": "hyperon.ext",
        "documentation": {}
    },
    {
        "label": "register_atoms",
        "importPath": "hyperon.ext",
        "description": "hyperon.ext",
        "isExtraImport": true,
        "detail": "hyperon.ext",
        "documentation": {}
    },
    {
        "label": "register_atoms",
        "importPath": "hyperon.ext",
        "description": "hyperon.ext",
        "isExtraImport": true,
        "detail": "hyperon.ext",
        "documentation": {}
    },
    {
        "label": "register_tokens",
        "importPath": "hyperon.ext",
        "description": "hyperon.ext",
        "isExtraImport": true,
        "detail": "hyperon.ext",
        "documentation": {}
    },
    {
        "label": "register_atoms",
        "importPath": "hyperon.ext",
        "description": "hyperon.ext",
        "isExtraImport": true,
        "detail": "hyperon.ext",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon.ext",
        "description": "hyperon.ext",
        "isExtraImport": true,
        "detail": "hyperon.ext",
        "documentation": {}
    },
    {
        "label": "register_atoms",
        "importPath": "hyperon.ext",
        "description": "hyperon.ext",
        "isExtraImport": true,
        "detail": "hyperon.ext",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon.ext",
        "description": "hyperon.ext",
        "isExtraImport": true,
        "detail": "hyperon.ext",
        "documentation": {}
    },
    {
        "label": "register_atoms",
        "importPath": "hyperon.ext",
        "description": "hyperon.ext",
        "isExtraImport": true,
        "detail": "hyperon.ext",
        "documentation": {}
    },
    {
        "label": "register_atoms",
        "importPath": "hyperon.ext",
        "description": "hyperon.ext",
        "isExtraImport": true,
        "detail": "hyperon.ext",
        "documentation": {}
    },
    {
        "label": "register_atoms",
        "importPath": "hyperon.ext",
        "description": "hyperon.ext",
        "isExtraImport": true,
        "detail": "hyperon.ext",
        "documentation": {}
    },
    {
        "label": "register_atoms",
        "importPath": "hyperon.ext",
        "description": "hyperon.ext",
        "isExtraImport": true,
        "detail": "hyperon.ext",
        "documentation": {}
    },
    {
        "label": "register_atoms",
        "importPath": "hyperon.ext",
        "description": "hyperon.ext",
        "isExtraImport": true,
        "detail": "hyperon.ext",
        "documentation": {}
    },
    {
        "label": "register_atoms",
        "importPath": "hyperon.ext",
        "description": "hyperon.ext",
        "isExtraImport": true,
        "detail": "hyperon.ext",
        "documentation": {}
    },
    {
        "label": "register_tokens",
        "importPath": "hyperon.ext",
        "description": "hyperon.ext",
        "isExtraImport": true,
        "detail": "hyperon.ext",
        "documentation": {}
    },
    {
        "label": "register_atoms",
        "importPath": "hyperon.ext",
        "description": "hyperon.ext",
        "isExtraImport": true,
        "detail": "hyperon.ext",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon.ext",
        "description": "hyperon.ext",
        "isExtraImport": true,
        "detail": "hyperon.ext",
        "documentation": {}
    },
    {
        "label": "register_atoms",
        "importPath": "hyperon.ext",
        "description": "hyperon.ext",
        "isExtraImport": true,
        "detail": "hyperon.ext",
        "documentation": {}
    },
    {
        "label": "register_tokens",
        "importPath": "hyperon.ext",
        "description": "hyperon.ext",
        "isExtraImport": true,
        "detail": "hyperon.ext",
        "documentation": {}
    },
    {
        "label": "register_atoms",
        "importPath": "hyperon.ext",
        "description": "hyperon.ext",
        "isExtraImport": true,
        "detail": "hyperon.ext",
        "documentation": {}
    },
    {
        "label": "register_atoms",
        "importPath": "hyperon.ext",
        "description": "hyperon.ext",
        "isExtraImport": true,
        "detail": "hyperon.ext",
        "documentation": {}
    },
    {
        "label": "register_atoms",
        "importPath": "hyperon.ext",
        "description": "hyperon.ext",
        "isExtraImport": true,
        "detail": "hyperon.ext",
        "documentation": {}
    },
    {
        "label": "register_tokens",
        "importPath": "hyperon.ext",
        "description": "hyperon.ext",
        "isExtraImport": true,
        "detail": "hyperon.ext",
        "documentation": {}
    },
    {
        "label": "register_atoms",
        "importPath": "hyperon.ext",
        "description": "hyperon.ext",
        "isExtraImport": true,
        "detail": "hyperon.ext",
        "documentation": {}
    },
    {
        "label": "register_tokens",
        "importPath": "hyperon.ext",
        "description": "hyperon.ext",
        "isExtraImport": true,
        "detail": "hyperon.ext",
        "documentation": {}
    },
    {
        "label": "register_atoms",
        "importPath": "hyperon.ext",
        "description": "hyperon.ext",
        "isExtraImport": true,
        "detail": "hyperon.ext",
        "documentation": {}
    },
    {
        "label": "register_atoms",
        "importPath": "hyperon.ext",
        "description": "hyperon.ext",
        "isExtraImport": true,
        "detail": "hyperon.ext",
        "documentation": {}
    },
    {
        "label": "hyperon",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hyperon",
        "description": "hyperon",
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "MeTTa",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "E",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "atoms_are_equivalent",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "Environment",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "MeTTa",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "Environment",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "E",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "MeTTa",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "E",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "atoms_are_equivalent",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "Environment",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "MeTTa",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "Environment",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "E",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon",
        "description": "hyperon",
        "isExtraImport": true,
        "detail": "hyperon",
        "documentation": {}
    },
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "defaultdict",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "Counter",
        "importPath": "collections",
        "description": "collections",
        "isExtraImport": true,
        "detail": "collections",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "monotonic_ns",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "monotonic_ns",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "monotonic_ns",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "monotonic_ns",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "monotonic_ns",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "monotonic_ns",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "time",
        "importPath": "time",
        "description": "time",
        "isExtraImport": true,
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "MeTTa",
        "importPath": "base",
        "description": "base",
        "isExtraImport": true,
        "detail": "base",
        "documentation": {}
    },
    {
        "label": "color_expr",
        "importPath": "base",
        "description": "base",
        "isExtraImport": true,
        "detail": "base",
        "documentation": {}
    },
    {
        "label": "underline",
        "importPath": "base",
        "description": "base",
        "isExtraImport": true,
        "detail": "base",
        "documentation": {}
    },
    {
        "label": "MeTTa",
        "importPath": "base",
        "description": "base",
        "isExtraImport": true,
        "detail": "base",
        "documentation": {}
    },
    {
        "label": "color_expr",
        "importPath": "base",
        "description": "base",
        "isExtraImport": true,
        "detail": "base",
        "documentation": {}
    },
    {
        "label": "underline",
        "importPath": "base",
        "description": "base",
        "isExtraImport": true,
        "detail": "base",
        "documentation": {}
    },
    {
        "label": "OperationAtom",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "ValueAtom",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "G",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "AtomType",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "OperationAtom",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "E",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "OperationAtom",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "ValueAtom",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "OperationAtom",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "ValueAtom",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "G",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "AtomType",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "OperationAtom",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "E",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "OperationAtom",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "ValueAtom",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "V",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "S",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "E",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "ValueAtom",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "GroundedAtom",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "ExpressionAtom",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "G",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "AtomType",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "MatchableObject",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "OperationAtom",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "OperationObject",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "BindingsSet",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "Atom",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "Atom",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "Atom",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "AtomType",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "OperationAtom",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "G",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "AtomType",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "OperationAtom",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "E",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "Atom",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "AtomType",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "OperationAtom",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon.atoms",
        "description": "hyperon.atoms",
        "isExtraImport": true,
        "detail": "hyperon.atoms",
        "documentation": {}
    },
    {
        "label": "random",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random",
        "description": "random",
        "detail": "random",
        "documentation": {}
    },
    {
        "label": "metta_learner",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "metta_learner",
        "description": "metta_learner",
        "detail": "metta_learner",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "metta_learner",
        "description": "metta_learner",
        "isExtraImport": true,
        "detail": "metta_learner",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "metta_learner",
        "description": "metta_learner",
        "isExtraImport": true,
        "detail": "metta_learner",
        "documentation": {}
    },
    {
        "label": "DistributedAtomSpace",
        "importPath": "hyperon_das",
        "description": "hyperon_das",
        "isExtraImport": true,
        "detail": "hyperon_das",
        "documentation": {}
    },
    {
        "label": "DistributedAtomSpace",
        "importPath": "hyperon_das",
        "description": "hyperon_das",
        "isExtraImport": true,
        "detail": "hyperon_das",
        "documentation": {}
    },
    {
        "label": "DistributedAtomSpace",
        "importPath": "hyperon_das",
        "description": "hyperon_das",
        "isExtraImport": true,
        "detail": "hyperon_das",
        "documentation": {}
    },
    {
        "label": "DistributedAtomSpace",
        "importPath": "hyperon_das",
        "description": "hyperon_das",
        "isExtraImport": true,
        "detail": "hyperon_das",
        "documentation": {}
    },
    {
        "label": "DistributedAtomSpace",
        "importPath": "hyperon_das",
        "description": "hyperon_das",
        "isExtraImport": true,
        "detail": "hyperon_das",
        "documentation": {}
    },
    {
        "label": "DistributedAtomSpace",
        "importPath": "hyperon_das",
        "description": "hyperon_das",
        "isExtraImport": true,
        "detail": "hyperon_das",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "absolute_import",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "division",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "print_function",
        "importPath": "__future__",
        "description": "__future__",
        "isExtraImport": true,
        "detail": "__future__",
        "documentation": {}
    },
    {
        "label": "argparse,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "argparse.",
        "description": "argparse.",
        "detail": "argparse.",
        "documentation": {}
    },
    {
        "label": "random,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "random.",
        "description": "random.",
        "detail": "random.",
        "documentation": {}
    },
    {
        "label": "glob",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "glob",
        "description": "glob",
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "glob",
        "importPath": "glob",
        "description": "glob",
        "isExtraImport": true,
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "glob",
        "importPath": "glob",
        "description": "glob",
        "isExtraImport": true,
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "glob",
        "importPath": "glob",
        "description": "glob",
        "isExtraImport": true,
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "glob",
        "importPath": "glob",
        "description": "glob",
        "isExtraImport": true,
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "glob",
        "importPath": "glob",
        "description": "glob",
        "isExtraImport": true,
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "glob",
        "importPath": "glob",
        "description": "glob",
        "isExtraImport": true,
        "detail": "glob",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "ctypes",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ctypes",
        "description": "ctypes",
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "ctypes",
        "description": "ctypes",
        "isExtraImport": true,
        "detail": "ctypes",
        "documentation": {}
    },
    {
        "label": "ast",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "ast",
        "description": "ast",
        "detail": "ast",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "QueryOutputFormat",
        "importPath": "hyperon_das.utils",
        "description": "hyperon_das.utils",
        "isExtraImport": true,
        "detail": "hyperon_das.utils",
        "documentation": {}
    },
    {
        "label": "QueryOutputFormat",
        "importPath": "hyperon_das.utils",
        "description": "hyperon_das.utils",
        "isExtraImport": true,
        "detail": "hyperon_das.utils",
        "documentation": {}
    },
    {
        "label": "Assignment",
        "importPath": "hyperon_das.utils",
        "description": "hyperon_das.utils",
        "isExtraImport": true,
        "detail": "hyperon_das.utils",
        "documentation": {}
    },
    {
        "label": "QueryAnswer",
        "importPath": "hyperon_das.utils",
        "description": "hyperon_das.utils",
        "isExtraImport": true,
        "detail": "hyperon_das.utils",
        "documentation": {}
    },
    {
        "label": "QueryOutputFormat",
        "importPath": "hyperon_das.utils",
        "description": "hyperon_das.utils",
        "isExtraImport": true,
        "detail": "hyperon_das.utils",
        "documentation": {}
    },
    {
        "label": "QueryParameters",
        "importPath": "hyperon_das.utils",
        "description": "hyperon_das.utils",
        "isExtraImport": true,
        "detail": "hyperon_das.utils",
        "documentation": {}
    },
    {
        "label": "Link",
        "importPath": "hyperon_das.pattern_matcher",
        "description": "hyperon_das.pattern_matcher",
        "isExtraImport": true,
        "detail": "hyperon_das.pattern_matcher",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "hyperon_das.pattern_matcher",
        "description": "hyperon_das.pattern_matcher",
        "isExtraImport": true,
        "detail": "hyperon_das.pattern_matcher",
        "documentation": {}
    },
    {
        "label": "Variable",
        "importPath": "hyperon_das.pattern_matcher",
        "description": "hyperon_das.pattern_matcher",
        "isExtraImport": true,
        "detail": "hyperon_das.pattern_matcher",
        "documentation": {}
    },
    {
        "label": "And",
        "importPath": "hyperon_das.pattern_matcher",
        "description": "hyperon_das.pattern_matcher",
        "isExtraImport": true,
        "detail": "hyperon_das.pattern_matcher",
        "documentation": {}
    },
    {
        "label": "Or",
        "importPath": "hyperon_das.pattern_matcher",
        "description": "hyperon_das.pattern_matcher",
        "isExtraImport": true,
        "detail": "hyperon_das.pattern_matcher",
        "documentation": {}
    },
    {
        "label": "Not",
        "importPath": "hyperon_das.pattern_matcher",
        "description": "hyperon_das.pattern_matcher",
        "isExtraImport": true,
        "detail": "hyperon_das.pattern_matcher",
        "documentation": {}
    },
    {
        "label": "PatternMatchingAnswer",
        "importPath": "hyperon_das.pattern_matcher",
        "description": "hyperon_das.pattern_matcher",
        "isExtraImport": true,
        "detail": "hyperon_das.pattern_matcher",
        "documentation": {}
    },
    {
        "label": "Link",
        "importPath": "hyperon_das.pattern_matcher",
        "description": "hyperon_das.pattern_matcher",
        "isExtraImport": true,
        "detail": "hyperon_das.pattern_matcher",
        "documentation": {}
    },
    {
        "label": "Node",
        "importPath": "hyperon_das.pattern_matcher",
        "description": "hyperon_das.pattern_matcher",
        "isExtraImport": true,
        "detail": "hyperon_das.pattern_matcher",
        "documentation": {}
    },
    {
        "label": "Variable",
        "importPath": "hyperon_das.pattern_matcher",
        "description": "hyperon_das.pattern_matcher",
        "isExtraImport": true,
        "detail": "hyperon_das.pattern_matcher",
        "documentation": {}
    },
    {
        "label": "And",
        "importPath": "hyperon_das.pattern_matcher",
        "description": "hyperon_das.pattern_matcher",
        "isExtraImport": true,
        "detail": "hyperon_das.pattern_matcher",
        "documentation": {}
    },
    {
        "label": "Or",
        "importPath": "hyperon_das.pattern_matcher",
        "description": "hyperon_das.pattern_matcher",
        "isExtraImport": true,
        "detail": "hyperon_das.pattern_matcher",
        "documentation": {}
    },
    {
        "label": "Not",
        "importPath": "hyperon_das.pattern_matcher",
        "description": "hyperon_das.pattern_matcher",
        "isExtraImport": true,
        "detail": "hyperon_das.pattern_matcher",
        "documentation": {}
    },
    {
        "label": "PatternMatchingAnswer",
        "importPath": "hyperon_das.pattern_matcher",
        "description": "hyperon_das.pattern_matcher",
        "isExtraImport": true,
        "detail": "hyperon_das.pattern_matcher",
        "documentation": {}
    },
    {
        "label": "LogicalExpression",
        "importPath": "hyperon_das.pattern_matcher",
        "description": "hyperon_das.pattern_matcher",
        "isExtraImport": true,
        "detail": "hyperon_das.pattern_matcher",
        "documentation": {}
    },
    {
        "label": "PatternMatchingAnswer",
        "importPath": "hyperon_das.pattern_matcher",
        "description": "hyperon_das.pattern_matcher",
        "isExtraImport": true,
        "detail": "hyperon_das.pattern_matcher",
        "documentation": {}
    },
    {
        "label": "openai",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "openai",
        "description": "openai",
        "detail": "openai",
        "documentation": {}
    },
    {
        "label": "re",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "re",
        "description": "re",
        "detail": "re",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "MeTTa",
        "importPath": "hyperon.runner",
        "description": "hyperon.runner",
        "isExtraImport": true,
        "detail": "hyperon.runner",
        "documentation": {}
    },
    {
        "label": "MeTTa",
        "importPath": "hyperon.runner",
        "description": "hyperon.runner",
        "isExtraImport": true,
        "detail": "hyperon.runner",
        "documentation": {}
    },
    {
        "label": "MeTTa",
        "importPath": "hyperon.runner",
        "description": "hyperon.runner",
        "isExtraImport": true,
        "detail": "hyperon.runner",
        "documentation": {}
    },
    {
        "label": "MeTTa",
        "importPath": "hyperon.runner",
        "description": "hyperon.runner",
        "isExtraImport": true,
        "detail": "hyperon.runner",
        "documentation": {}
    },
    {
        "label": "MeTTa",
        "importPath": "hyperon.runner",
        "description": "hyperon.runner",
        "isExtraImport": true,
        "detail": "hyperon.runner",
        "documentation": {}
    },
    {
        "label": "Atom",
        "importPath": "hyperon.base",
        "description": "hyperon.base",
        "isExtraImport": true,
        "detail": "hyperon.base",
        "documentation": {}
    },
    {
        "label": "Atom",
        "importPath": "hyperon.base",
        "description": "hyperon.base",
        "isExtraImport": true,
        "detail": "hyperon.base",
        "documentation": {}
    },
    {
        "label": "AbstractSpace",
        "importPath": "hyperon.base",
        "description": "hyperon.base",
        "isExtraImport": true,
        "detail": "hyperon.base",
        "documentation": {}
    },
    {
        "label": "SpaceRef",
        "importPath": "hyperon.base",
        "description": "hyperon.base",
        "isExtraImport": true,
        "detail": "hyperon.base",
        "documentation": {}
    },
    {
        "label": "GroundingSpace",
        "importPath": "hyperon.base",
        "description": "hyperon.base",
        "isExtraImport": true,
        "detail": "hyperon.base",
        "documentation": {}
    },
    {
        "label": "interpret",
        "importPath": "hyperon.base",
        "description": "hyperon.base",
        "isExtraImport": true,
        "detail": "hyperon.base",
        "documentation": {}
    },
    {
        "label": "GroundingSpaceRef",
        "importPath": "hyperon.base",
        "description": "hyperon.base",
        "isExtraImport": true,
        "detail": "hyperon.base",
        "documentation": {}
    },
    {
        "label": "Tokenizer",
        "importPath": "hyperon.base",
        "description": "hyperon.base",
        "isExtraImport": true,
        "detail": "hyperon.base",
        "documentation": {}
    },
    {
        "label": "SExprParser",
        "importPath": "hyperon.base",
        "description": "hyperon.base",
        "isExtraImport": true,
        "detail": "hyperon.base",
        "documentation": {}
    },
    {
        "label": "Atom",
        "importPath": "hyperon.base",
        "description": "hyperon.base",
        "isExtraImport": true,
        "detail": "hyperon.base",
        "documentation": {}
    },
    {
        "label": "AbstractSpace",
        "importPath": "hyperon.base",
        "description": "hyperon.base",
        "isExtraImport": true,
        "detail": "hyperon.base",
        "documentation": {}
    },
    {
        "label": "SpaceRef",
        "importPath": "hyperon.base",
        "description": "hyperon.base",
        "isExtraImport": true,
        "detail": "hyperon.base",
        "documentation": {}
    },
    {
        "label": "GroundingSpace",
        "importPath": "hyperon.base",
        "description": "hyperon.base",
        "isExtraImport": true,
        "detail": "hyperon.base",
        "documentation": {}
    },
    {
        "label": "interpret",
        "importPath": "hyperon.base",
        "description": "hyperon.base",
        "isExtraImport": true,
        "detail": "hyperon.base",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "hyperon.base",
        "description": "hyperon.base",
        "isExtraImport": true,
        "detail": "hyperon.base",
        "documentation": {}
    },
    {
        "label": "GroundingSpaceRef",
        "importPath": "hyperon.base",
        "description": "hyperon.base",
        "isExtraImport": true,
        "detail": "hyperon.base",
        "documentation": {}
    },
    {
        "label": "Tokenizer",
        "importPath": "hyperon.base",
        "description": "hyperon.base",
        "isExtraImport": true,
        "detail": "hyperon.base",
        "documentation": {}
    },
    {
        "label": "SExprParser",
        "importPath": "hyperon.base",
        "description": "hyperon.base",
        "isExtraImport": true,
        "detail": "hyperon.base",
        "documentation": {}
    },
    {
        "label": "hyperonpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "hyperonpy",
        "description": "hyperonpy",
        "detail": "hyperonpy",
        "documentation": {}
    },
    {
        "label": "psycopg2",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "psycopg2",
        "description": "psycopg2",
        "detail": "psycopg2",
        "documentation": {}
    },
    {
        "label": "unittest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unittest",
        "description": "unittest",
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "deepcopy",
        "importPath": "copy",
        "description": "copy",
        "isExtraImport": true,
        "detail": "copy",
        "documentation": {}
    },
    {
        "label": "HyperonTestCase",
        "importPath": "test_common",
        "description": "test_common",
        "isExtraImport": true,
        "detail": "test_common",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "test_common",
        "description": "test_common",
        "isExtraImport": true,
        "detail": "test_common",
        "documentation": {}
    },
    {
        "label": "HyperonTestCase",
        "importPath": "test_common",
        "description": "test_common",
        "isExtraImport": true,
        "detail": "test_common",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "test_common",
        "description": "test_common",
        "isExtraImport": true,
        "detail": "test_common",
        "documentation": {}
    },
    {
        "label": "HyperonTestCase",
        "importPath": "test_common",
        "description": "test_common",
        "isExtraImport": true,
        "detail": "test_common",
        "documentation": {}
    },
    {
        "label": "HyperonTestCase",
        "importPath": "test_common",
        "description": "test_common",
        "isExtraImport": true,
        "detail": "test_common",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "test_common",
        "description": "test_common",
        "isExtraImport": true,
        "detail": "test_common",
        "documentation": {}
    },
    {
        "label": "HyperonTestCase",
        "importPath": "test_common",
        "description": "test_common",
        "isExtraImport": true,
        "detail": "test_common",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "test_common",
        "description": "test_common",
        "isExtraImport": true,
        "detail": "test_common",
        "documentation": {}
    },
    {
        "label": "HyperonTestCase",
        "importPath": "test_common",
        "description": "test_common",
        "isExtraImport": true,
        "detail": "test_common",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "test_common",
        "description": "test_common",
        "isExtraImport": true,
        "detail": "test_common",
        "documentation": {}
    },
    {
        "label": "HyperonTestCase",
        "importPath": "test_common",
        "description": "test_common",
        "isExtraImport": true,
        "detail": "test_common",
        "documentation": {}
    },
    {
        "label": "HyperonTestCase",
        "importPath": "test_common",
        "description": "test_common",
        "isExtraImport": true,
        "detail": "test_common",
        "documentation": {}
    },
    {
        "label": "*",
        "importPath": "test_common",
        "description": "test_common",
        "isExtraImport": true,
        "detail": "test_common",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Path",
        "importPath": "pathlib",
        "description": "pathlib",
        "isExtraImport": true,
        "detail": "pathlib",
        "documentation": {}
    },
    {
        "label": "Char",
        "importPath": "hyperon.stdlib",
        "description": "hyperon.stdlib",
        "isExtraImport": true,
        "detail": "hyperon.stdlib",
        "documentation": {}
    },
    {
        "label": "Char",
        "importPath": "hyperon.stdlib",
        "description": "hyperon.stdlib",
        "isExtraImport": true,
        "detail": "hyperon.stdlib",
        "documentation": {}
    },
    {
        "label": "product",
        "importPath": "itertools",
        "description": "itertools",
        "isExtraImport": true,
        "detail": "itertools",
        "documentation": {}
    },
    {
        "label": "Any",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Dict",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "List",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Set",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Tuple",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Union",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "WILDCARD",
        "importPath": "hyperon_das_atomdb",
        "description": "hyperon_das_atomdb",
        "isExtraImport": true,
        "detail": "hyperon_das_atomdb",
        "documentation": {}
    },
    {
        "label": "record_execution_time",
        "importPath": "hyperon_das.decorators",
        "description": "hyperon_das.decorators",
        "isExtraImport": true,
        "detail": "hyperon_das.decorators",
        "documentation": {}
    },
    {
        "label": "DatabaseTypeException",
        "importPath": "hyperon_das.exceptions",
        "description": "hyperon_das.exceptions",
        "isExtraImport": true,
        "detail": "hyperon_das.exceptions",
        "documentation": {}
    },
    {
        "label": "InitializeServerException",
        "importPath": "hyperon_das.exceptions",
        "description": "hyperon_das.exceptions",
        "isExtraImport": true,
        "detail": "hyperon_das.exceptions",
        "documentation": {}
    },
    {
        "label": "MethodNotAllowed",
        "importPath": "hyperon_das.exceptions",
        "description": "hyperon_das.exceptions",
        "isExtraImport": true,
        "detail": "hyperon_das.exceptions",
        "documentation": {}
    },
    {
        "label": "UnexpectedQueryFormat",
        "importPath": "hyperon_das.exceptions",
        "description": "hyperon_das.exceptions",
        "isExtraImport": true,
        "detail": "hyperon_das.exceptions",
        "documentation": {}
    },
    {
        "label": "QueryParametersException",
        "importPath": "hyperon_das.exceptions",
        "description": "hyperon_das.exceptions",
        "isExtraImport": true,
        "detail": "hyperon_das.exceptions",
        "documentation": {}
    },
    {
        "label": "DatabaseFactory",
        "importPath": "hyperon_das.factory",
        "description": "hyperon_das.factory",
        "isExtraImport": true,
        "detail": "hyperon_das.factory",
        "documentation": {}
    },
    {
        "label": "DatabaseType",
        "importPath": "hyperon_das.factory",
        "description": "hyperon_das.factory",
        "isExtraImport": true,
        "detail": "hyperon_das.factory",
        "documentation": {}
    },
    {
        "label": "database_factory",
        "importPath": "hyperon_das.factory",
        "description": "hyperon_das.factory",
        "isExtraImport": true,
        "detail": "hyperon_das.factory",
        "documentation": {}
    },
    {
        "label": "logger",
        "importPath": "hyperon_das.logger",
        "description": "hyperon_das.logger",
        "isExtraImport": true,
        "detail": "hyperon_das.logger",
        "documentation": {}
    },
    {
        "label": "DistributedAtomSpace",
        "importPath": "hyperon_das.api",
        "description": "hyperon_das.api",
        "isExtraImport": true,
        "detail": "hyperon_das.api",
        "documentation": {}
    },
    {
        "label": "LazyQueryEvaluator",
        "importPath": "hyperon_das.cache",
        "description": "hyperon_das.cache",
        "isExtraImport": true,
        "detail": "hyperon_das.cache",
        "documentation": {}
    },
    {
        "label": "ListIterator",
        "importPath": "hyperon_das.cache",
        "description": "hyperon_das.cache",
        "isExtraImport": true,
        "detail": "hyperon_das.cache",
        "documentation": {}
    },
    {
        "label": "QueryAnswerIterator",
        "importPath": "hyperon_das.cache",
        "description": "hyperon_das.cache",
        "isExtraImport": true,
        "detail": "hyperon_das.cache",
        "documentation": {}
    },
    {
        "label": "pytest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pytest",
        "description": "pytest",
        "detail": "pytest",
        "documentation": {}
    },
    {
        "label": "ExpressionHasher",
        "importPath": "hyperon_das_atomdb.utils.expression_hasher",
        "description": "hyperon_das_atomdb.utils.expression_hasher",
        "isExtraImport": true,
        "detail": "hyperon_das_atomdb.utils.expression_hasher",
        "documentation": {}
    },
    {
        "label": "ExpressionHasher",
        "importPath": "hyperon_das_atomdb.utils.expression_hasher",
        "description": "hyperon_das_atomdb.utils.expression_hasher",
        "isExtraImport": true,
        "detail": "hyperon_das_atomdb.utils.expression_hasher",
        "documentation": {}
    },
    {
        "label": "FunctionsClient",
        "importPath": "hyperon_das.client",
        "description": "hyperon_das.client",
        "isExtraImport": true,
        "detail": "hyperon_das.client",
        "documentation": {}
    },
    {
        "label": "FunctionsClient",
        "importPath": "hyperon_das.client",
        "description": "hyperon_das.client",
        "isExtraImport": true,
        "detail": "hyperon_das.client",
        "documentation": {}
    },
    {
        "label": "QueryOutputFormat",
        "importPath": "hyperon_das.constants",
        "description": "hyperon_das.constants",
        "isExtraImport": true,
        "detail": "hyperon_das.constants",
        "documentation": {}
    },
    {
        "label": "QueryOutputFormat",
        "importPath": "hyperon_das.constants",
        "description": "hyperon_das.constants",
        "isExtraImport": true,
        "detail": "hyperon_das.constants",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "atexit",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "atexit",
        "description": "atexit",
        "detail": "atexit",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "check_output",
        "importPath": "subprocess",
        "description": "subprocess",
        "isExtraImport": true,
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "pip",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pip",
        "description": "pip",
        "detail": "pip",
        "documentation": {}
    },
    {
        "label": "readline",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "readline",
        "description": "readline",
        "detail": "readline",
        "documentation": {}
    },
    {
        "label": "traceback",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "traceback",
        "description": "traceback",
        "detail": "traceback",
        "documentation": {}
    },
    {
        "label": "inspect",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "inspect",
        "description": "inspect",
        "detail": "inspect",
        "documentation": {}
    },
    {
        "label": "Atom",
        "importPath": "pyswip",
        "description": "pyswip",
        "isExtraImport": true,
        "detail": "pyswip",
        "documentation": {}
    },
    {
        "label": "Term",
        "importPath": "pyswip",
        "description": "pyswip",
        "isExtraImport": true,
        "detail": "pyswip",
        "documentation": {}
    },
    {
        "label": "Functor",
        "importPath": "pyswip",
        "description": "pyswip",
        "isExtraImport": true,
        "detail": "pyswip",
        "documentation": {}
    },
    {
        "label": "registerForeign",
        "importPath": "pyswip",
        "description": "pyswip",
        "isExtraImport": true,
        "detail": "pyswip",
        "documentation": {}
    },
    {
        "label": "PL_PRUNED",
        "importPath": "pyswip",
        "description": "pyswip",
        "isExtraImport": true,
        "detail": "pyswip",
        "documentation": {}
    },
    {
        "label": "PL_retry",
        "importPath": "pyswip",
        "description": "pyswip",
        "isExtraImport": true,
        "detail": "pyswip",
        "documentation": {}
    },
    {
        "label": "PL_FA_NONDETERMINISTIC",
        "importPath": "pyswip",
        "description": "pyswip",
        "isExtraImport": true,
        "detail": "pyswip",
        "documentation": {}
    },
    {
        "label": "PL_foreign_control",
        "importPath": "pyswip",
        "description": "pyswip",
        "isExtraImport": true,
        "detail": "pyswip",
        "documentation": {}
    },
    {
        "label": "PL_foreign_context",
        "importPath": "pyswip",
        "description": "pyswip",
        "isExtraImport": true,
        "detail": "pyswip",
        "documentation": {}
    },
    {
        "label": "PL_FIRST_CALL",
        "importPath": "pyswip",
        "description": "pyswip",
        "isExtraImport": true,
        "detail": "pyswip",
        "documentation": {}
    },
    {
        "label": "PL_REDO",
        "importPath": "pyswip",
        "description": "pyswip",
        "isExtraImport": true,
        "detail": "pyswip",
        "documentation": {}
    },
    {
        "label": "Variable",
        "importPath": "pyswip",
        "description": "pyswip",
        "isExtraImport": true,
        "detail": "pyswip",
        "documentation": {}
    },
    {
        "label": "Prolog",
        "importPath": "pyswip",
        "description": "pyswip",
        "isExtraImport": true,
        "detail": "pyswip",
        "documentation": {}
    },
    {
        "label": "Atom",
        "importPath": "pyswip",
        "description": "pyswip",
        "isExtraImport": true,
        "detail": "pyswip",
        "documentation": {}
    },
    {
        "label": "Term",
        "importPath": "pyswip",
        "description": "pyswip",
        "isExtraImport": true,
        "detail": "pyswip",
        "documentation": {}
    },
    {
        "label": "call",
        "importPath": "pyswip",
        "description": "pyswip",
        "isExtraImport": true,
        "detail": "pyswip",
        "documentation": {}
    },
    {
        "label": "Functor",
        "importPath": "pyswip",
        "description": "pyswip",
        "isExtraImport": true,
        "detail": "pyswip",
        "documentation": {}
    },
    {
        "label": "PL_discard_foreign_frame",
        "importPath": "pyswip",
        "description": "pyswip",
        "isExtraImport": true,
        "detail": "pyswip",
        "documentation": {}
    },
    {
        "label": "PL_new_term_ref",
        "importPath": "pyswip",
        "description": "pyswip",
        "isExtraImport": true,
        "detail": "pyswip",
        "documentation": {}
    },
    {
        "label": "PL_open_foreign_frame",
        "importPath": "pyswip",
        "description": "pyswip",
        "isExtraImport": true,
        "detail": "pyswip",
        "documentation": {}
    },
    {
        "label": "registerForeign",
        "importPath": "pyswip",
        "description": "pyswip",
        "isExtraImport": true,
        "detail": "pyswip",
        "documentation": {}
    },
    {
        "label": "PL_PRUNED",
        "importPath": "pyswip",
        "description": "pyswip",
        "isExtraImport": true,
        "detail": "pyswip",
        "documentation": {}
    },
    {
        "label": "PL_retry",
        "importPath": "pyswip",
        "description": "pyswip",
        "isExtraImport": true,
        "detail": "pyswip",
        "documentation": {}
    },
    {
        "label": "PL_FA_NONDETERMINISTIC",
        "importPath": "pyswip",
        "description": "pyswip",
        "isExtraImport": true,
        "detail": "pyswip",
        "documentation": {}
    },
    {
        "label": "PL_foreign_control",
        "importPath": "pyswip",
        "description": "pyswip",
        "isExtraImport": true,
        "detail": "pyswip",
        "documentation": {}
    },
    {
        "label": "PL_foreign_context",
        "importPath": "pyswip",
        "description": "pyswip",
        "isExtraImport": true,
        "detail": "pyswip",
        "documentation": {}
    },
    {
        "label": "PL_FIRST_CALL",
        "importPath": "pyswip",
        "description": "pyswip",
        "isExtraImport": true,
        "detail": "pyswip",
        "documentation": {}
    },
    {
        "label": "PL_REDO",
        "importPath": "pyswip",
        "description": "pyswip",
        "isExtraImport": true,
        "detail": "pyswip",
        "documentation": {}
    },
    {
        "label": "Variable",
        "importPath": "pyswip",
        "description": "pyswip",
        "isExtraImport": true,
        "detail": "pyswip",
        "documentation": {}
    },
    {
        "label": "Prolog",
        "importPath": "pyswip",
        "description": "pyswip",
        "isExtraImport": true,
        "detail": "pyswip",
        "documentation": {}
    },
    {
        "label": "newModule",
        "importPath": "pyswip.easy",
        "description": "pyswip.easy",
        "isExtraImport": true,
        "detail": "pyswip.easy",
        "documentation": {}
    },
    {
        "label": "Query",
        "importPath": "pyswip.easy",
        "description": "pyswip.easy",
        "isExtraImport": true,
        "detail": "pyswip.easy",
        "documentation": {}
    },
    {
        "label": "newModule",
        "importPath": "pyswip.easy",
        "description": "pyswip.easy",
        "isExtraImport": true,
        "detail": "pyswip.easy",
        "documentation": {}
    },
    {
        "label": "Query",
        "importPath": "pyswip.easy",
        "description": "pyswip.easy",
        "isExtraImport": true,
        "detail": "pyswip.easy",
        "documentation": {}
    },
    {
        "label": "importlib",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "importlib",
        "description": "importlib",
        "detail": "importlib",
        "documentation": {}
    },
    {
        "label": "import_module",
        "importPath": "importlib",
        "description": "importlib",
        "isExtraImport": true,
        "detail": "importlib",
        "documentation": {}
    },
    {
        "label": "import_module",
        "importPath": "importlib",
        "description": "importlib",
        "isExtraImport": true,
        "detail": "importlib",
        "documentation": {}
    },
    {
        "label": "label",
        "importPath": "cProfile",
        "description": "cProfile",
        "isExtraImport": true,
        "detail": "cProfile",
        "documentation": {}
    },
    {
        "label": "general_random_intersection_graph",
        "importPath": "networkx",
        "description": "networkx",
        "isExtraImport": true,
        "detail": "networkx",
        "documentation": {}
    },
    {
        "label": "expected_conditions",
        "importPath": "selenium.webdriver.support",
        "description": "selenium.webdriver.support",
        "isExtraImport": true,
        "detail": "selenium.webdriver.support",
        "documentation": {}
    },
    {
        "label": "exceptions",
        "importPath": "selenium.common",
        "description": "selenium.common",
        "isExtraImport": true,
        "detail": "selenium.common",
        "documentation": {}
    },
    {
        "label": "WebDriverWait",
        "importPath": "selenium.webdriver.support.ui",
        "description": "selenium.webdriver.support.ui",
        "isExtraImport": true,
        "detail": "selenium.webdriver.support.ui",
        "documentation": {}
    },
    {
        "label": "Keys",
        "importPath": "selenium.webdriver.common.keys",
        "description": "selenium.webdriver.common.keys",
        "isExtraImport": true,
        "detail": "selenium.webdriver.common.keys",
        "documentation": {}
    },
    {
        "label": "By",
        "importPath": "selenium.webdriver.common.by",
        "description": "selenium.webdriver.common.by",
        "isExtraImport": true,
        "detail": "selenium.webdriver.common.by",
        "documentation": {}
    },
    {
        "label": "undetected_chromedriver",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "undetected_chromedriver",
        "description": "undetected_chromedriver",
        "detail": "undetected_chromedriver",
        "documentation": {}
    },
    {
        "label": "markdownify",
        "importPath": "markdownify",
        "description": "markdownify",
        "isExtraImport": true,
        "detail": "markdownify",
        "documentation": {}
    },
    {
        "label": "Thread",
        "importPath": "threading",
        "description": "threading",
        "isExtraImport": true,
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "platform",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "platform",
        "description": "platform",
        "detail": "platform",
        "documentation": {}
    },
    {
        "label": "logging",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "logging",
        "description": "logging",
        "detail": "logging",
        "documentation": {}
    },
    {
        "label": "weakref",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "weakref",
        "description": "weakref",
        "detail": "weakref",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "GPT4OpenAI",
        "importPath": "gpt4_openai",
        "description": "gpt4_openai",
        "isExtraImport": true,
        "detail": "gpt4_openai",
        "documentation": {}
    },
    {
        "label": "GPT4OpenAI",
        "importPath": "gpt4_openai",
        "description": "gpt4_openai",
        "isExtraImport": true,
        "detail": "gpt4_openai",
        "documentation": {}
    },
    {
        "label": "GPT4OpenAI",
        "importPath": "gpt4_openai",
        "description": "gpt4_openai",
        "isExtraImport": true,
        "detail": "gpt4_openai",
        "documentation": {}
    },
    {
        "label": "GPT4OpenAI",
        "importPath": "gpt4_openai",
        "description": "gpt4_openai",
        "isExtraImport": true,
        "detail": "gpt4_openai",
        "documentation": {}
    },
    {
        "label": "GPT4OpenAI",
        "importPath": "gpt4_openai",
        "description": "gpt4_openai",
        "isExtraImport": true,
        "detail": "gpt4_openai",
        "documentation": {}
    },
    {
        "label": "GPT4OpenAI",
        "importPath": "gpt4_openai",
        "description": "gpt4_openai",
        "isExtraImport": true,
        "detail": "gpt4_openai",
        "documentation": {}
    },
    {
        "label": "GPT4OpenAI",
        "importPath": "gpt4_openai",
        "description": "gpt4_openai",
        "isExtraImport": true,
        "detail": "gpt4_openai",
        "documentation": {}
    },
    {
        "label": "cv2",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "cv2",
        "description": "cv2",
        "detail": "cv2",
        "documentation": {}
    },
    {
        "label": "LLMChain",
        "importPath": "langchain.chains.LLMChain",
        "description": "langchain.chains.LLMChain",
        "isExtraImport": true,
        "detail": "langchain.chains.LLMChain",
        "documentation": {}
    },
    {
        "label": "ChatPromptTemplate",
        "importPath": "langchain.prompts.chat",
        "description": "langchain.prompts.chat",
        "isExtraImport": true,
        "detail": "langchain.prompts.chat",
        "documentation": {}
    },
    {
        "label": "SystemMessagePromptTemplate",
        "importPath": "langchain.prompts.chat",
        "description": "langchain.prompts.chat",
        "isExtraImport": true,
        "detail": "langchain.prompts.chat",
        "documentation": {}
    },
    {
        "label": "AIMessagePromptTemplate",
        "importPath": "langchain.prompts.chat",
        "description": "langchain.prompts.chat",
        "isExtraImport": true,
        "detail": "langchain.prompts.chat",
        "documentation": {}
    },
    {
        "label": "HumanMessagePromptTemplate",
        "importPath": "langchain.prompts.chat",
        "description": "langchain.prompts.chat",
        "isExtraImport": true,
        "detail": "langchain.prompts.chat",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "setup",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "find_packages",
        "importPath": "setuptools",
        "description": "setuptools",
        "isExtraImport": true,
        "detail": "setuptools",
        "documentation": {}
    },
    {
        "label": "webdriver",
        "importPath": "selenium",
        "description": "selenium",
        "isExtraImport": true,
        "detail": "selenium",
        "documentation": {}
    },
    {
        "label": "Service",
        "importPath": "selenium.webdriver.chrome.service",
        "description": "selenium.webdriver.chrome.service",
        "isExtraImport": true,
        "detail": "selenium.webdriver.chrome.service",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "MetaKernel",
        "importPath": "metakernel",
        "description": "metakernel",
        "isExtraImport": true,
        "detail": "metakernel",
        "documentation": {}
    },
    {
        "label": "MetaKernel",
        "importPath": "metakernel",
        "description": "metakernel",
        "isExtraImport": true,
        "detail": "metakernel",
        "documentation": {}
    },
    {
        "label": "Kernel",
        "importPath": "ipykernel.kernelbase",
        "description": "ipykernel.kernelbase",
        "isExtraImport": true,
        "detail": "ipykernel.kernelbase",
        "documentation": {}
    },
    {
        "label": "replwrap",
        "importPath": "pexpect",
        "description": "pexpect",
        "isExtraImport": true,
        "detail": "pexpect",
        "documentation": {}
    },
    {
        "label": "EOF",
        "importPath": "pexpect",
        "description": "pexpect",
        "isExtraImport": true,
        "detail": "pexpect",
        "documentation": {}
    },
    {
        "label": "ExtendedMeTTa",
        "importPath": "metta_learner ",
        "description": "metta_learner ",
        "isExtraImport": true,
        "detail": "metta_learner ",
        "documentation": {}
    },
    {
        "label": "signal",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "signal",
        "description": "signal",
        "detail": "signal",
        "documentation": {}
    },
    {
        "label": "KernelSpecManager",
        "importPath": "jupyter_client.kernelspec",
        "description": "jupyter_client.kernelspec",
        "isExtraImport": true,
        "detail": "jupyter_client.kernelspec",
        "documentation": {}
    },
    {
        "label": "atexit,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "atexit.",
        "description": "atexit.",
        "detail": "atexit.",
        "documentation": {}
    },
    {
        "label": "chardet",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "chardet",
        "description": "chardet",
        "detail": "chardet",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "Iterable",
        "importPath": "collections.abc",
        "description": "collections.abc",
        "isExtraImport": true,
        "detail": "collections.abc",
        "documentation": {}
    },
    {
        "label": "io",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "io",
        "description": "io",
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "count_atoms",
        "kind": 2,
        "importPath": "examples.examples.extended_compat.hyperon-miner.utils.helper",
        "description": "examples.examples.extended_compat.hyperon-miner.utils.helper",
        "peekOfCode": "def count_atoms():\n    count = OperationAtom(\n        'tuple-count', \n        lambda atom: [ValueAtom(len(atom.get_children()), 'Number')], [AtomType.ATOM, \"Number\"], \n        unwrap=False)\n    return {\n        r\"tuple-count\": count\n    }",
        "detail": "examples.examples.extended_compat.hyperon-miner.utils.helper",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 2,
        "importPath": "examples.examples.extended_compat.metta-examples.logic.puzzle",
        "description": "examples.examples.extended_compat.metta-examples.logic.puzzle",
        "peekOfCode": "def test():\n        program = '''\n                (: quote (-> Atom Atom))\n                ; convert (a b c) to (Cons a (Cons b (Cons c Nil)))\n                (: makelist (-> Atom Atom))\n                (= (makelist $x)\n                    (if (== () $x) Nil (let $cdr (cdr-atom $x) \n                                                (Cons (car-atom $x) (makelist $cdr)))\n                    )\n                )",
        "detail": "examples.examples.extended_compat.metta-examples.logic.puzzle",
        "documentation": {}
    },
    {
        "label": "MeTTa",
        "kind": 6,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "class MeTTa:\n    def __init__(self, space=None):\n        self.space = GroundingSpace(\"&self\") if space is None else space\n        self.tokenizer = Tokenizer()\n        self.cwd = []  # current working directory as an array\n        self._tokenizer()\n    def _tokenizer(self):\n        self.add_atom(r\"\\+\", addAtom)\n        self.add_atom(r\"-\", subAtom)\n        self.add_atom(r\"\\*\", mulAtom)",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "match_op",
        "kind": 2,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def match_op(space, pattern, templ_op):\n    space = space.get_object().value\n    return space.subst(pattern, templ_op)\ndef let_op(pattern, atom, templ):\n    space = GroundingSpace()\n    space.add_atom(atom)\n    return space.subst(pattern, templ)\ndef transfer_op(metta, fname):\n    \"\"\"\n    Transfers all atoms from the specified file to the current Space.",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "let_op",
        "kind": 2,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def let_op(pattern, atom, templ):\n    space = GroundingSpace()\n    space.add_atom(atom)\n    return space.subst(pattern, templ)\ndef transfer_op(metta, fname):\n    \"\"\"\n    Transfers all atoms from the specified file to the current Space.\n    \"\"\"\n    metta2 = MeTTa()\n    metta2.cwd = metta.cwd  # inherit current working directory",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "transfer_op",
        "kind": 2,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def transfer_op(metta, fname):\n    \"\"\"\n    Transfers all atoms from the specified file to the current Space.\n    \"\"\"\n    metta2 = MeTTa()\n    metta2.cwd = metta.cwd  # inherit current working directory\n    metta2.import_file(fname.get_object().value)\n    for atom in metta2.space.get_atoms():\n        metta.space.add_atom(atom)\n    return []",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "make_transfer_op",
        "kind": 2,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def make_transfer_op(metta):\n    return OperationAtom(\n        'transfer!',\n        lambda file: transfer_op(metta, file),\n        unwrap=False)\ndef make_all_atoms_op(metta):\n    return OperationAtom(\n        'all',\n        lambda: metta.space.get_atoms(),\n        unwrap=False)",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "make_all_atoms_op",
        "kind": 2,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def make_all_atoms_op(metta):\n    return OperationAtom(\n        'all',\n        lambda: metta.space.get_atoms(),\n        unwrap=False)\ndef letrec_op(subs, body):\n    # just unsugaring `let*`` into `let` substitution by substitution\n    subs = subs.get_children()\n    if len(subs) == 0:\n        return [body]",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "letrec_op",
        "kind": 2,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def letrec_op(subs, body):\n    # just unsugaring `let*`` into `let` substitution by substitution\n    subs = subs.get_children()\n    if len(subs) == 0:\n        return [body]\n    next_sub = subs[0].get_children()\n    if len(subs) == 1:\n        return [E(letAtom, next_sub[0], next_sub[1], body)]\n    return [E(letAtom, next_sub[0], next_sub[1], E(letrecAtom, E(*subs[1:]), body))]\ndef call_atom_op(atom, method_str, *args):",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "call_atom_op",
        "kind": 2,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def call_atom_op(atom, method_str, *args):\n    if not isinstance(atom, GroundedAtom):\n        raise NoReduceError()\n    obj = atom.get_object().value\n    method = getattr(obj, method_str)\n    result = method(*args)\n    if result is None:\n        return []\n    # Fixme? getting results from call_atom raises some issues but convenient.\n    # Running example is call:... &self (or another imported space)",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "print_op",
        "kind": 2,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def print_op(atom):\n    print(atom)\n    return []\ndef assert_results_equal(result, expected):\n    report = \"Expected: \" + str(expected) + \"\\nGot: \" + str(result)\n    for r in result:\n        if r not in expected:\n            raise RuntimeError(report + \"\\nExcessive result: \" + str(r))\n    for e in expected:\n        if e not in result:",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "assert_results_equal",
        "kind": 2,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def assert_results_equal(result, expected):\n    report = \"Expected: \" + str(expected) + \"\\nGot: \" + str(result)\n    for r in result:\n        if r not in expected:\n            raise RuntimeError(report + \"\\nExcessive result: \" + str(r))\n    for e in expected:\n        if e not in result:\n            raise RuntimeError(report + \"\\nMissed result: \" + str(e))\n    if len(expected) != len(result):\n        # NOTE: (1 1 2) vs (1 2 2) will pass",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "make_assert_equal_atom",
        "kind": 2,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def make_assert_equal_atom(metta):\n    return OperationAtom(\n        'assertEqual',\n        lambda e1, e2: assert_results_equal(interpret(metta.space, e1), interpret(metta.space, e2)),\n        [AtomType.ATOM, AtomType.ATOM, AtomType.ATOM],\n        unwrap=False)\ndef make_assert_equal_to_result_atom(metta):\n    return OperationAtom(\n        'assertEqualToResult',\n        lambda expr, expected: assert_results_equal(interpret(metta.space, expr), expected.get_children()),",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "make_assert_equal_to_result_atom",
        "kind": 2,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def make_assert_equal_to_result_atom(metta):\n    return OperationAtom(\n        'assertEqualToResult',\n        lambda expr, expected: assert_results_equal(interpret(metta.space, expr), expected.get_children()),\n        [AtomType.ATOM, AtomType.ATOM, AtomType.ATOM],\n        unwrap=False)\n# E(S('->'), S('Number'), S('Number'), S('Number'))\nsubAtom = OperationAtom('-', lambda a, b: a - b, ['Number', 'Number', 'Number'])\nmulAtom = OperationAtom('*', lambda a, b: a * b, ['Number', 'Number', 'Number'])\naddAtom = OperationAtom('+', lambda a, b: a + b, ['Number', 'Number', 'Number'])",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "make_call_atom",
        "kind": 2,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def make_call_atom(token):\n    # NOTE: we could use \"call\" as a plain symbol (insted of \"call:...\")\n    #       with the method name as the parameter of call_atom_op\n    #       (but this parameter should be unwrapped)\n    # \"call:...\" is an interesting example of families of tokens for ops, though\n    return OperationAtom(\n        token,\n        lambda obj, *args: call_atom_op(obj, token[5:], *args),\n        unwrap=False)\ndef SpaceAtom(grounding_space, repr_name=None):",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "SpaceAtom",
        "kind": 2,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def SpaceAtom(grounding_space, repr_name=None):\n    # Overriding grounding_space.repr_name here\n    # It will be changed in all occurences of this Space\n    if repr_name is not None:\n        grounding_space.repr_name = repr_name\n    return ValueAtom(grounding_space, 'Space')\ndef import_op(metta, space, fname):\n    # Check if space wasn't resolved\n    if space.get_type() == AtomKind.SYMBOL:\n        # Create new space",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "import_op",
        "kind": 2,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def import_op(metta, space, fname):\n    # Check if space wasn't resolved\n    if space.get_type() == AtomKind.SYMBOL:\n        # Create new space\n        name = space.get_name()\n        space = GroundingSpace()\n        # Register this space under name `name`\n        metta.add_atom(name, SpaceAtom(space, name))\n    else:\n        space = space.get_object().value",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "make_import_op",
        "kind": 2,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def make_import_op(metta):\n    # unwrap=False, because space name can remain\n    # an unresolved symbol atom\n    return OperationAtom(\n        'import!',\n        lambda s, f: import_op(metta, s, f),\n        unwrap=False)\ndef pragma_op(metta, key, *args):\n    # TODO: add support for Grounded values when needed\n    metta.settings[key.get_name()] = \\",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "pragma_op",
        "kind": 2,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def pragma_op(metta, key, *args):\n    # TODO: add support for Grounded values when needed\n    metta.settings[key.get_name()] = \\\n        args[0].get_name() if len(args) == 1 else \\\n            [arg.get_name() for arg in args]\n    return []\ndef make_pragma_op(metta):\n    return OperationAtom(\n        'pragma!',\n        lambda key, *args: pragma_op(metta, key, *args),",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "make_pragma_op",
        "kind": 2,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def make_pragma_op(metta):\n    return OperationAtom(\n        'pragma!',\n        lambda key, *args: pragma_op(metta, key, *args),\n        unwrap=False)\ndef make_collapse_atom(metta):\n    # FIXME? Calling interpreter inside the operation is not too good\n    #        Could it be done via StepResult?\n    return OperationAtom(\n        'collapse',",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "make_collapse_atom",
        "kind": 2,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def make_collapse_atom(metta):\n    # FIXME? Calling interpreter inside the operation is not too good\n    #        Could it be done via StepResult?\n    return OperationAtom(\n        'collapse',\n        lambda atom: [E(*interpret(metta.space, atom))],\n        [AtomType.ATOM, AtomType.ATOM],\n        unwrap=False)\n# `superpose` receives one atom (expression) in order to make composition\n# `(superpose (collapse ...))` possible",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "superpose_op",
        "kind": 2,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def superpose_op(expr):\n    if isinstance(expr, ExpressionAtom):\n        return [arg for arg in expr.get_children()]\n    return [expr]\nsuperposeAtom = OperationAtom('superpose', superpose_op, unwrap=False)\ndef color(t, c):\n    cmap = [90, 91, 31, 93, 92, 32, 36, 96, 94, 34, 35, 95, 38]\n    return f\"\\033[{cmap[c % len(cmap)]}m{t}\\033[0m\"\ndef oblique(t):\n    return f\"\\033[3m{t}\\033[0m\"",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "color",
        "kind": 2,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def color(t, c):\n    cmap = [90, 91, 31, 93, 92, 32, 36, 96, 94, 34, 35, 95, 38]\n    return f\"\\033[{cmap[c % len(cmap)]}m{t}\\033[0m\"\ndef oblique(t):\n    return f\"\\033[3m{t}\\033[0m\"\ndef underline(t):\n    return f\"\\033[4m{t}\\033[0m\"\ndef expr_vars(expr):\n    if isinstance(expr, SymbolAtom):\n        return []",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "oblique",
        "kind": 2,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def oblique(t):\n    return f\"\\033[3m{t}\\033[0m\"\ndef underline(t):\n    return f\"\\033[4m{t}\\033[0m\"\ndef expr_vars(expr):\n    if isinstance(expr, SymbolAtom):\n        return []\n    elif isinstance(expr, VariableAtom):\n        return [str(expr)]\n    elif isinstance(expr, ExpressionAtom):",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "underline",
        "kind": 2,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def underline(t):\n    return f\"\\033[4m{t}\\033[0m\"\ndef expr_vars(expr):\n    if isinstance(expr, SymbolAtom):\n        return []\n    elif isinstance(expr, VariableAtom):\n        return [str(expr)]\n    elif isinstance(expr, ExpressionAtom):\n        return [e for c in expr.get_children() for e in expr_vars(c)]\n    elif isinstance(expr, GroundedAtom):",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "expr_vars",
        "kind": 2,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def expr_vars(expr):\n    if isinstance(expr, SymbolAtom):\n        return []\n    elif isinstance(expr, VariableAtom):\n        return [str(expr)]\n    elif isinstance(expr, ExpressionAtom):\n        return [e for c in expr.get_children() for e in expr_vars(c)]\n    elif isinstance(expr, GroundedAtom):\n        return []\n    else:",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "color_expr",
        "kind": 2,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def color_expr(expr, level=0, unif_vars=None):\n    name = str(expr)\n    if level == 0:\n        unif_vars = frozenset(e for e, c in Counter(expr_vars(expr)).items() if c > 1) \\\n            if unif_vars is None else frozenset()\n    if isinstance(expr, SymbolAtom):\n        return name\n    elif isinstance(expr, VariableAtom):\n        return oblique(name) if name in unif_vars else name\n    elif isinstance(expr, ExpressionAtom):",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "subAtom",
        "kind": 5,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "subAtom = OperationAtom('-', lambda a, b: a - b, ['Number', 'Number', 'Number'])\nmulAtom = OperationAtom('*', lambda a, b: a * b, ['Number', 'Number', 'Number'])\naddAtom = OperationAtom('+', lambda a, b: a + b, ['Number', 'Number', 'Number'])\ndivAtom = OperationAtom('/', lambda a, b: a / b, ['Number', 'Number', 'Number'])\nmodAtom = OperationAtom('%', lambda a, b: a % b, ['Number', 'Number', 'Number'])\nequalAtom = OperationAtom('==', lambda a, b: a == b, ['$t', '$t', 'Bool'])\ngreaterAtom = OperationAtom('>', lambda a, b: a > b, ['Number', 'Number', 'Bool'])\nlessAtom = OperationAtom('<', lambda a, b: a < b, ['Number', 'Number', 'Bool'])\norAtom = OperationAtom('or', lambda a, b: a or b, ['Bool', 'Bool', 'Bool'])\nandAtom = OperationAtom('and', lambda a, b: a and b, ['Bool', 'Bool', 'Bool'])",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "mulAtom",
        "kind": 5,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "mulAtom = OperationAtom('*', lambda a, b: a * b, ['Number', 'Number', 'Number'])\naddAtom = OperationAtom('+', lambda a, b: a + b, ['Number', 'Number', 'Number'])\ndivAtom = OperationAtom('/', lambda a, b: a / b, ['Number', 'Number', 'Number'])\nmodAtom = OperationAtom('%', lambda a, b: a % b, ['Number', 'Number', 'Number'])\nequalAtom = OperationAtom('==', lambda a, b: a == b, ['$t', '$t', 'Bool'])\ngreaterAtom = OperationAtom('>', lambda a, b: a > b, ['Number', 'Number', 'Bool'])\nlessAtom = OperationAtom('<', lambda a, b: a < b, ['Number', 'Number', 'Bool'])\norAtom = OperationAtom('or', lambda a, b: a or b, ['Bool', 'Bool', 'Bool'])\nandAtom = OperationAtom('and', lambda a, b: a and b, ['Bool', 'Bool', 'Bool'])\nnotAtom = OperationAtom('not', lambda a: not a, ['Bool', 'Bool'])",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "addAtom",
        "kind": 5,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "addAtom = OperationAtom('+', lambda a, b: a + b, ['Number', 'Number', 'Number'])\ndivAtom = OperationAtom('/', lambda a, b: a / b, ['Number', 'Number', 'Number'])\nmodAtom = OperationAtom('%', lambda a, b: a % b, ['Number', 'Number', 'Number'])\nequalAtom = OperationAtom('==', lambda a, b: a == b, ['$t', '$t', 'Bool'])\ngreaterAtom = OperationAtom('>', lambda a, b: a > b, ['Number', 'Number', 'Bool'])\nlessAtom = OperationAtom('<', lambda a, b: a < b, ['Number', 'Number', 'Bool'])\norAtom = OperationAtom('or', lambda a, b: a or b, ['Bool', 'Bool', 'Bool'])\nandAtom = OperationAtom('and', lambda a, b: a and b, ['Bool', 'Bool', 'Bool'])\nnotAtom = OperationAtom('not', lambda a: not a, ['Bool', 'Bool'])\n# Any number of arguments for `nop` (including zero) due to *args",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "divAtom",
        "kind": 5,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "divAtom = OperationAtom('/', lambda a, b: a / b, ['Number', 'Number', 'Number'])\nmodAtom = OperationAtom('%', lambda a, b: a % b, ['Number', 'Number', 'Number'])\nequalAtom = OperationAtom('==', lambda a, b: a == b, ['$t', '$t', 'Bool'])\ngreaterAtom = OperationAtom('>', lambda a, b: a > b, ['Number', 'Number', 'Bool'])\nlessAtom = OperationAtom('<', lambda a, b: a < b, ['Number', 'Number', 'Bool'])\norAtom = OperationAtom('or', lambda a, b: a or b, ['Bool', 'Bool', 'Bool'])\nandAtom = OperationAtom('and', lambda a, b: a and b, ['Bool', 'Bool', 'Bool'])\nnotAtom = OperationAtom('not', lambda a: not a, ['Bool', 'Bool'])\n# Any number of arguments for `nop` (including zero) due to *args\nnopAtom = OperationAtom('nop', lambda *args: [], unwrap=False)",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "modAtom",
        "kind": 5,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "modAtom = OperationAtom('%', lambda a, b: a % b, ['Number', 'Number', 'Number'])\nequalAtom = OperationAtom('==', lambda a, b: a == b, ['$t', '$t', 'Bool'])\ngreaterAtom = OperationAtom('>', lambda a, b: a > b, ['Number', 'Number', 'Bool'])\nlessAtom = OperationAtom('<', lambda a, b: a < b, ['Number', 'Number', 'Bool'])\norAtom = OperationAtom('or', lambda a, b: a or b, ['Bool', 'Bool', 'Bool'])\nandAtom = OperationAtom('and', lambda a, b: a and b, ['Bool', 'Bool', 'Bool'])\nnotAtom = OperationAtom('not', lambda a: not a, ['Bool', 'Bool'])\n# Any number of arguments for `nop` (including zero) due to *args\nnopAtom = OperationAtom('nop', lambda *args: [], unwrap=False)\n# FIXME? Undefined for the argument is necessary to make argument reductable.",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "equalAtom",
        "kind": 5,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "equalAtom = OperationAtom('==', lambda a, b: a == b, ['$t', '$t', 'Bool'])\ngreaterAtom = OperationAtom('>', lambda a, b: a > b, ['Number', 'Number', 'Bool'])\nlessAtom = OperationAtom('<', lambda a, b: a < b, ['Number', 'Number', 'Bool'])\norAtom = OperationAtom('or', lambda a, b: a or b, ['Bool', 'Bool', 'Bool'])\nandAtom = OperationAtom('and', lambda a, b: a and b, ['Bool', 'Bool', 'Bool'])\nnotAtom = OperationAtom('not', lambda a: not a, ['Bool', 'Bool'])\n# Any number of arguments for `nop` (including zero) due to *args\nnopAtom = OperationAtom('nop', lambda *args: [], unwrap=False)\n# FIXME? Undefined for the argument is necessary to make argument reductable.\nletAtom = OperationAtom('let', let_op,",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "greaterAtom",
        "kind": 5,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "greaterAtom = OperationAtom('>', lambda a, b: a > b, ['Number', 'Number', 'Bool'])\nlessAtom = OperationAtom('<', lambda a, b: a < b, ['Number', 'Number', 'Bool'])\norAtom = OperationAtom('or', lambda a, b: a or b, ['Bool', 'Bool', 'Bool'])\nandAtom = OperationAtom('and', lambda a, b: a and b, ['Bool', 'Bool', 'Bool'])\nnotAtom = OperationAtom('not', lambda a: not a, ['Bool', 'Bool'])\n# Any number of arguments for `nop` (including zero) due to *args\nnopAtom = OperationAtom('nop', lambda *args: [], unwrap=False)\n# FIXME? Undefined for the argument is necessary to make argument reductable.\nletAtom = OperationAtom('let', let_op,\n                        type_names=[AtomType.VARIABLE, AtomType.UNDEFINED, AtomType.ATOM, AtomType.ATOM], unwrap=False)",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "lessAtom",
        "kind": 5,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "lessAtom = OperationAtom('<', lambda a, b: a < b, ['Number', 'Number', 'Bool'])\norAtom = OperationAtom('or', lambda a, b: a or b, ['Bool', 'Bool', 'Bool'])\nandAtom = OperationAtom('and', lambda a, b: a and b, ['Bool', 'Bool', 'Bool'])\nnotAtom = OperationAtom('not', lambda a: not a, ['Bool', 'Bool'])\n# Any number of arguments for `nop` (including zero) due to *args\nnopAtom = OperationAtom('nop', lambda *args: [], unwrap=False)\n# FIXME? Undefined for the argument is necessary to make argument reductable.\nletAtom = OperationAtom('let', let_op,\n                        type_names=[AtomType.VARIABLE, AtomType.UNDEFINED, AtomType.ATOM, AtomType.ATOM], unwrap=False)\n# The first argument is an Atom, because it has to be evaluated iteratively",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "orAtom",
        "kind": 5,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "orAtom = OperationAtom('or', lambda a, b: a or b, ['Bool', 'Bool', 'Bool'])\nandAtom = OperationAtom('and', lambda a, b: a and b, ['Bool', 'Bool', 'Bool'])\nnotAtom = OperationAtom('not', lambda a: not a, ['Bool', 'Bool'])\n# Any number of arguments for `nop` (including zero) due to *args\nnopAtom = OperationAtom('nop', lambda *args: [], unwrap=False)\n# FIXME? Undefined for the argument is necessary to make argument reductable.\nletAtom = OperationAtom('let', let_op,\n                        type_names=[AtomType.VARIABLE, AtomType.UNDEFINED, AtomType.ATOM, AtomType.ATOM], unwrap=False)\n# The first argument is an Atom, because it has to be evaluated iteratively\nletrecAtom = OperationAtom('let*', letrec_op,",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "andAtom",
        "kind": 5,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "andAtom = OperationAtom('and', lambda a, b: a and b, ['Bool', 'Bool', 'Bool'])\nnotAtom = OperationAtom('not', lambda a: not a, ['Bool', 'Bool'])\n# Any number of arguments for `nop` (including zero) due to *args\nnopAtom = OperationAtom('nop', lambda *args: [], unwrap=False)\n# FIXME? Undefined for the argument is necessary to make argument reductable.\nletAtom = OperationAtom('let', let_op,\n                        type_names=[AtomType.VARIABLE, AtomType.UNDEFINED, AtomType.ATOM, AtomType.ATOM], unwrap=False)\n# The first argument is an Atom, because it has to be evaluated iteratively\nletrecAtom = OperationAtom('let*', letrec_op,\n                           type_names=[AtomType.ATOM, AtomType.ATOM, AtomType.ATOM], unwrap=False)",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "notAtom",
        "kind": 5,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "notAtom = OperationAtom('not', lambda a: not a, ['Bool', 'Bool'])\n# Any number of arguments for `nop` (including zero) due to *args\nnopAtom = OperationAtom('nop', lambda *args: [], unwrap=False)\n# FIXME? Undefined for the argument is necessary to make argument reductable.\nletAtom = OperationAtom('let', let_op,\n                        type_names=[AtomType.VARIABLE, AtomType.UNDEFINED, AtomType.ATOM, AtomType.ATOM], unwrap=False)\n# The first argument is an Atom, because it has to be evaluated iteratively\nletrecAtom = OperationAtom('let*', letrec_op,\n                           type_names=[AtomType.ATOM, AtomType.ATOM, AtomType.ATOM], unwrap=False)\nmatchAtom = OperationAtom('match', match_op,",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "nopAtom",
        "kind": 5,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "nopAtom = OperationAtom('nop', lambda *args: [], unwrap=False)\n# FIXME? Undefined for the argument is necessary to make argument reductable.\nletAtom = OperationAtom('let', let_op,\n                        type_names=[AtomType.VARIABLE, AtomType.UNDEFINED, AtomType.ATOM, AtomType.ATOM], unwrap=False)\n# The first argument is an Atom, because it has to be evaluated iteratively\nletrecAtom = OperationAtom('let*', letrec_op,\n                           type_names=[AtomType.ATOM, AtomType.ATOM, AtomType.ATOM], unwrap=False)\nmatchAtom = OperationAtom('match', match_op,\n                          type_names=[\"Space\", AtomType.ATOM, AtomType.ATOM, AtomType.UNDEFINED], unwrap=False)\nprintAtom = OperationAtom('println!', print_op, [AtomType.UNDEFINED, 'IO'], unwrap=False)",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "letAtom",
        "kind": 5,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "letAtom = OperationAtom('let', let_op,\n                        type_names=[AtomType.VARIABLE, AtomType.UNDEFINED, AtomType.ATOM, AtomType.ATOM], unwrap=False)\n# The first argument is an Atom, because it has to be evaluated iteratively\nletrecAtom = OperationAtom('let*', letrec_op,\n                           type_names=[AtomType.ATOM, AtomType.ATOM, AtomType.ATOM], unwrap=False)\nmatchAtom = OperationAtom('match', match_op,\n                          type_names=[\"Space\", AtomType.ATOM, AtomType.ATOM, AtomType.UNDEFINED], unwrap=False)\nprintAtom = OperationAtom('println!', print_op, [AtomType.UNDEFINED, 'IO'], unwrap=False)\ndef make_call_atom(token):\n    # NOTE: we could use \"call\" as a plain symbol (insted of \"call:...\")",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "letrecAtom",
        "kind": 5,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "letrecAtom = OperationAtom('let*', letrec_op,\n                           type_names=[AtomType.ATOM, AtomType.ATOM, AtomType.ATOM], unwrap=False)\nmatchAtom = OperationAtom('match', match_op,\n                          type_names=[\"Space\", AtomType.ATOM, AtomType.ATOM, AtomType.UNDEFINED], unwrap=False)\nprintAtom = OperationAtom('println!', print_op, [AtomType.UNDEFINED, 'IO'], unwrap=False)\ndef make_call_atom(token):\n    # NOTE: we could use \"call\" as a plain symbol (insted of \"call:...\")\n    #       with the method name as the parameter of call_atom_op\n    #       (but this parameter should be unwrapped)\n    # \"call:...\" is an interesting example of families of tokens for ops, though",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "matchAtom",
        "kind": 5,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "matchAtom = OperationAtom('match', match_op,\n                          type_names=[\"Space\", AtomType.ATOM, AtomType.ATOM, AtomType.UNDEFINED], unwrap=False)\nprintAtom = OperationAtom('println!', print_op, [AtomType.UNDEFINED, 'IO'], unwrap=False)\ndef make_call_atom(token):\n    # NOTE: we could use \"call\" as a plain symbol (insted of \"call:...\")\n    #       with the method name as the parameter of call_atom_op\n    #       (but this parameter should be unwrapped)\n    # \"call:...\" is an interesting example of families of tokens for ops, though\n    return OperationAtom(\n        token,",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "printAtom",
        "kind": 5,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "printAtom = OperationAtom('println!', print_op, [AtomType.UNDEFINED, 'IO'], unwrap=False)\ndef make_call_atom(token):\n    # NOTE: we could use \"call\" as a plain symbol (insted of \"call:...\")\n    #       with the method name as the parameter of call_atom_op\n    #       (but this parameter should be unwrapped)\n    # \"call:...\" is an interesting example of families of tokens for ops, though\n    return OperationAtom(\n        token,\n        lambda obj, *args: call_atom_op(obj, token[5:], *args),\n        unwrap=False)",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "superposeAtom",
        "kind": 5,
        "importPath": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "superposeAtom = OperationAtom('superpose', superpose_op, unwrap=False)\ndef color(t, c):\n    cmap = [90, 91, 31, 93, 92, 32, 36, 96, 94, 34, 35, 95, 38]\n    return f\"\\033[{cmap[c % len(cmap)]}m{t}\\033[0m\"\ndef oblique(t):\n    return f\"\\033[3m{t}\\033[0m\"\ndef underline(t):\n    return f\"\\033[4m{t}\\033[0m\"\ndef expr_vars(expr):\n    if isinstance(expr, SymbolAtom):",
        "detail": "examples.examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "updateSeed",
        "kind": 2,
        "importPath": "examples.examples.extended_compat.metta-examples.SICP_book.additional_funcs",
        "description": "examples.examples.extended_compat.metta-examples.SICP_book.additional_funcs",
        "peekOfCode": "def updateSeed():\n    random.seed(getCurTime())\ndef getRandInt(start, end):\n    updateSeed()\n    return random.randint(start, end)\ndef getCurTime():\n    return time.time_ns() / (10 ** 6)\n@register_atoms\ndef my_glob_atoms():\n    return {",
        "detail": "examples.examples.extended_compat.metta-examples.SICP_book.additional_funcs",
        "documentation": {}
    },
    {
        "label": "getRandInt",
        "kind": 2,
        "importPath": "examples.examples.extended_compat.metta-examples.SICP_book.additional_funcs",
        "description": "examples.examples.extended_compat.metta-examples.SICP_book.additional_funcs",
        "peekOfCode": "def getRandInt(start, end):\n    updateSeed()\n    return random.randint(start, end)\ndef getCurTime():\n    return time.time_ns() / (10 ** 6)\n@register_atoms\ndef my_glob_atoms():\n    return {\n        'randomint!': OperationAtom(\"randomint!\", getRandInt),\n        'timems!': OperationAtom(\"timems!\", getCurTime),",
        "detail": "examples.examples.extended_compat.metta-examples.SICP_book.additional_funcs",
        "documentation": {}
    },
    {
        "label": "getCurTime",
        "kind": 2,
        "importPath": "examples.examples.extended_compat.metta-examples.SICP_book.additional_funcs",
        "description": "examples.examples.extended_compat.metta-examples.SICP_book.additional_funcs",
        "peekOfCode": "def getCurTime():\n    return time.time_ns() / (10 ** 6)\n@register_atoms\ndef my_glob_atoms():\n    return {\n        'randomint!': OperationAtom(\"randomint!\", getRandInt),\n        'timems!': OperationAtom(\"timems!\", getCurTime),\n        }",
        "detail": "examples.examples.extended_compat.metta-examples.SICP_book.additional_funcs",
        "documentation": {}
    },
    {
        "label": "my_glob_atoms",
        "kind": 2,
        "importPath": "examples.examples.extended_compat.metta-examples.SICP_book.additional_funcs",
        "description": "examples.examples.extended_compat.metta-examples.SICP_book.additional_funcs",
        "peekOfCode": "def my_glob_atoms():\n    return {\n        'randomint!': OperationAtom(\"randomint!\", getRandInt),\n        'timems!': OperationAtom(\"timems!\", getCurTime),\n        }",
        "detail": "examples.examples.extended_compat.metta-examples.SICP_book.additional_funcs",
        "documentation": {}
    },
    {
        "label": "query",
        "kind": 2,
        "importPath": "examples.examples.flybase.from_das.mettalog_das_client",
        "description": "examples.examples.flybase.from_das.mettalog_das_client",
        "peekOfCode": "def query(das, symbol, node_type = None):\n    fbgns = _fbgns(das, symbol)\n    print(f\"FBgn: {fbgns}\")\n    answer = []\n    for fbgn in fbgns:\n        query_answer = das.query({\n            \"atom_type\": \"link\",\n            \"type\": \"Execution\",\n            \"targets\": [\n                {\"atom_type\": \"variable\", \"name\": \"v0\"},",
        "detail": "examples.examples.flybase.from_das.mettalog_das_client",
        "documentation": {}
    },
    {
        "label": "host",
        "kind": 5,
        "importPath": "examples.examples.flybase.from_das.mettalog_das_client",
        "description": "examples.examples.flybase.from_das.mettalog_das_client",
        "peekOfCode": "host = '104.238.183.115'\nport = '8081'\ndas = DistributedAtomSpace(query_engine='remote', host=host, port=port)\nprint(f\"Connected to DAS at {host}:{port}\")\ndef _filter(query_answer, index, value):\n    filtered = []\n    for link in query_answer:\n        if link['targets'][index]['type'] == value:\n            filtered.append(link)\n    return filtered",
        "detail": "examples.examples.flybase.from_das.mettalog_das_client",
        "documentation": {}
    },
    {
        "label": "port",
        "kind": 5,
        "importPath": "examples.examples.flybase.from_das.mettalog_das_client",
        "description": "examples.examples.flybase.from_das.mettalog_das_client",
        "peekOfCode": "port = '8081'\ndas = DistributedAtomSpace(query_engine='remote', host=host, port=port)\nprint(f\"Connected to DAS at {host}:{port}\")\ndef _filter(query_answer, index, value):\n    filtered = []\n    for link in query_answer:\n        if link['targets'][index]['type'] == value:\n            filtered.append(link)\n    return filtered\ndef _fbgns(das, symbol, handles=False):",
        "detail": "examples.examples.flybase.from_das.mettalog_das_client",
        "documentation": {}
    },
    {
        "label": "das",
        "kind": 5,
        "importPath": "examples.examples.flybase.from_das.mettalog_das_client",
        "description": "examples.examples.flybase.from_das.mettalog_das_client",
        "peekOfCode": "das = DistributedAtomSpace(query_engine='remote', host=host, port=port)\nprint(f\"Connected to DAS at {host}:{port}\")\ndef _filter(query_answer, index, value):\n    filtered = []\n    for link in query_answer:\n        if link['targets'][index]['type'] == value:\n            filtered.append(link)\n    return filtered\ndef _fbgns(das, symbol, handles=False):\n    answer = das.query({",
        "detail": "examples.examples.flybase.from_das.mettalog_das_client",
        "documentation": {}
    },
    {
        "label": "query",
        "kind": 2,
        "importPath": "examples.examples.flybase.from_das.script_example_BIO",
        "description": "examples.examples.flybase.from_das.script_example_BIO",
        "peekOfCode": "def query(das, symbol, node_type = None):\n    fbgns = _fbgns(das, symbol)\n    print(f\"FBgn: {fbgns}\")\n    answer = []\n    for fbgn in fbgns:\n        query_answer = das.query({\n            \"atom_type\": \"link\",\n            \"type\": \"Execution\",\n            \"targets\": [\n                {\"atom_type\": \"variable\", \"name\": \"v0\"},",
        "detail": "examples.examples.flybase.from_das.script_example_BIO",
        "documentation": {}
    },
    {
        "label": "host",
        "kind": 5,
        "importPath": "examples.examples.flybase.from_das.script_example_BIO",
        "description": "examples.examples.flybase.from_das.script_example_BIO",
        "peekOfCode": "host = '104.238.183.115'\nport = '8081'\ndas = DistributedAtomSpace(query_engine='remote', host=host, port=port)\nprint(f\"Connected to DAS at {host}:{port}\")\ndef _filter(query_answer, index, value):\n    filtered = []\n    for link in query_answer:\n        if link['targets'][index]['type'] == value:\n            filtered.append(link)\n    return filtered",
        "detail": "examples.examples.flybase.from_das.script_example_BIO",
        "documentation": {}
    },
    {
        "label": "port",
        "kind": 5,
        "importPath": "examples.examples.flybase.from_das.script_example_BIO",
        "description": "examples.examples.flybase.from_das.script_example_BIO",
        "peekOfCode": "port = '8081'\ndas = DistributedAtomSpace(query_engine='remote', host=host, port=port)\nprint(f\"Connected to DAS at {host}:{port}\")\ndef _filter(query_answer, index, value):\n    filtered = []\n    for link in query_answer:\n        if link['targets'][index]['type'] == value:\n            filtered.append(link)\n    return filtered\ndef _fbgns(das, symbol, handles=False):",
        "detail": "examples.examples.flybase.from_das.script_example_BIO",
        "documentation": {}
    },
    {
        "label": "das",
        "kind": 5,
        "importPath": "examples.examples.flybase.from_das.script_example_BIO",
        "description": "examples.examples.flybase.from_das.script_example_BIO",
        "peekOfCode": "das = DistributedAtomSpace(query_engine='remote', host=host, port=port)\nprint(f\"Connected to DAS at {host}:{port}\")\ndef _filter(query_answer, index, value):\n    filtered = []\n    for link in query_answer:\n        if link['targets'][index]['type'] == value:\n            filtered.append(link)\n    return filtered\ndef _fbgns(das, symbol, handles=False):\n    answer = das.query({",
        "detail": "examples.examples.flybase.from_das.script_example_BIO",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "examples.examples.performance.gpt2-like.corpus.self_dialogue_corpus.old.get_data",
        "description": "examples.examples.performance.gpt2-like.corpus.self_dialogue_corpus.old.get_data",
        "peekOfCode": "def main():\n    args = parse_args()\n    logger.info(\"Will write data to {0}.\".format(args.outDir))\n    # Create output directories\n    train_dir = create_dirs(args.outDir)\n    if os.path.isfile(\"blocked_workers.txt\"):\n        with open(\"blocked_workers.txt\") as f:\n            blocked_workers = f.read().splitlines()\n    else:\n        blocked_workers = []",
        "detail": "examples.examples.performance.gpt2-like.corpus.self_dialogue_corpus.old.get_data",
        "documentation": {}
    },
    {
        "label": "write_dialogues",
        "kind": 2,
        "importPath": "examples.examples.performance.gpt2-like.corpus.self_dialogue_corpus.old.get_data",
        "description": "examples.examples.performance.gpt2-like.corpus.self_dialogue_corpus.old.get_data",
        "peekOfCode": "def write_dialogues(dialogues, keys, directory, args):\n    \"\"\"Writes dialogues given keys to directory.\"\"\"\n    counter = 0\n    for key in keys:\n        if args.output_naming == \"integer\":\n            filename = counter\n        elif args.output_naming == \"assignment_id\":\n            filename = key\n        dialogue = dialogues[key]\n        with open(\"{0}/{1}.txt\".format(directory, filename), 'w') as f:",
        "detail": "examples.examples.performance.gpt2-like.corpus.self_dialogue_corpus.old.get_data",
        "documentation": {}
    },
    {
        "label": "read_data",
        "kind": 2,
        "importPath": "examples.examples.performance.gpt2-like.corpus.self_dialogue_corpus.old.get_data",
        "description": "examples.examples.performance.gpt2-like.corpus.self_dialogue_corpus.old.get_data",
        "peekOfCode": "def read_data(directory, blocked_workers=[]):\n    \"\"\"Reads data from CSVs in a directory and \n    returns a dictionary indexed by assignment IDs.\n    Ignores workers in blocked_workers list.\"\"\"\n    dialogues = {} # indexed by assignment IDs\n    for filename in glob(\"{0}/*.csv\".format(directory)):\n        with open(filename) as f:\n            csvreader = csv.DictReader(f)\n            for row in csvreader:\n                # if len(restrict_to) > 0:",
        "detail": "examples.examples.performance.gpt2-like.corpus.self_dialogue_corpus.old.get_data",
        "documentation": {}
    },
    {
        "label": "create_dirs",
        "kind": 2,
        "importPath": "examples.examples.performance.gpt2-like.corpus.self_dialogue_corpus.old.get_data",
        "description": "examples.examples.performance.gpt2-like.corpus.self_dialogue_corpus.old.get_data",
        "peekOfCode": "def create_dirs(root_dir):\n    \"\"\"Create training directories. Returns their paths.\"\"\"\n    train_dir = \"{0}/\".format(root_dir)\n    for d in [train_dir]:\n        if not os.path.exists(d):\n            os.makedirs(d)\n    return train_dir \ndef parse_args():\n    \"\"\"Parse input arguments.\"\"\"\n    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter,",
        "detail": "examples.examples.performance.gpt2-like.corpus.self_dialogue_corpus.old.get_data",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "kind": 2,
        "importPath": "examples.examples.performance.gpt2-like.corpus.self_dialogue_corpus.old.get_data",
        "description": "examples.examples.performance.gpt2-like.corpus.self_dialogue_corpus.old.get_data",
        "peekOfCode": "def parse_args():\n    \"\"\"Parse input arguments.\"\"\"\n    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter,\n            description=\"\"\"Prepares data directories with dialogues from the\n            self-dialogue corpus.\"\"\",\n            epilog=\"Example usage: python get_data.py\")\n    parser.add_argument(\"--inDir\", \n            help=\"Source data directory.\",default=\"corpus\")\n    parser.add_argument(\"--outDir\",\n            help=\"Where to store output data directories (train, dev, test).\",default=\"dialogues\")",
        "detail": "examples.examples.performance.gpt2-like.corpus.self_dialogue_corpus.old.get_data",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "examples.examples.performance.gpt2-like.corpus.self_dialogue_corpus.old.get_data",
        "description": "examples.examples.performance.gpt2-like.corpus.self_dialogue_corpus.old.get_data",
        "peekOfCode": "logger = logging.getLogger('Self dialogue corpus')\ndef main():\n    args = parse_args()\n    logger.info(\"Will write data to {0}.\".format(args.outDir))\n    # Create output directories\n    train_dir = create_dirs(args.outDir)\n    if os.path.isfile(\"blocked_workers.txt\"):\n        with open(\"blocked_workers.txt\") as f:\n            blocked_workers = f.read().splitlines()\n    else:",
        "detail": "examples.examples.performance.gpt2-like.corpus.self_dialogue_corpus.old.get_data",
        "documentation": {}
    },
    {
        "label": "PatternOperation",
        "kind": 6,
        "importPath": "examples.examples.python_compat.extend.mettamorph",
        "description": "examples.examples.python_compat.extend.mettamorph",
        "peekOfCode": "class PatternOperation(OperationObject):\n    def __init__(self, name, op, unwrap=False, rec=False):\n        super().__init__(name, op, unwrap)\n        self.rec = rec\n    def execute(self, *args, res_typ=AtomType.UNDEFINED):\n        return super().execute(*args, res_typ=res_typ)\ndef wrapnpop(func):\n    def wrapper(*args):\n        a = [str(\"'\"+arg) if arg is SymbolAtom else str(arg) for arg in args]\n        res = func(*a)",
        "detail": "examples.examples.python_compat.extend.mettamorph",
        "documentation": {}
    },
    {
        "label": "wrapnpop",
        "kind": 2,
        "importPath": "examples.examples.python_compat.extend.mettamorph",
        "description": "examples.examples.python_compat.extend.mettamorph",
        "peekOfCode": "def wrapnpop(func):\n    def wrapper(*args):\n        a = [str(\"'\"+arg) if arg is SymbolAtom else str(arg) for arg in args]\n        res = func(*a)\n        return [res]\n    return wrapper\ndef func_mettamorph(evalstr):\n    bytes_literal = evalstr.encode('utf-8')\n    input_str = c_char_p(bytes_literal)\n    result = mettamorphlib.mettamorph(input_str)",
        "detail": "examples.examples.python_compat.extend.mettamorph",
        "documentation": {}
    },
    {
        "label": "func_mettamorph",
        "kind": 2,
        "importPath": "examples.examples.python_compat.extend.mettamorph",
        "description": "examples.examples.python_compat.extend.mettamorph",
        "peekOfCode": "def func_mettamorph(evalstr):\n    bytes_literal = evalstr.encode('utf-8')\n    input_str = c_char_p(bytes_literal)\n    result = mettamorphlib.mettamorph(input_str)\n    result_str = ctypes.string_at(result).decode('utf-8')\n    return result_str\ndef quoteSymbol(index, x):\n    if index == 0: #first is function symbol\n        return x\n    if x[0] != \"$\" and not x.replace(\"-\",\"\").replace(\".\",\"\").isnumeric() and x!=\"#f\" and x!=\"#t\":",
        "detail": "examples.examples.python_compat.extend.mettamorph",
        "documentation": {}
    },
    {
        "label": "quoteSymbol",
        "kind": 2,
        "importPath": "examples.examples.python_compat.extend.mettamorph",
        "description": "examples.examples.python_compat.extend.mettamorph",
        "peekOfCode": "def quoteSymbol(index, x):\n    if index == 0: #first is function symbol\n        return x\n    if x[0] != \"$\" and not x.replace(\"-\",\"\").replace(\".\",\"\").isnumeric() and x!=\"#f\" and x!=\"#t\":\n        return (\"'\" + x).replace(\"(\",\"(list \").replace(\" \", \" '\")\n    return x\ndef call_mettamorph(*a):\n    tokenizer = globalmetta.tokenizer()\n    EXPRESSION = \"(\" + (\" \".join([quoteSymbol(i, str(x)).replace(\"'(\",\"(\") for i,x in enumerate(a)])) + \")\"\n    parser = SExprParser(\"(superpose \" + str(func_mettamorph(EXPRESSION) + \")\"))",
        "detail": "examples.examples.python_compat.extend.mettamorph",
        "documentation": {}
    },
    {
        "label": "call_mettamorph",
        "kind": 2,
        "importPath": "examples.examples.python_compat.extend.mettamorph",
        "description": "examples.examples.python_compat.extend.mettamorph",
        "peekOfCode": "def call_mettamorph(*a):\n    tokenizer = globalmetta.tokenizer()\n    EXPRESSION = \"(\" + (\" \".join([quoteSymbol(i, str(x)).replace(\"'(\",\"(\") for i,x in enumerate(a)])) + \")\"\n    parser = SExprParser(\"(superpose \" + str(func_mettamorph(EXPRESSION) + \")\"))\n    return parser.parse(tokenizer)\nwrapperfunctions = set([])\ndef inject_calltypewrapper(content):\n    global wrapperfunctions\n    wrappers = \"\"\n    for line in content.split(\"\\n\"):",
        "detail": "examples.examples.python_compat.extend.mettamorph",
        "documentation": {}
    },
    {
        "label": "inject_calltypewrapper",
        "kind": 2,
        "importPath": "examples.examples.python_compat.extend.mettamorph",
        "description": "examples.examples.python_compat.extend.mettamorph",
        "peekOfCode": "def inject_calltypewrapper(content):\n    global wrapperfunctions\n    wrappers = \"\"\n    for line in content.split(\"\\n\"):\n        if line.startswith(\"(= (\"):\n            argstr = line.split(\"(= (\")[1]\n            name = argstr.split(\" \")[0]\n            i = 0\n            args = \"(\"\n            counter = 1",
        "detail": "examples.examples.python_compat.extend.mettamorph",
        "documentation": {}
    },
    {
        "label": "call_compilefile",
        "kind": 2,
        "importPath": "examples.examples.python_compat.extend.mettamorph",
        "description": "examples.examples.python_compat.extend.mettamorph",
        "peekOfCode": "def call_compilefile(*a):\n    global mettamorphlib, globalmetta, compiled\n    if compiled:\n        return E(S(\"Compilation:\"), S(\"unsupported\"))\n    compiled = True\n    loadfiletoken = str(a[0]).replace(\") (=\", \")\\n(=\").replace(\") (:\", \")\\n(:\")\n    loadfile = loadfiletoken[1:-1] if loadfiletoken.startswith('\"') or loadfiletoken.startswith('(') else loadfiletoken\n    if not loadfile.endswith(\".metta\"):\n        content = loadfile\n        loadfile = \"TEMP.metta\"",
        "detail": "examples.examples.python_compat.extend.mettamorph",
        "documentation": {}
    },
    {
        "label": "scheme_atoms",
        "kind": 2,
        "importPath": "examples.examples.python_compat.extend.mettamorph",
        "description": "examples.examples.python_compat.extend.mettamorph",
        "peekOfCode": "def scheme_atoms(metta):\n    global globalmetta\n    globalmetta = metta\n    with open(\"../mettamorph.metta\") as file:\n        metta.run(file.read()) #as \"!(import ../mettamorph.metta)\" doesn't work here\n    call_mettamorph_atom = G(PatternOperation('mettamorph', wrapnpop(call_mettamorph), unwrap=False))\n    call_compilefile_atom = G(PatternOperation('compile!', wrapnpop(call_compilefile), unwrap=False))\n    return { r\"compile!\": call_compilefile_atom, r\"mettamorph\": call_mettamorph_atom }",
        "detail": "examples.examples.python_compat.extend.mettamorph",
        "documentation": {}
    },
    {
        "label": "wrapperfunctions",
        "kind": 5,
        "importPath": "examples.examples.python_compat.extend.mettamorph",
        "description": "examples.examples.python_compat.extend.mettamorph",
        "peekOfCode": "wrapperfunctions = set([])\ndef inject_calltypewrapper(content):\n    global wrapperfunctions\n    wrappers = \"\"\n    for line in content.split(\"\\n\"):\n        if line.startswith(\"(= (\"):\n            argstr = line.split(\"(= (\")[1]\n            name = argstr.split(\" \")[0]\n            i = 0\n            args = \"(\"",
        "detail": "examples.examples.python_compat.extend.mettamorph",
        "documentation": {}
    },
    {
        "label": "compiled",
        "kind": 5,
        "importPath": "examples.examples.python_compat.extend.mettamorph",
        "description": "examples.examples.python_compat.extend.mettamorph",
        "peekOfCode": "compiled = False\ndef call_compilefile(*a):\n    global mettamorphlib, globalmetta, compiled\n    if compiled:\n        return E(S(\"Compilation:\"), S(\"unsupported\"))\n    compiled = True\n    loadfiletoken = str(a[0]).replace(\") (=\", \")\\n(=\").replace(\") (:\", \")\\n(:\")\n    loadfile = loadfiletoken[1:-1] if loadfiletoken.startswith('\"') or loadfiletoken.startswith('(') else loadfiletoken\n    if not loadfile.endswith(\".metta\"):\n        content = loadfile",
        "detail": "examples.examples.python_compat.extend.mettamorph",
        "documentation": {}
    },
    {
        "label": "globalmetta",
        "kind": 5,
        "importPath": "examples.examples.python_compat.extend.mettamorph",
        "description": "examples.examples.python_compat.extend.mettamorph",
        "peekOfCode": "globalmetta = None\n@register_atoms(pass_metta=True)\ndef scheme_atoms(metta):\n    global globalmetta\n    globalmetta = metta\n    with open(\"../mettamorph.metta\") as file:\n        metta.run(file.read()) #as \"!(import ../mettamorph.metta)\" doesn't work here\n    call_mettamorph_atom = G(PatternOperation('mettamorph', wrapnpop(call_mettamorph), unwrap=False))\n    call_compilefile_atom = G(PatternOperation('compile!', wrapnpop(call_compilefile), unwrap=False))\n    return { r\"compile!\": call_compilefile_atom, r\"mettamorph\": call_mettamorph_atom }",
        "detail": "examples.examples.python_compat.extend.mettamorph",
        "documentation": {}
    },
    {
        "label": "SORT_LINES",
        "kind": 2,
        "importPath": "examples.examples.python_compat.extend.test",
        "description": "examples.examples.python_compat.extend.test",
        "peekOfCode": "def SORT_LINES(name):\n    lines = \"\"\n    for line in name.split(\"\\n\"):\n        try:\n            my_list = ast.literal_eval(list_as_string)\n            my_list.sort()\n            lines += str(my_list) + \"\\n\"\n        except:\n            lines += line + \"\\n\"\n#5. Compare the postprocessed outputs, reporting failure on mismatch",
        "detail": "examples.examples.python_compat.extend.test",
        "documentation": {}
    },
    {
        "label": "basefile",
        "kind": 5,
        "importPath": "examples.examples.python_compat.extend.test",
        "description": "examples.examples.python_compat.extend.test",
        "peekOfCode": "basefile = \"\"\nfilename = sys.argv[1]\nif filename.split(\"/\")[-1][0].isupper() or \"compileme.metta\" in filename: #temp files are skipped\n    exit(0)\nwith open(filename) as file:\n    basefile = file.read()\nprint(\"Testing:\", sys.argv[1])\n#2. For compilation-omitted code, replace includes with included code and omit compilation instructions\nnewfile = \"\"\nfor line in basefile.split(\"\\n\"):",
        "detail": "examples.examples.python_compat.extend.test",
        "documentation": {}
    },
    {
        "label": "filename",
        "kind": 5,
        "importPath": "examples.examples.python_compat.extend.test",
        "description": "examples.examples.python_compat.extend.test",
        "peekOfCode": "filename = sys.argv[1]\nif filename.split(\"/\")[-1][0].isupper() or \"compileme.metta\" in filename: #temp files are skipped\n    exit(0)\nwith open(filename) as file:\n    basefile = file.read()\nprint(\"Testing:\", sys.argv[1])\n#2. For compilation-omitted code, replace includes with included code and omit compilation instructions\nnewfile = \"\"\nfor line in basefile.split(\"\\n\"):\n    if not line.startswith('\")') and not line.startswith(\"))\") and \\",
        "detail": "examples.examples.python_compat.extend.test",
        "documentation": {}
    },
    {
        "label": "newfile",
        "kind": 5,
        "importPath": "examples.examples.python_compat.extend.test",
        "description": "examples.examples.python_compat.extend.test",
        "peekOfCode": "newfile = \"\"\nfor line in basefile.split(\"\\n\"):\n    if not line.startswith('\")') and not line.startswith(\"))\") and \\\n       not line.startswith(\"!(compile! \") and not line.startswith(\"!(extend-py mettamorph)\"):\n           newfile += line + \"\\n\"\n    if \"!(compile! \" in line and \".metta)\" in line:\n        includefile = \"./extend/\" + line.split(\"!(compile! \")[1].split(\")\")[0]\n        with open(includefile) as file:\n            newfile += file.read() + \"\\n\"\nwith open(\"TEST.metta\",\"w\") as file:",
        "detail": "examples.examples.python_compat.extend.test",
        "documentation": {}
    },
    {
        "label": "OUTPUT_IS",
        "kind": 5,
        "importPath": "examples.examples.python_compat.extend.test",
        "description": "examples.examples.python_compat.extend.test",
        "peekOfCode": "OUTPUT_IS = SORT_LINES(OUTPUT_IS)\nOUTPUT_SHOULD = SORT_LINES(OUTPUT_SHOULD)\nif OUTPUT_IS != OUTPUT_SHOULD:\n    print(\"FAILED:\", filename)",
        "detail": "examples.examples.python_compat.extend.test",
        "documentation": {}
    },
    {
        "label": "OUTPUT_SHOULD",
        "kind": 5,
        "importPath": "examples.examples.python_compat.extend.test",
        "description": "examples.examples.python_compat.extend.test",
        "peekOfCode": "OUTPUT_SHOULD = SORT_LINES(OUTPUT_SHOULD)\nif OUTPUT_IS != OUTPUT_SHOULD:\n    print(\"FAILED:\", filename)",
        "detail": "examples.examples.python_compat.extend.test",
        "documentation": {}
    },
    {
        "label": "DASpace",
        "kind": 6,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.sandbox.das_gate.dasgate",
        "description": "examples.examples.python_compat.hyperon-experimental_python.sandbox.das_gate.dasgate",
        "peekOfCode": "class DASpace(AbstractSpace):\n    def __init__(self, unwrap=True):\n        super().__init__()\n        self.das = DistributedAtomSpace('ram_only')\n        self.unwrap = unwrap\n    def _atom2dict(self, atom):\n        if isinstance(atom, ExpressionAtom):\n            return {\n                \"type\": \"Expression\",\n                \"targets\": [self._atom2dict(ch) for ch in atom.get_children()]",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.sandbox.das_gate.dasgate",
        "documentation": {}
    },
    {
        "label": "das_atoms",
        "kind": 2,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.sandbox.das_gate.dasgate",
        "description": "examples.examples.python_compat.hyperon-experimental_python.sandbox.das_gate.dasgate",
        "peekOfCode": "def das_atoms(metta):\n    newDASpaceAtom = OperationAtom('new-das', lambda: [G(SpaceRef(DASpace()))], unwrap=False)\n    return {\n        r\"new-das\": newDASpaceAtom,\n    }",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.sandbox.das_gate.dasgate",
        "documentation": {}
    },
    {
        "label": "to_nested_expr",
        "kind": 2,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.sandbox.neurospace.llm_gate",
        "description": "examples.examples.python_compat.hyperon-experimental_python.sandbox.neurospace.llm_gate",
        "peekOfCode": "def to_nested_expr(xs):\n    if isinstance(xs, list):\n        return E(*list(map(to_nested_expr, xs)))\n    return ValueAtom(xs)\ndef get_message_list(msg_atoms):\n    '''\n    Convert atoms to ChatGPT messages and flatten a possibly nested message list\n    '''\n    messages = []\n    for msg in msg_atoms:",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.sandbox.neurospace.llm_gate",
        "documentation": {}
    },
    {
        "label": "get_message_list",
        "kind": 2,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.sandbox.neurospace.llm_gate",
        "description": "examples.examples.python_compat.hyperon-experimental_python.sandbox.neurospace.llm_gate",
        "peekOfCode": "def get_message_list(msg_atoms):\n    '''\n    Convert atoms to ChatGPT messages and flatten a possibly nested message list\n    '''\n    messages = []\n    for msg in msg_atoms:\n        if isinstance(msg, ExpressionAtom):\n            ch = msg.get_children()\n            if len(ch) == 0:\n                continue",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.sandbox.neurospace.llm_gate",
        "documentation": {}
    },
    {
        "label": "llm",
        "kind": 2,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.sandbox.neurospace.llm_gate",
        "description": "examples.examples.python_compat.hyperon-experimental_python.sandbox.neurospace.llm_gate",
        "peekOfCode": "def llm(metta: MeTTa, *args):\n    messages = []\n    functions = []\n    msgs = None\n    for arg in args:\n        if isinstance(arg, ExpressionAtom):\n            ch = arg.get_children()\n            if len(ch) > 1 and ch[0].get_name() == 'Messages':\n                msgs = arg\n                messages += get_message_list(ch[1:])",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.sandbox.neurospace.llm_gate",
        "documentation": {}
    },
    {
        "label": "llmgate_atoms",
        "kind": 2,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.sandbox.neurospace.llm_gate",
        "description": "examples.examples.python_compat.hyperon-experimental_python.sandbox.neurospace.llm_gate",
        "peekOfCode": "def llmgate_atoms(metta):\n    llmAtom = OperationAtom('llm', lambda *args: llm(metta, *args), unwrap=False)\n    return {\n        r\"llm\": llmAtom\n    }",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.sandbox.neurospace.llm_gate",
        "documentation": {}
    },
    {
        "label": "openai.api_key",
        "kind": 5,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.sandbox.neurospace.llm_gate",
        "description": "examples.examples.python_compat.hyperon-experimental_python.sandbox.neurospace.llm_gate",
        "peekOfCode": "openai.api_key = os.environ[\"OPENAI_API_KEY\"]\ndef to_nested_expr(xs):\n    if isinstance(xs, list):\n        return E(*list(map(to_nested_expr, xs)))\n    return ValueAtom(xs)\ndef get_message_list(msg_atoms):\n    '''\n    Convert atoms to ChatGPT messages and flatten a possibly nested message list\n    '''\n    messages = []",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.sandbox.neurospace.llm_gate",
        "documentation": {}
    },
    {
        "label": "NeuralSpace",
        "kind": 6,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.sandbox.neurospace.neurospace",
        "description": "examples.examples.python_compat.hyperon-experimental_python.sandbox.neurospace.neurospace",
        "peekOfCode": "class NeuralSpace(GroundingSpace):\n    def query(self, query_atom):\n        tot_str = \"Answer the question taking into account the following information (each fact is in brackets):\\n\"\n        for atom in self.atoms_iter():\n            tot_str += str(atom) + \"\\n\"\n        tot_str += \"If the question contains letters in brackets with $ sign, for example ($x), provide the answer in the json format in curly brackets, that is { $x: your answer }.\\n\"\n        # tot_str += \"If information is not provided, return the entry to be queried in JSON {unknown value: UNKNOWN}.\"\n        tot_str += \"The question is: \" + str(query_atom)[1:-1] + \"?\"\n        response = openai.ChatCompletion.create(\n                model=\"gpt-3.5-turbo-0613\",",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.sandbox.neurospace.neurospace",
        "documentation": {}
    },
    {
        "label": "IntentSpace",
        "kind": 6,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.sandbox.neurospace.neurospace",
        "description": "examples.examples.python_compat.hyperon-experimental_python.sandbox.neurospace.neurospace",
        "peekOfCode": "class IntentSpace(GroundingSpace):\n    def query(self, query_atom):\n        tot_str = \"Analyze the topic of the utterance: \" + str(query_atom)[1:-1] + \"\\n\"\n        tot_str += \"Try to pick the most relevant topic from the following list (each topic in brackets):\"\n        for atom in self.atoms_iter():\n            tot_str += str(atom) + \"\\n\"\n        tot_str += \"If neither of the listed topics seems relevant, answer (chit-chat).\"\n        tot_str += \"Provide the answer in the json format in curly brackets in the form { topic: your answer }.\\n\"\n        response = openai.ChatCompletion.create(\n                model=\"gpt-3.5-turbo-0613\",",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.sandbox.neurospace.neurospace",
        "documentation": {}
    },
    {
        "label": "neuralspace_atoms",
        "kind": 2,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.sandbox.neurospace.neurospace",
        "description": "examples.examples.python_compat.hyperon-experimental_python.sandbox.neurospace.neurospace",
        "peekOfCode": "def neuralspace_atoms():\n    newNSpaceAtom = OperationAtom('new-neural-space', lambda: [G(SpaceRef(NeuralSpace()))], unwrap=False)\n    newISpaceAtom = OperationAtom('new-intent-space', lambda: [G(SpaceRef(IntentSpace()))], unwrap=False)\n    return {\n        r\"new-neural-space\": newNSpaceAtom,\n        r\"new-intent-space\": newISpaceAtom,\n    }",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.sandbox.neurospace.neurospace",
        "documentation": {}
    },
    {
        "label": "openai.api_key",
        "kind": 5,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.sandbox.neurospace.neurospace",
        "description": "examples.examples.python_compat.hyperon-experimental_python.sandbox.neurospace.neurospace",
        "peekOfCode": "openai.api_key = os.environ[\"OPENAI_API_KEY\"]\ndef _response2bindings(txt):\n        res = re.findall(r'\\{.*?\\}', txt)\n        new_bindings_set = BindingsSet.empty()\n        if res == []:\n            return new_bindings_set\n        res = res[0][1:-1]\n        _var, val = res.split(':')\n        var = re.findall(r'\\\".*?\\\"', _var)\n        var = var[0][1:-1] if len(var) > 0 else _var.replace(\" \", \"\")",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.sandbox.neurospace.neurospace",
        "documentation": {}
    },
    {
        "label": "NumpyValue",
        "kind": 6,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.sandbox.numpy.numme",
        "description": "examples.examples.python_compat.hyperon-experimental_python.sandbox.numpy.numme",
        "peekOfCode": "class NumpyValue(MatchableObject):\n    def __eq__(self, other):\n        return isinstance(other, NumpyValue) and\\\n               (self.content.shape == other.content.shape) and\\\n               (self.content == other.content).all()\n    def match_(self, other):\n        sh = self.content.shape\n        bindings = {}\n        if isinstance(other, GroundedAtom):\n            other = other.get_object()",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.sandbox.numpy.numme",
        "documentation": {}
    },
    {
        "label": "PatternValue",
        "kind": 6,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.sandbox.numpy.numme",
        "description": "examples.examples.python_compat.hyperon-experimental_python.sandbox.numpy.numme",
        "peekOfCode": "class PatternValue(MatchableObject):\n    def match_(self, other):\n        if isinstance(other, GroundedAtom):\n            other = other.get_object().content\n        if not isinstance(other, PatternValue):\n            return other.match_(self)\n        # TODO: match to patterns\n        return []\nclass PatternOperation(OperationObject):\n    def __init__(self, name, op, unwrap=False, rec=False):",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.sandbox.numpy.numme",
        "documentation": {}
    },
    {
        "label": "PatternOperation",
        "kind": 6,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.sandbox.numpy.numme",
        "description": "examples.examples.python_compat.hyperon-experimental_python.sandbox.numpy.numme",
        "peekOfCode": "class PatternOperation(OperationObject):\n    def __init__(self, name, op, unwrap=False, rec=False):\n        super().__init__(name, op, unwrap)\n        self.rec = rec\n    def execute(self, *args, res_typ=AtomType.UNDEFINED):\n        if self.rec:\n            args = args[0].get_children()\n            args = [self.execute(arg)[0]\\\n                if isinstance(arg, ExpressionAtom) else arg for arg in args]\n        # If there is a variable or PatternValue in arguments, create PatternValue",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.sandbox.numpy.numme",
        "documentation": {}
    },
    {
        "label": "wrapnpop",
        "kind": 2,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.sandbox.numpy.numme",
        "description": "examples.examples.python_compat.hyperon-experimental_python.sandbox.numpy.numme",
        "peekOfCode": "def wrapnpop(func):\n    def wrapper(*args):\n        a = [arg.get_object().value for arg in args]\n        res = func(*a)\n        typ = _np_atom_type(res)\n        return [G(NumpyValue(res), typ)]\n    return wrapper\n@register_atoms\ndef numme_atoms():\n    # FIXME: we don't add types for operations, because numpy operations types",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.sandbox.numpy.numme",
        "documentation": {}
    },
    {
        "label": "numme_atoms",
        "kind": 2,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.sandbox.numpy.numme",
        "description": "examples.examples.python_compat.hyperon-experimental_python.sandbox.numpy.numme",
        "peekOfCode": "def numme_atoms():\n    # FIXME: we don't add types for operations, because numpy operations types\n    # are too loose\n    nmVectorAtom = G(PatternOperation('np.vector', wrapnpop(lambda *args: np.array(args)), unwrap=False))\n    nmArrayAtom = G(PatternOperation('np.array', wrapnpop(lambda *args: np.array(args)), unwrap=False, rec=True))\n    nmAddAtom = G(PatternOperation('np.add', wrapnpop(np.add), unwrap=False))\n    nmSubAtom = G(PatternOperation('np.sub', wrapnpop(np.subtract), unwrap=False))\n    nmMulAtom = G(PatternOperation('np.mul', wrapnpop(np.multiply), unwrap=False))\n    nmDivAtom = G(PatternOperation('np.div', wrapnpop(np.divide), unwrap=False))\n    nmMMulAtom = G(PatternOperation('np.matmul', wrapnpop(np.matmul), unwrap=False))",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.sandbox.numpy.numme",
        "documentation": {}
    },
    {
        "label": "MeTTaC",
        "kind": 6,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.sandbox.resolve.r",
        "description": "examples.examples.python_compat.hyperon-experimental_python.sandbox.resolve.r",
        "peekOfCode": "class MeTTaC(MeTTa):\n    def copy(self):\n        return self\n@register_atoms\ndef my_imported_runner_atom():\n    # We don't use metta here, but we could...\n    content = '''\n        (: fact (-> Number Number))\n        (= (fact $x)\n           (case $x",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.sandbox.resolve.r",
        "documentation": {}
    },
    {
        "label": "my_imported_runner_atom",
        "kind": 2,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.sandbox.resolve.r",
        "description": "examples.examples.python_compat.hyperon-experimental_python.sandbox.resolve.r",
        "peekOfCode": "def my_imported_runner_atom():\n    # We don't use metta here, but we could...\n    content = '''\n        (: fact (-> Number Number))\n        (= (fact $x)\n           (case $x\n            ((0 1)\n             ($_ (* $x (fact (- $x 1)))))\n           )\n        )",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.sandbox.resolve.r",
        "documentation": {}
    },
    {
        "label": "my_resolver_atoms",
        "kind": 2,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.sandbox.resolve.resolve",
        "description": "examples.examples.python_compat.hyperon-experimental_python.sandbox.resolve.resolve",
        "peekOfCode": "def my_resolver_atoms(metta):\n    def run_resolved_symbol_op(runner, atom, *args):\n        expr = E(atom, *args)\n        result = hp.metta_evaluate_atom(runner.cmetta, expr.catom)\n        result = [Atom._from_catom(catom) for catom in result]\n        return result\n    def resolve_atom(metta, token):\n        # TODO: nested modules...\n        runner_name, atom_name = token.split('::')\n        # FIXME: using `run` for this is an overkill,",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.sandbox.resolve.resolve",
        "documentation": {}
    },
    {
        "label": "SqlHelper",
        "kind": 6,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.sandbox.sql_space.sql_space",
        "description": "examples.examples.python_compat.hyperon-experimental_python.sandbox.sql_space.sql_space",
        "peekOfCode": "class SqlHelper:\n    colums_word = \"ColumnNames\"\n    insert_command_sql = \"INSERT INTO\"\n    @staticmethod\n    def get_query_atoms(query_atom):\n        children = query_atom.get_children()\n        new_query_atoms = []\n        for ch in children:\n            if 'limit' not in repr(ch).lower():\n                new_query_atoms.append(ch)",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.sandbox.sql_space.sql_space",
        "documentation": {}
    },
    {
        "label": "SqlSpace",
        "kind": 6,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.sandbox.sql_space.sql_space",
        "description": "examples.examples.python_compat.hyperon-experimental_python.sandbox.sql_space.sql_space",
        "peekOfCode": "class SqlSpace(GroundingSpace):\n    def __init__(self, database, host, user, password, port):\n        super().__init__()\n        self.conn = psycopg2.connect(database=database,\n                                     host=host,\n                                     user=user,\n                                     password=password,\n                                     port=port)\n        self.cursor = self.conn.cursor()\n    def from_space(self, cspace):",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.sandbox.sql_space.sql_space",
        "documentation": {}
    },
    {
        "label": "results2bindings",
        "kind": 2,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.sandbox.sql_space.sql_space",
        "description": "examples.examples.python_compat.hyperon-experimental_python.sandbox.sql_space.sql_space",
        "peekOfCode": "def results2bindings(vars, values):\n    new_bindings_set = BindingsSet.empty()\n    if len(values) == 0 or len(vars) != len(values[0]):\n        return new_bindings_set\n    for value in values:\n        bindings = Bindings()\n        for i in range(len(vars)):\n            bindings.add_var_binding(vars[i], ValueAtom(str(value[i])))\n        new_bindings_set.push(bindings)\n    return new_bindings_set",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.sandbox.sql_space.sql_space",
        "documentation": {}
    },
    {
        "label": "wrapsqlop",
        "kind": 2,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.sandbox.sql_space.sql_space",
        "description": "examples.examples.python_compat.hyperon-experimental_python.sandbox.sql_space.sql_space",
        "peekOfCode": "def wrapsqlop(func):\n    def wrapper(*args):\n        if len(args) > 1:\n            if isinstance(args[0], GroundedAtom):\n                space1 = args[0].get_object()\n                if isinstance(space1, SpaceRef):\n                    if isinstance(args[1], GroundedAtom):\n                        space2 = args[1].get_object()\n                        if isinstance(space2, SpaceRef):\n                            args = args[2:]",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.sandbox.sql_space.sql_space",
        "documentation": {}
    },
    {
        "label": "sql_space_atoms",
        "kind": 2,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.sandbox.sql_space.sql_space",
        "description": "examples.examples.python_compat.hyperon-experimental_python.sandbox.sql_space.sql_space",
        "peekOfCode": "def sql_space_atoms():\n    helper = SqlHelper()\n    newSQLSpaceAtom = OperationAtom('new-sql-space', lambda database, host, user, password, port: [\n        G(SpaceRef(SqlSpace(database, host, user, password, port)))], unwrap=False)\n    saveQueryResult = G(OperationObject('sql.save-query-result', wrapsqlop(helper.save_query_result), unwrap=False))\n    sqlInsert = G(OperationObject('sql.insert', wrapsqlop(helper.insert), unwrap=False))\n    return {\n        r\"new-sql-space\": newSQLSpaceAtom,\n        r\"sql.save-query-result\": saveQueryResult,\n        r\"sql.insert\": sqlInsert",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.sandbox.sql_space.sql_space",
        "documentation": {}
    },
    {
        "label": "set_global",
        "kind": 2,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.extension",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.extension",
        "peekOfCode": "def set_global(v):\n    global g_object\n    g_object = v\n@register_atoms\ndef my_dict_atoms():\n    return {\n        '&my-dict': ValueAtom({'A': 5, 6: 'B'}),\n        'get-by-key': OperationAtom('get-by-key', lambda d, k: d[k])\n        }\n@register_atoms",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.extension",
        "documentation": {}
    },
    {
        "label": "my_dict_atoms",
        "kind": 2,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.extension",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.extension",
        "peekOfCode": "def my_dict_atoms():\n    return {\n        '&my-dict': ValueAtom({'A': 5, 6: 'B'}),\n        'get-by-key': OperationAtom('get-by-key', lambda d, k: d[k])\n        }\n@register_atoms\ndef my_glob_atoms():\n    return {\n        'set-global!': OperationAtom(\"set-global!\", set_global),\n        'get-global': OperationAtom(\"get-global\", lambda: g_object),",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.extension",
        "documentation": {}
    },
    {
        "label": "my_glob_atoms",
        "kind": 2,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.extension",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.extension",
        "peekOfCode": "def my_glob_atoms():\n    return {\n        'set-global!': OperationAtom(\"set-global!\", set_global),\n        'get-global': OperationAtom(\"get-global\", lambda: g_object),\n        }\n@register_tokens(pass_metta=True)\ndef my_get_runner(metta):\n    return {\n        '&runner': lambda _: ValueAtom(metta)\n    }",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.extension",
        "documentation": {}
    },
    {
        "label": "my_get_runner",
        "kind": 2,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.extension",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.extension",
        "peekOfCode": "def my_get_runner(metta):\n    return {\n        '&runner': lambda _: ValueAtom(metta)\n    }",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.extension",
        "documentation": {}
    },
    {
        "label": "g_object",
        "kind": 5,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.extension",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.extension",
        "peekOfCode": "g_object = None\ndef set_global(v):\n    global g_object\n    g_object = v\n@register_atoms\ndef my_dict_atoms():\n    return {\n        '&my-dict': ValueAtom({'A': 5, 6: 'B'}),\n        'get-by-key': OperationAtom('get-by-key', lambda d, k: d[k])\n        }",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.extension",
        "documentation": {}
    },
    {
        "label": "AtomTest",
        "kind": 6,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "peekOfCode": "class AtomTest(unittest.TestCase):\n    def test_symbol_equals(self):\n        self.assertEqual(S(\"a\"), S(\"a\"))\n        self.assertNotEqual(S(\"a\"), S(\"b\"))\n    def test_symbol_str(self):\n        self.assertEqual(str(S(\"a\")), \"a\")\n    def test_symbol_type(self):\n        self.assertEqual(S(\"a\").get_type(), AtomKind.SYMBOL)\n    def test_symbol_get_symbol(self):\n        self.assertEqual(S(\"a\").get_name(), \"a\")",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "documentation": {}
    },
    {
        "label": "GroundedNoCopy",
        "kind": 6,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "peekOfCode": "class GroundedNoCopy:\n    pass\nclass MatchableObjectTest(MatchableObject):\n    def match_(self, atom):\n        return [{'atom_type': S(atom.get_children()[0].get_type().name)}]\ndef MatchableAtomTest(value, type_name=None, atom_id=None):\n    return G(MatchableObjectTest(value, atom_id), AtomType.UNDEFINED)\nif __name__ == \"__main__\":\n    unittest.main()",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "documentation": {}
    },
    {
        "label": "MatchableObjectTest",
        "kind": 6,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "peekOfCode": "class MatchableObjectTest(MatchableObject):\n    def match_(self, atom):\n        return [{'atom_type': S(atom.get_children()[0].get_type().name)}]\ndef MatchableAtomTest(value, type_name=None, atom_id=None):\n    return G(MatchableObjectTest(value, atom_id), AtomType.UNDEFINED)\nif __name__ == \"__main__\":\n    unittest.main()",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "documentation": {}
    },
    {
        "label": "x2_op",
        "kind": 2,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "peekOfCode": "def x2_op(atom):\n    return [ValueAtom(2 * atom.get_object().value)]\nx2Atom = OperationAtom('*2', x2_op, type_names=[\"int\", \"int\"], unwrap=False)\ndef no_reduce_op(atom):\n    raise NoReduceError()\nnoReduceAtom = OperationAtom('no-reduce', no_reduce_op, unwrap=False)\nclass GroundedNoCopy:\n    pass\nclass MatchableObjectTest(MatchableObject):\n    def match_(self, atom):",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "documentation": {}
    },
    {
        "label": "no_reduce_op",
        "kind": 2,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "peekOfCode": "def no_reduce_op(atom):\n    raise NoReduceError()\nnoReduceAtom = OperationAtom('no-reduce', no_reduce_op, unwrap=False)\nclass GroundedNoCopy:\n    pass\nclass MatchableObjectTest(MatchableObject):\n    def match_(self, atom):\n        return [{'atom_type': S(atom.get_children()[0].get_type().name)}]\ndef MatchableAtomTest(value, type_name=None, atom_id=None):\n    return G(MatchableObjectTest(value, atom_id), AtomType.UNDEFINED)",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "documentation": {}
    },
    {
        "label": "MatchableAtomTest",
        "kind": 2,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "peekOfCode": "def MatchableAtomTest(value, type_name=None, atom_id=None):\n    return G(MatchableObjectTest(value, atom_id), AtomType.UNDEFINED)\nif __name__ == \"__main__\":\n    unittest.main()",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "documentation": {}
    },
    {
        "label": "x2Atom",
        "kind": 5,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "peekOfCode": "x2Atom = OperationAtom('*2', x2_op, type_names=[\"int\", \"int\"], unwrap=False)\ndef no_reduce_op(atom):\n    raise NoReduceError()\nnoReduceAtom = OperationAtom('no-reduce', no_reduce_op, unwrap=False)\nclass GroundedNoCopy:\n    pass\nclass MatchableObjectTest(MatchableObject):\n    def match_(self, atom):\n        return [{'atom_type': S(atom.get_children()[0].get_type().name)}]\ndef MatchableAtomTest(value, type_name=None, atom_id=None):",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "documentation": {}
    },
    {
        "label": "noReduceAtom",
        "kind": 5,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "peekOfCode": "noReduceAtom = OperationAtom('no-reduce', no_reduce_op, unwrap=False)\nclass GroundedNoCopy:\n    pass\nclass MatchableObjectTest(MatchableObject):\n    def match_(self, atom):\n        return [{'atom_type': S(atom.get_children()[0].get_type().name)}]\ndef MatchableAtomTest(value, type_name=None, atom_id=None):\n    return G(MatchableObjectTest(value, atom_id), AtomType.UNDEFINED)\nif __name__ == \"__main__\":\n    unittest.main()",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "documentation": {}
    },
    {
        "label": "AtomTest",
        "kind": 6,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_atom_type",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_atom_type",
        "peekOfCode": "class AtomTest(unittest.TestCase):\n    def test_check_type(self):\n        space = GroundingSpaceRef()\n        space.add_atom(E(S(\":\"), S(\"a\"), S(\"A\")))\n        self.assertTrue(check_type(space, S(\"a\"), AtomType.UNDEFINED))\n        self.assertTrue(check_type(space, S(\"a\"), S(\"A\")))\n        self.assertFalse(check_type(space, S(\"a\"), S(\"B\")))\n    def test_validate_atom(self):\n        space = GroundingSpaceRef()\n        space.add_atom(E(S(\":\"), S(\"a\"), S(\"A\")))",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_atom_type",
        "documentation": {}
    },
    {
        "label": "BindingsTest",
        "kind": 6,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_bindings",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_bindings",
        "peekOfCode": "class BindingsTest(unittest.TestCase):\n    def setUp(self):\n        self.emptyBindings = Bindings()\n        self.bindings = Bindings()\n        self.bindings.add_var_binding(\"a\", S(\"b\"))\n        self.bindings.add_var_binding(\"x\", S(\"y\"))\n    def tearDown(self) -> None:\n        pass\n    def test_bindings_match_display(self):\n        pass",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_bindings",
        "documentation": {}
    },
    {
        "label": "HyperonTestCase",
        "kind": 6,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_common",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_common",
        "peekOfCode": "class HyperonTestCase(unittest.TestCase):\n    def __init__(self, methodName):\n        super().__init__(methodName)\n    def assertEqualNoOrder(self, left, right):\n        self.assertTrue(areEqualNoOrder(left, right),\n            f\"Lists differ: {left} != {right}\")\n    def assertEqualMettaRunnerResults(self, left, right):\n        self.assertTrue(areEqualMettaRunResults(left, right),\n            f\"MeTTa results differ: {left} != {right}\")\n    def assertAtomsAreEquivalent(self, actual, expected):",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_common",
        "documentation": {}
    },
    {
        "label": "areEqualNoOrder",
        "kind": 2,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_common",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_common",
        "peekOfCode": "def areEqualNoOrder(a, b):\n    class FakeHash:\n        def __init__(self, o):\n            self.o = o\n        def __hash__(self):\n            return 0\n        def __eq__(self, other):\n            return self.o.__eq__(other.o)\n    mapa = dict()\n    mapb = dict()",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_common",
        "documentation": {}
    },
    {
        "label": "areEqualMettaRunResults",
        "kind": 2,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_common",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_common",
        "peekOfCode": "def areEqualMettaRunResults(a, b):\n    if len(a) != len(b):\n        return False\n    for (a, b) in zip(a, b):\n        if not areEqualNoOrder(a, b):\n            return False\n    return True\nclass HyperonTestCase(unittest.TestCase):\n    def __init__(self, methodName):\n        super().__init__(methodName)",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_common",
        "documentation": {}
    },
    {
        "label": "TestSpace",
        "kind": 6,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_custom_space",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_custom_space",
        "peekOfCode": "class TestSpace(AbstractSpace):\n    def __init__(self, unwrap=True):\n        super().__init__()\n        self.atoms_list = []\n        self.unwrap = unwrap\n    # NOTE: this is a naive implementation barely good enough to pass the tests\n    # Don't take this as a guide to implementing a space query function\n    def query(self, query_atom):\n        # Extract only the variables from the query atom\n        query_vars = list(filter(lambda atom: atom.get_type() == AtomKind.VARIABLE, query_atom.iterate()))",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_custom_space",
        "documentation": {}
    },
    {
        "label": "CustomSpaceTest",
        "kind": 6,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_custom_space",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_custom_space",
        "peekOfCode": "class CustomSpaceTest(HyperonTestCase):\n    def test_custom_space(self):\n        test_space = TestSpace()\n        test_space.test_attrib = \"Test Space Payload Attrib\"\n        kb = SpaceRef(test_space)\n        kb.add_atom(S(\"a\"))\n        kb.add_atom(S(\"b\"))\n        self.assertEqual(kb.atom_count(), 2)\n        self.assertEqual(kb.get_payload().test_attrib, \"Test Space Payload Attrib\")\n        self.assertEqualNoOrder(kb.get_atoms(), [S(\"a\"), S(\"b\")])",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_custom_space",
        "documentation": {}
    },
    {
        "label": "HyperonTestCase",
        "kind": 6,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_environment",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_environment",
        "peekOfCode": "class HyperonTestCase(unittest.TestCase):\n    def __init__(self, methodName):\n        super().__init__(methodName)\n    def testEnvironment(self):\n        self.assertTrue(Environment.init_common_env(config_dir = \"/tmp/test_dir\", create_config = True))\n        self.assertEqual(Environment.config_dir(), \"/tmp/test_dir\")\n        self.assertFalse(Environment.init_common_env(disable_config = True))",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_environment",
        "documentation": {}
    },
    {
        "label": "ExamplesTest",
        "kind": 6,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_examples",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_examples",
        "peekOfCode": "class ExamplesTest(HyperonTestCase):\n    def test_grounded_functions(self):\n        metta = MeTTa(env_builder=Environment.test_env())\n        obj = SomeObject()\n        # using & as a prefix is not obligatory, but is naming convention\n        metta.register_atom(\"&obj\", ValueAtom(obj))\n        target = metta.parse_single('(call:foo &obj)')\n        # interpreting this target in another space still works,\n        # because substitution '&obj' -> obj is done by metta\n        metta2 = MeTTa(env_builder=Environment.test_env())",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_examples",
        "documentation": {}
    },
    {
        "label": "SomeObject",
        "kind": 6,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_examples",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_examples",
        "peekOfCode": "class SomeObject():\n    def __init__(self):\n        self.called = False\n    def foo(self):\n        self.called = True\n# New object example\ndef new_atom_op(klass, unwrap, *params):\n    if unwrap:\n        unwrapped = [param.get_object().value for param in params]\n        return [ValueAtom(klass(*unwrapped))]",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_examples",
        "documentation": {}
    },
    {
        "label": "Global",
        "kind": 6,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_examples",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_examples",
        "peekOfCode": "class Global:\n    def __init__(self, x):\n        self.set(x)\n    def set(self, x):\n        self.x = x\n    def get(self):\n        return self.x\nclass Setter:\n    def __init__(self, var, val):\n        self.var = var",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_examples",
        "documentation": {}
    },
    {
        "label": "Setter",
        "kind": 6,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_examples",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_examples",
        "peekOfCode": "class Setter:\n    def __init__(self, var, val):\n        self.var = var\n        self.val = val\n    def act(self):\n        self.var.set(self.val)\n    def let(self):\n        self.var = self.val\n    def latom(self):\n        # if var/val are not unwrapped",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_examples",
        "documentation": {}
    },
    {
        "label": "new_atom_op",
        "kind": 2,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_examples",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_examples",
        "peekOfCode": "def new_atom_op(klass, unwrap, *params):\n    if unwrap:\n        unwrapped = [param.get_object().value for param in params]\n        return [ValueAtom(klass(*unwrapped))]\n    else:\n        return [ValueAtom(klass(*params))]\ndef newNewAtom(token, klass, unwrap=True):\n    return OperationAtom(\n        token,\n        lambda *params: new_atom_op(klass, unwrap, *params),",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_examples",
        "documentation": {}
    },
    {
        "label": "newNewAtom",
        "kind": 2,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_examples",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_examples",
        "peekOfCode": "def newNewAtom(token, klass, unwrap=True):\n    return OperationAtom(\n        token,\n        lambda *params: new_atom_op(klass, unwrap, *params),\n        unwrap=False)\nclass Global:\n    def __init__(self, x):\n        self.set(x)\n    def set(self, x):\n        self.x = x",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_examples",
        "documentation": {}
    },
    {
        "label": "ExtendTest",
        "kind": 6,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_extend",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_extend",
        "peekOfCode": "class ExtendTest(unittest.TestCase):\n    def test_extend(self):\n        '''\n        This test verifies that extend-py! along with @register_atoms and @register_tokens works\n        '''\n        metta = MeTTa(env_builder=Environment.test_env())\n        self.assertEqual(\n            metta.run('''\n              !(extend-py! extension)\n              !(get-by-key &my-dict \"A\")",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_extend",
        "documentation": {}
    },
    {
        "label": "ExtendGlobalTest",
        "kind": 6,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_extend",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_extend",
        "peekOfCode": "class ExtendGlobalTest(unittest.TestCase):\n    def test_extend_global(self):\n        '''\n        This test is intended to check that if the extension uses internal states,\n        they are not lost between metta.run's and are also accessible from Python\n        '''\n        from extension import g_object\n        # Sanity check\n        self.assertEqual(g_object, None)\n        metta = MeTTa(env_builder=Environment.test_env())",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_extend",
        "documentation": {}
    },
    {
        "label": "GroundedTypeTest",
        "kind": 6,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_grounded_type",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_grounded_type",
        "peekOfCode": "class GroundedTypeTest(unittest.TestCase):\n    def test_apply_type(self):\n        metta = MeTTa(env_builder=Environment.test_env())\n        self.assertEqual(\n            metta.parse_single(\"+\").get_grounded_type(),\n            metta.parse_single(\"*\").get_grounded_type())\n        self.assertEqual(\n            metta.run(\"!(+ (* 1 4) 2)\")[0][0].get_grounded_type(),\n            metta.parse_single(\"0\").get_grounded_type())\n        self.assertEqual(",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_grounded_type",
        "documentation": {}
    },
    {
        "label": "GroundingSpaceTest",
        "kind": 6,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_grounding_space",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_grounding_space",
        "peekOfCode": "class GroundingSpaceTest(HyperonTestCase):\n    def test_add(self):\n        kb = GroundingSpaceRef()\n        kb.add_atom(S(\"a\"))\n        kb.add_atom(S(\"b\"))\n        self.assertEqualNoOrder(kb.get_atoms(), [S(\"a\"), S(\"b\")])\n    def test_remove(self):\n        kb = GroundingSpaceRef()\n        kb.add_atom(S(\"a\"))\n        kb.add_atom(S(\"b\"))",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_grounding_space",
        "documentation": {}
    },
    {
        "label": "MettaTest",
        "kind": 6,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_metta",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_metta",
        "peekOfCode": "class MettaTest(unittest.TestCase):\n    def test_adding_tokens_while_parsing(self):\n        metta = MeTTa(env_builder=Environment.test_env())\n        atom = metta.parse_single('(A B)')\n        self.assertEqual(atom, E(S('A'), S('B')))\n        metta.register_atom('A', S('C'))\n        atom = metta.parse_single('(A B)')\n        self.assertEqual(atom, E(S('C'), S('B')))\n        metta.register_atom('A', S('F'))\n        atom = metta.parse_single('(A B)')",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_metta",
        "documentation": {}
    },
    {
        "label": "MinecraftTest",
        "kind": 6,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_minecraft",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_minecraft",
        "peekOfCode": "class MinecraftTest(unittest.TestCase):\n    def test_minecraft_planning(self):\n        metta = MeTTa(env_builder=Environment.test_env())\n        inventory = [S('inventory'), S('hands')]\n        metta.register_token(\"in-inventory\", lambda _: newInInventory(inventory))\n        metta.register_token(\"craft\", lambda _: newCraftOp(inventory))\n        metta.register_token(\"mine\", lambda _: newMineOp(inventory))\n        metta.run('''\n            (= (wood) (spruce-wood))\n            (= (spruce-wood) (mine spruce-tree hand))",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_minecraft",
        "documentation": {}
    },
    {
        "label": "newInInventory",
        "kind": 2,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_minecraft",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_minecraft",
        "peekOfCode": "def newInInventory(inventory):\n    return OperationAtom(\n        \"in-inventory\",\n        lambda obj: [ValueAtom(obj in inventory)],\n        unwrap=False)\ndef craft_op(inventory, obj, where, comp):\n    print(str(obj) + \" crafted in \" + str(where) + \" from \" + str(comp))\n    inventory.append(obj)\n    return [obj]\ndef newCraftOp(inventory):",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_minecraft",
        "documentation": {}
    },
    {
        "label": "craft_op",
        "kind": 2,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_minecraft",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_minecraft",
        "peekOfCode": "def craft_op(inventory, obj, where, comp):\n    print(str(obj) + \" crafted in \" + str(where) + \" from \" + str(comp))\n    inventory.append(obj)\n    return [obj]\ndef newCraftOp(inventory):\n    return OperationAtom(\n        \"craft\",\n        lambda obj, where, comp: craft_op(inventory, obj, where, comp),\n        unwrap=False)\ndef mine_op(inventory, obj, tool):",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_minecraft",
        "documentation": {}
    },
    {
        "label": "newCraftOp",
        "kind": 2,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_minecraft",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_minecraft",
        "peekOfCode": "def newCraftOp(inventory):\n    return OperationAtom(\n        \"craft\",\n        lambda obj, where, comp: craft_op(inventory, obj, where, comp),\n        unwrap=False)\ndef mine_op(inventory, obj, tool):\n    print(str(obj) + \" mined by \" + str(tool))\n    inventory.append(obj)\n    return [obj]\ndef newMineOp(inventory):",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_minecraft",
        "documentation": {}
    },
    {
        "label": "mine_op",
        "kind": 2,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_minecraft",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_minecraft",
        "peekOfCode": "def mine_op(inventory, obj, tool):\n    print(str(obj) + \" mined by \" + str(tool))\n    inventory.append(obj)\n    return [obj]\ndef newMineOp(inventory):\n    return OperationAtom(\n        \"mine\",\n        lambda obj, tool: mine_op(inventory, obj, tool),\n        unwrap=False)\nclass MinecraftTest(unittest.TestCase):",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_minecraft",
        "documentation": {}
    },
    {
        "label": "newMineOp",
        "kind": 2,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_minecraft",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_minecraft",
        "peekOfCode": "def newMineOp(inventory):\n    return OperationAtom(\n        \"mine\",\n        lambda obj, tool: mine_op(inventory, obj, tool),\n        unwrap=False)\nclass MinecraftTest(unittest.TestCase):\n    def test_minecraft_planning(self):\n        metta = MeTTa(env_builder=Environment.test_env())\n        inventory = [S('inventory'), S('hands')]\n        metta.register_token(\"in-inventory\", lambda _: newInInventory(inventory))",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_minecraft",
        "documentation": {}
    },
    {
        "label": "MinelogyTest",
        "kind": 6,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_minelogy",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_minelogy",
        "peekOfCode": "class MinelogyTest(HyperonTestCase):\n    def test_minelogy(self):\n        # A nearly direct reimplementation of minelogy as it\n        # was in the minecraft demo. Not optimal representation -\n        # just testing.\n        mines = MeTTa(env_builder=Environment.test_env())\n        mines.run('''\n            (((: log type) (: $x variant))\n             (: (stone_axe wooden_axe None) tools)\n             ((: log type) (: $x variant))",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_minelogy",
        "documentation": {}
    },
    {
        "label": "PLNTVTest",
        "kind": 6,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_pln_tv",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_pln_tv",
        "peekOfCode": "class PLNTVTest(HyperonTestCase):\n    def test_fuzzy_conjunction_fn(self):\n        metta = MeTTa(env_builder=Environment.test_env())\n        # `stv` as a mix of function and constructor\n        # working through ordinary equalities\n        metta.run('''\n                (= (min $a $b) (if (< $a $b) $a $b))\n                (= (s-tv (stv $s $c)) $s)\n                (= (c-tv (stv $s $c)) $c)\n                (= (stv (And $a $b))",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_pln_tv",
        "documentation": {}
    },
    {
        "label": "MeTTaTest",
        "kind": 6,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_run_metta",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_run_metta",
        "peekOfCode": "class MeTTaTest(HyperonTestCase):\n    def test_run_metta(self):\n        program = '''\n            (isa red color)\n            (isa green color)\n            (isa blue color)\n            ;(isa comment color)\n            !(match &self (isa $color color) $color)\n            (= (f) (+ 2 3))\n            !(f)",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_run_metta",
        "documentation": {}
    },
    {
        "label": "pwd",
        "kind": 5,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_run_metta",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_run_metta",
        "peekOfCode": "pwd = Path(__file__).parent\nclass MeTTaTest(HyperonTestCase):\n    def test_run_metta(self):\n        program = '''\n            (isa red color)\n            (isa green color)\n            (isa blue color)\n            ;(isa comment color)\n            !(match &self (isa $color color) $color)\n            (= (f) (+ 2 3))",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_run_metta",
        "documentation": {}
    },
    {
        "label": "HyperonTestCase",
        "kind": 6,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_sexparser",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_sexparser",
        "peekOfCode": "class HyperonTestCase(unittest.TestCase):\n    def __init__(self, methodName):\n        super().__init__(methodName)\n    def testParseToSyntaxNodes(self):\n        parser = SExprParser(\"(+ one \\\"one\\\")\")\n        syntax_node = parser.parse_to_syntax_tree()\n        leaf_node_list = syntax_node.unroll()\n        leaf_node_types = [];\n        for node in leaf_node_list:\n            leaf_node_types.append(node.get_type())",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_sexparser",
        "documentation": {}
    },
    {
        "label": "StdlibTest",
        "kind": 6,
        "importPath": "examples.examples.python_compat.hyperon-experimental_python.tests.test_stdlib",
        "description": "examples.examples.python_compat.hyperon-experimental_python.tests.test_stdlib",
        "peekOfCode": "class StdlibTest(HyperonTestCase):\n    def test_text_ops(self):\n        metta = MeTTa(env_builder=Environment.test_env())\n        # Check that (repr (my atom)) == \"(my atom)\"\n        self.assertEqualMettaRunnerResults(metta.run(\"!(repr (my atom))\"),\n                                           [[ValueAtom(\"(my atom)\")]])\n        # Check that (parse \"(my atom)\") == (my atom)\n        self.assertEqualMettaRunnerResults(metta.run(\"!(parse \\\"(my atom)\\\")\"),\n                                           [[ValueAtom(E(S(\"my\"), S(\"atom\")))]])\n        # Check that (stringToChars \"ABC\") == ('A' 'B' 'C')",
        "detail": "examples.examples.python_compat.hyperon-experimental_python.tests.test_stdlib",
        "documentation": {}
    },
    {
        "label": "rand",
        "kind": 2,
        "importPath": "examples.examples.python_compat.janus.mymodule",
        "description": "examples.examples.python_compat.janus.mymodule",
        "peekOfCode": "def rand():\n    return 4",
        "detail": "examples.examples.python_compat.janus.mymodule",
        "documentation": {}
    },
    {
        "label": "tests",
        "kind": 5,
        "importPath": "examples.examples.python_compat.timing.timing",
        "description": "examples.examples.python_compat.timing.timing",
        "peekOfCode": "tests = [\n     \"!(factorial 30)\",\n     \"!(range 1 30)\",\n     \"!(TupleCount (1 2 3 4 5 6 7 8 9 10 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30))\",\n   \"\"\"!(StampDisjoint (1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30) \n                      (1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30))\"\"\"\n]\n#Run and time them:\nruns=10\nprint(f\"Starting {len(tests)} tests with {runs} runs each, grab a coffee!\")",
        "detail": "examples.examples.python_compat.timing.timing",
        "documentation": {}
    },
    {
        "label": "workdir",
        "kind": 5,
        "importPath": "examples.examples.python_compat.timing.timing",
        "description": "examples.examples.python_compat.timing.timing",
        "peekOfCode": "workdir = os.getcwd()\nfor test in tests:\n    os.chdir(workdir)\n    os.system(\"cp timing.metta RUN.metta\")\n    with open(\"RUN.metta\", \"a\") as file:\n        file.write(test)\n    os.chdir(\"../\")\n    os.system(\"sh run.sh ./timing/RUN.metta cat-only\")\n    os.system(\"sh compile_scheme.sh\")\n    os.system(\"./RUN > /dev/null\") #make sure binary is already in file cache",
        "detail": "examples.examples.python_compat.timing.timing",
        "documentation": {}
    },
    {
        "label": "count_atoms",
        "kind": 2,
        "importPath": "examples.extended_compat.hyperon-miner.utils.helper",
        "description": "examples.extended_compat.hyperon-miner.utils.helper",
        "peekOfCode": "def count_atoms():\n    count = OperationAtom(\n        'tuple-count', \n        lambda atom: [ValueAtom(len(atom.get_children()), 'Number')], [AtomType.ATOM, \"Number\"], \n        unwrap=False)\n    return {\n        r\"tuple-count\": count\n    }",
        "detail": "examples.extended_compat.hyperon-miner.utils.helper",
        "documentation": {}
    },
    {
        "label": "test",
        "kind": 2,
        "importPath": "examples.extended_compat.metta-examples.logic.puzzle",
        "description": "examples.extended_compat.metta-examples.logic.puzzle",
        "peekOfCode": "def test():\n        program = '''\n                (: quote (-> Atom Atom))\n                ; convert (a b c) to (Cons a (Cons b (Cons c Nil)))\n                (: makelist (-> Atom Atom))\n                (= (makelist $x)\n                    (if (== () $x) Nil (let $cdr (cdr-atom $x) \n                                                (Cons (car-atom $x) (makelist $cdr)))\n                    )\n                )",
        "detail": "examples.extended_compat.metta-examples.logic.puzzle",
        "documentation": {}
    },
    {
        "label": "MeTTa",
        "kind": 6,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "class MeTTa:\n    def __init__(self, space=None):\n        self.space = GroundingSpace(\"&self\") if space is None else space\n        self.tokenizer = Tokenizer()\n        self.cwd = []  # current working directory as an array\n        self._tokenizer()\n    def _tokenizer(self):\n        self.add_atom(r\"\\+\", addAtom)\n        self.add_atom(r\"-\", subAtom)\n        self.add_atom(r\"\\*\", mulAtom)",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "match_op",
        "kind": 2,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def match_op(space, pattern, templ_op):\n    space = space.get_object().value\n    return space.subst(pattern, templ_op)\ndef let_op(pattern, atom, templ):\n    space = GroundingSpace()\n    space.add_atom(atom)\n    return space.subst(pattern, templ)\ndef transfer_op(metta, fname):\n    \"\"\"\n    Transfers all atoms from the specified file to the current Space.",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "let_op",
        "kind": 2,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def let_op(pattern, atom, templ):\n    space = GroundingSpace()\n    space.add_atom(atom)\n    return space.subst(pattern, templ)\ndef transfer_op(metta, fname):\n    \"\"\"\n    Transfers all atoms from the specified file to the current Space.\n    \"\"\"\n    metta2 = MeTTa()\n    metta2.cwd = metta.cwd  # inherit current working directory",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "transfer_op",
        "kind": 2,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def transfer_op(metta, fname):\n    \"\"\"\n    Transfers all atoms from the specified file to the current Space.\n    \"\"\"\n    metta2 = MeTTa()\n    metta2.cwd = metta.cwd  # inherit current working directory\n    metta2.import_file(fname.get_object().value)\n    for atom in metta2.space.get_atoms():\n        metta.space.add_atom(atom)\n    return []",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "make_transfer_op",
        "kind": 2,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def make_transfer_op(metta):\n    return OperationAtom(\n        'transfer!',\n        lambda file: transfer_op(metta, file),\n        unwrap=False)\ndef make_all_atoms_op(metta):\n    return OperationAtom(\n        'all',\n        lambda: metta.space.get_atoms(),\n        unwrap=False)",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "make_all_atoms_op",
        "kind": 2,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def make_all_atoms_op(metta):\n    return OperationAtom(\n        'all',\n        lambda: metta.space.get_atoms(),\n        unwrap=False)\ndef letrec_op(subs, body):\n    # just unsugaring `let*`` into `let` substitution by substitution\n    subs = subs.get_children()\n    if len(subs) == 0:\n        return [body]",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "letrec_op",
        "kind": 2,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def letrec_op(subs, body):\n    # just unsugaring `let*`` into `let` substitution by substitution\n    subs = subs.get_children()\n    if len(subs) == 0:\n        return [body]\n    next_sub = subs[0].get_children()\n    if len(subs) == 1:\n        return [E(letAtom, next_sub[0], next_sub[1], body)]\n    return [E(letAtom, next_sub[0], next_sub[1], E(letrecAtom, E(*subs[1:]), body))]\ndef call_atom_op(atom, method_str, *args):",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "call_atom_op",
        "kind": 2,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def call_atom_op(atom, method_str, *args):\n    if not isinstance(atom, GroundedAtom):\n        raise NoReduceError()\n    obj = atom.get_object().value\n    method = getattr(obj, method_str)\n    result = method(*args)\n    if result is None:\n        return []\n    # Fixme? getting results from call_atom raises some issues but convenient.\n    # Running example is call:... &self (or another imported space)",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "print_op",
        "kind": 2,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def print_op(atom):\n    print(atom)\n    return []\ndef assert_results_equal(result, expected):\n    report = \"Expected: \" + str(expected) + \"\\nGot: \" + str(result)\n    for r in result:\n        if r not in expected:\n            raise RuntimeError(report + \"\\nExcessive result: \" + str(r))\n    for e in expected:\n        if e not in result:",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "assert_results_equal",
        "kind": 2,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def assert_results_equal(result, expected):\n    report = \"Expected: \" + str(expected) + \"\\nGot: \" + str(result)\n    for r in result:\n        if r not in expected:\n            raise RuntimeError(report + \"\\nExcessive result: \" + str(r))\n    for e in expected:\n        if e not in result:\n            raise RuntimeError(report + \"\\nMissed result: \" + str(e))\n    if len(expected) != len(result):\n        # NOTE: (1 1 2) vs (1 2 2) will pass",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "make_assert_equal_atom",
        "kind": 2,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def make_assert_equal_atom(metta):\n    return OperationAtom(\n        'assertEqual',\n        lambda e1, e2: assert_results_equal(interpret(metta.space, e1), interpret(metta.space, e2)),\n        [AtomType.ATOM, AtomType.ATOM, AtomType.ATOM],\n        unwrap=False)\ndef make_assert_equal_to_result_atom(metta):\n    return OperationAtom(\n        'assertEqualToResult',\n        lambda expr, expected: assert_results_equal(interpret(metta.space, expr), expected.get_children()),",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "make_assert_equal_to_result_atom",
        "kind": 2,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def make_assert_equal_to_result_atom(metta):\n    return OperationAtom(\n        'assertEqualToResult',\n        lambda expr, expected: assert_results_equal(interpret(metta.space, expr), expected.get_children()),\n        [AtomType.ATOM, AtomType.ATOM, AtomType.ATOM],\n        unwrap=False)\n# E(S('->'), S('Number'), S('Number'), S('Number'))\nsubAtom = OperationAtom('-', lambda a, b: a - b, ['Number', 'Number', 'Number'])\nmulAtom = OperationAtom('*', lambda a, b: a * b, ['Number', 'Number', 'Number'])\naddAtom = OperationAtom('+', lambda a, b: a + b, ['Number', 'Number', 'Number'])",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "make_call_atom",
        "kind": 2,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def make_call_atom(token):\n    # NOTE: we could use \"call\" as a plain symbol (insted of \"call:...\")\n    #       with the method name as the parameter of call_atom_op\n    #       (but this parameter should be unwrapped)\n    # \"call:...\" is an interesting example of families of tokens for ops, though\n    return OperationAtom(\n        token,\n        lambda obj, *args: call_atom_op(obj, token[5:], *args),\n        unwrap=False)\ndef SpaceAtom(grounding_space, repr_name=None):",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "SpaceAtom",
        "kind": 2,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def SpaceAtom(grounding_space, repr_name=None):\n    # Overriding grounding_space.repr_name here\n    # It will be changed in all occurences of this Space\n    if repr_name is not None:\n        grounding_space.repr_name = repr_name\n    return ValueAtom(grounding_space, 'Space')\ndef import_op(metta, space, fname):\n    # Check if space wasn't resolved\n    if space.get_type() == AtomKind.SYMBOL:\n        # Create new space",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "import_op",
        "kind": 2,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def import_op(metta, space, fname):\n    # Check if space wasn't resolved\n    if space.get_type() == AtomKind.SYMBOL:\n        # Create new space\n        name = space.get_name()\n        space = GroundingSpace()\n        # Register this space under name `name`\n        metta.add_atom(name, SpaceAtom(space, name))\n    else:\n        space = space.get_object().value",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "make_import_op",
        "kind": 2,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def make_import_op(metta):\n    # unwrap=False, because space name can remain\n    # an unresolved symbol atom\n    return OperationAtom(\n        'import!',\n        lambda s, f: import_op(metta, s, f),\n        unwrap=False)\ndef pragma_op(metta, key, *args):\n    # TODO: add support for Grounded values when needed\n    metta.settings[key.get_name()] = \\",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "pragma_op",
        "kind": 2,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def pragma_op(metta, key, *args):\n    # TODO: add support for Grounded values when needed\n    metta.settings[key.get_name()] = \\\n        args[0].get_name() if len(args) == 1 else \\\n            [arg.get_name() for arg in args]\n    return []\ndef make_pragma_op(metta):\n    return OperationAtom(\n        'pragma!',\n        lambda key, *args: pragma_op(metta, key, *args),",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "make_pragma_op",
        "kind": 2,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def make_pragma_op(metta):\n    return OperationAtom(\n        'pragma!',\n        lambda key, *args: pragma_op(metta, key, *args),\n        unwrap=False)\ndef make_collapse_atom(metta):\n    # FIXME? Calling interpreter inside the operation is not too good\n    #        Could it be done via StepResult?\n    return OperationAtom(\n        'collapse',",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "make_collapse_atom",
        "kind": 2,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def make_collapse_atom(metta):\n    # FIXME? Calling interpreter inside the operation is not too good\n    #        Could it be done via StepResult?\n    return OperationAtom(\n        'collapse',\n        lambda atom: [E(*interpret(metta.space, atom))],\n        [AtomType.ATOM, AtomType.ATOM],\n        unwrap=False)\n# `superpose` receives one atom (expression) in order to make composition\n# `(superpose (collapse ...))` possible",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "superpose_op",
        "kind": 2,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def superpose_op(expr):\n    if isinstance(expr, ExpressionAtom):\n        return [arg for arg in expr.get_children()]\n    return [expr]\nsuperposeAtom = OperationAtom('superpose', superpose_op, unwrap=False)\ndef color(t, c):\n    cmap = [90, 91, 31, 93, 92, 32, 36, 96, 94, 34, 35, 95, 38]\n    return f\"\\033[{cmap[c % len(cmap)]}m{t}\\033[0m\"\ndef oblique(t):\n    return f\"\\033[3m{t}\\033[0m\"",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "color",
        "kind": 2,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def color(t, c):\n    cmap = [90, 91, 31, 93, 92, 32, 36, 96, 94, 34, 35, 95, 38]\n    return f\"\\033[{cmap[c % len(cmap)]}m{t}\\033[0m\"\ndef oblique(t):\n    return f\"\\033[3m{t}\\033[0m\"\ndef underline(t):\n    return f\"\\033[4m{t}\\033[0m\"\ndef expr_vars(expr):\n    if isinstance(expr, SymbolAtom):\n        return []",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "oblique",
        "kind": 2,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def oblique(t):\n    return f\"\\033[3m{t}\\033[0m\"\ndef underline(t):\n    return f\"\\033[4m{t}\\033[0m\"\ndef expr_vars(expr):\n    if isinstance(expr, SymbolAtom):\n        return []\n    elif isinstance(expr, VariableAtom):\n        return [str(expr)]\n    elif isinstance(expr, ExpressionAtom):",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "underline",
        "kind": 2,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def underline(t):\n    return f\"\\033[4m{t}\\033[0m\"\ndef expr_vars(expr):\n    if isinstance(expr, SymbolAtom):\n        return []\n    elif isinstance(expr, VariableAtom):\n        return [str(expr)]\n    elif isinstance(expr, ExpressionAtom):\n        return [e for c in expr.get_children() for e in expr_vars(c)]\n    elif isinstance(expr, GroundedAtom):",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "expr_vars",
        "kind": 2,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def expr_vars(expr):\n    if isinstance(expr, SymbolAtom):\n        return []\n    elif isinstance(expr, VariableAtom):\n        return [str(expr)]\n    elif isinstance(expr, ExpressionAtom):\n        return [e for c in expr.get_children() for e in expr_vars(c)]\n    elif isinstance(expr, GroundedAtom):\n        return []\n    else:",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "color_expr",
        "kind": 2,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "def color_expr(expr, level=0, unif_vars=None):\n    name = str(expr)\n    if level == 0:\n        unif_vars = frozenset(e for e, c in Counter(expr_vars(expr)).items() if c > 1) \\\n            if unif_vars is None else frozenset()\n    if isinstance(expr, SymbolAtom):\n        return name\n    elif isinstance(expr, VariableAtom):\n        return oblique(name) if name in unif_vars else name\n    elif isinstance(expr, ExpressionAtom):",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "subAtom",
        "kind": 5,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "subAtom = OperationAtom('-', lambda a, b: a - b, ['Number', 'Number', 'Number'])\nmulAtom = OperationAtom('*', lambda a, b: a * b, ['Number', 'Number', 'Number'])\naddAtom = OperationAtom('+', lambda a, b: a + b, ['Number', 'Number', 'Number'])\ndivAtom = OperationAtom('/', lambda a, b: a / b, ['Number', 'Number', 'Number'])\nmodAtom = OperationAtom('%', lambda a, b: a % b, ['Number', 'Number', 'Number'])\nequalAtom = OperationAtom('==', lambda a, b: a == b, ['$t', '$t', 'Bool'])\ngreaterAtom = OperationAtom('>', lambda a, b: a > b, ['Number', 'Number', 'Bool'])\nlessAtom = OperationAtom('<', lambda a, b: a < b, ['Number', 'Number', 'Bool'])\norAtom = OperationAtom('or', lambda a, b: a or b, ['Bool', 'Bool', 'Bool'])\nandAtom = OperationAtom('and', lambda a, b: a and b, ['Bool', 'Bool', 'Bool'])",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "mulAtom",
        "kind": 5,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "mulAtom = OperationAtom('*', lambda a, b: a * b, ['Number', 'Number', 'Number'])\naddAtom = OperationAtom('+', lambda a, b: a + b, ['Number', 'Number', 'Number'])\ndivAtom = OperationAtom('/', lambda a, b: a / b, ['Number', 'Number', 'Number'])\nmodAtom = OperationAtom('%', lambda a, b: a % b, ['Number', 'Number', 'Number'])\nequalAtom = OperationAtom('==', lambda a, b: a == b, ['$t', '$t', 'Bool'])\ngreaterAtom = OperationAtom('>', lambda a, b: a > b, ['Number', 'Number', 'Bool'])\nlessAtom = OperationAtom('<', lambda a, b: a < b, ['Number', 'Number', 'Bool'])\norAtom = OperationAtom('or', lambda a, b: a or b, ['Bool', 'Bool', 'Bool'])\nandAtom = OperationAtom('and', lambda a, b: a and b, ['Bool', 'Bool', 'Bool'])\nnotAtom = OperationAtom('not', lambda a: not a, ['Bool', 'Bool'])",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "addAtom",
        "kind": 5,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "addAtom = OperationAtom('+', lambda a, b: a + b, ['Number', 'Number', 'Number'])\ndivAtom = OperationAtom('/', lambda a, b: a / b, ['Number', 'Number', 'Number'])\nmodAtom = OperationAtom('%', lambda a, b: a % b, ['Number', 'Number', 'Number'])\nequalAtom = OperationAtom('==', lambda a, b: a == b, ['$t', '$t', 'Bool'])\ngreaterAtom = OperationAtom('>', lambda a, b: a > b, ['Number', 'Number', 'Bool'])\nlessAtom = OperationAtom('<', lambda a, b: a < b, ['Number', 'Number', 'Bool'])\norAtom = OperationAtom('or', lambda a, b: a or b, ['Bool', 'Bool', 'Bool'])\nandAtom = OperationAtom('and', lambda a, b: a and b, ['Bool', 'Bool', 'Bool'])\nnotAtom = OperationAtom('not', lambda a: not a, ['Bool', 'Bool'])\n# Any number of arguments for `nop` (including zero) due to *args",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "divAtom",
        "kind": 5,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "divAtom = OperationAtom('/', lambda a, b: a / b, ['Number', 'Number', 'Number'])\nmodAtom = OperationAtom('%', lambda a, b: a % b, ['Number', 'Number', 'Number'])\nequalAtom = OperationAtom('==', lambda a, b: a == b, ['$t', '$t', 'Bool'])\ngreaterAtom = OperationAtom('>', lambda a, b: a > b, ['Number', 'Number', 'Bool'])\nlessAtom = OperationAtom('<', lambda a, b: a < b, ['Number', 'Number', 'Bool'])\norAtom = OperationAtom('or', lambda a, b: a or b, ['Bool', 'Bool', 'Bool'])\nandAtom = OperationAtom('and', lambda a, b: a and b, ['Bool', 'Bool', 'Bool'])\nnotAtom = OperationAtom('not', lambda a: not a, ['Bool', 'Bool'])\n# Any number of arguments for `nop` (including zero) due to *args\nnopAtom = OperationAtom('nop', lambda *args: [], unwrap=False)",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "modAtom",
        "kind": 5,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "modAtom = OperationAtom('%', lambda a, b: a % b, ['Number', 'Number', 'Number'])\nequalAtom = OperationAtom('==', lambda a, b: a == b, ['$t', '$t', 'Bool'])\ngreaterAtom = OperationAtom('>', lambda a, b: a > b, ['Number', 'Number', 'Bool'])\nlessAtom = OperationAtom('<', lambda a, b: a < b, ['Number', 'Number', 'Bool'])\norAtom = OperationAtom('or', lambda a, b: a or b, ['Bool', 'Bool', 'Bool'])\nandAtom = OperationAtom('and', lambda a, b: a and b, ['Bool', 'Bool', 'Bool'])\nnotAtom = OperationAtom('not', lambda a: not a, ['Bool', 'Bool'])\n# Any number of arguments for `nop` (including zero) due to *args\nnopAtom = OperationAtom('nop', lambda *args: [], unwrap=False)\n# FIXME? Undefined for the argument is necessary to make argument reductable.",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "equalAtom",
        "kind": 5,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "equalAtom = OperationAtom('==', lambda a, b: a == b, ['$t', '$t', 'Bool'])\ngreaterAtom = OperationAtom('>', lambda a, b: a > b, ['Number', 'Number', 'Bool'])\nlessAtom = OperationAtom('<', lambda a, b: a < b, ['Number', 'Number', 'Bool'])\norAtom = OperationAtom('or', lambda a, b: a or b, ['Bool', 'Bool', 'Bool'])\nandAtom = OperationAtom('and', lambda a, b: a and b, ['Bool', 'Bool', 'Bool'])\nnotAtom = OperationAtom('not', lambda a: not a, ['Bool', 'Bool'])\n# Any number of arguments for `nop` (including zero) due to *args\nnopAtom = OperationAtom('nop', lambda *args: [], unwrap=False)\n# FIXME? Undefined for the argument is necessary to make argument reductable.\nletAtom = OperationAtom('let', let_op,",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "greaterAtom",
        "kind": 5,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "greaterAtom = OperationAtom('>', lambda a, b: a > b, ['Number', 'Number', 'Bool'])\nlessAtom = OperationAtom('<', lambda a, b: a < b, ['Number', 'Number', 'Bool'])\norAtom = OperationAtom('or', lambda a, b: a or b, ['Bool', 'Bool', 'Bool'])\nandAtom = OperationAtom('and', lambda a, b: a and b, ['Bool', 'Bool', 'Bool'])\nnotAtom = OperationAtom('not', lambda a: not a, ['Bool', 'Bool'])\n# Any number of arguments for `nop` (including zero) due to *args\nnopAtom = OperationAtom('nop', lambda *args: [], unwrap=False)\n# FIXME? Undefined for the argument is necessary to make argument reductable.\nletAtom = OperationAtom('let', let_op,\n                        type_names=[AtomType.VARIABLE, AtomType.UNDEFINED, AtomType.ATOM, AtomType.ATOM], unwrap=False)",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "lessAtom",
        "kind": 5,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "lessAtom = OperationAtom('<', lambda a, b: a < b, ['Number', 'Number', 'Bool'])\norAtom = OperationAtom('or', lambda a, b: a or b, ['Bool', 'Bool', 'Bool'])\nandAtom = OperationAtom('and', lambda a, b: a and b, ['Bool', 'Bool', 'Bool'])\nnotAtom = OperationAtom('not', lambda a: not a, ['Bool', 'Bool'])\n# Any number of arguments for `nop` (including zero) due to *args\nnopAtom = OperationAtom('nop', lambda *args: [], unwrap=False)\n# FIXME? Undefined for the argument is necessary to make argument reductable.\nletAtom = OperationAtom('let', let_op,\n                        type_names=[AtomType.VARIABLE, AtomType.UNDEFINED, AtomType.ATOM, AtomType.ATOM], unwrap=False)\n# The first argument is an Atom, because it has to be evaluated iteratively",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "orAtom",
        "kind": 5,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "orAtom = OperationAtom('or', lambda a, b: a or b, ['Bool', 'Bool', 'Bool'])\nandAtom = OperationAtom('and', lambda a, b: a and b, ['Bool', 'Bool', 'Bool'])\nnotAtom = OperationAtom('not', lambda a: not a, ['Bool', 'Bool'])\n# Any number of arguments for `nop` (including zero) due to *args\nnopAtom = OperationAtom('nop', lambda *args: [], unwrap=False)\n# FIXME? Undefined for the argument is necessary to make argument reductable.\nletAtom = OperationAtom('let', let_op,\n                        type_names=[AtomType.VARIABLE, AtomType.UNDEFINED, AtomType.ATOM, AtomType.ATOM], unwrap=False)\n# The first argument is an Atom, because it has to be evaluated iteratively\nletrecAtom = OperationAtom('let*', letrec_op,",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "andAtom",
        "kind": 5,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "andAtom = OperationAtom('and', lambda a, b: a and b, ['Bool', 'Bool', 'Bool'])\nnotAtom = OperationAtom('not', lambda a: not a, ['Bool', 'Bool'])\n# Any number of arguments for `nop` (including zero) due to *args\nnopAtom = OperationAtom('nop', lambda *args: [], unwrap=False)\n# FIXME? Undefined for the argument is necessary to make argument reductable.\nletAtom = OperationAtom('let', let_op,\n                        type_names=[AtomType.VARIABLE, AtomType.UNDEFINED, AtomType.ATOM, AtomType.ATOM], unwrap=False)\n# The first argument is an Atom, because it has to be evaluated iteratively\nletrecAtom = OperationAtom('let*', letrec_op,\n                           type_names=[AtomType.ATOM, AtomType.ATOM, AtomType.ATOM], unwrap=False)",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "notAtom",
        "kind": 5,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "notAtom = OperationAtom('not', lambda a: not a, ['Bool', 'Bool'])\n# Any number of arguments for `nop` (including zero) due to *args\nnopAtom = OperationAtom('nop', lambda *args: [], unwrap=False)\n# FIXME? Undefined for the argument is necessary to make argument reductable.\nletAtom = OperationAtom('let', let_op,\n                        type_names=[AtomType.VARIABLE, AtomType.UNDEFINED, AtomType.ATOM, AtomType.ATOM], unwrap=False)\n# The first argument is an Atom, because it has to be evaluated iteratively\nletrecAtom = OperationAtom('let*', letrec_op,\n                           type_names=[AtomType.ATOM, AtomType.ATOM, AtomType.ATOM], unwrap=False)\nmatchAtom = OperationAtom('match', match_op,",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "nopAtom",
        "kind": 5,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "nopAtom = OperationAtom('nop', lambda *args: [], unwrap=False)\n# FIXME? Undefined for the argument is necessary to make argument reductable.\nletAtom = OperationAtom('let', let_op,\n                        type_names=[AtomType.VARIABLE, AtomType.UNDEFINED, AtomType.ATOM, AtomType.ATOM], unwrap=False)\n# The first argument is an Atom, because it has to be evaluated iteratively\nletrecAtom = OperationAtom('let*', letrec_op,\n                           type_names=[AtomType.ATOM, AtomType.ATOM, AtomType.ATOM], unwrap=False)\nmatchAtom = OperationAtom('match', match_op,\n                          type_names=[\"Space\", AtomType.ATOM, AtomType.ATOM, AtomType.UNDEFINED], unwrap=False)\nprintAtom = OperationAtom('println!', print_op, [AtomType.UNDEFINED, 'IO'], unwrap=False)",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "letAtom",
        "kind": 5,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "letAtom = OperationAtom('let', let_op,\n                        type_names=[AtomType.VARIABLE, AtomType.UNDEFINED, AtomType.ATOM, AtomType.ATOM], unwrap=False)\n# The first argument is an Atom, because it has to be evaluated iteratively\nletrecAtom = OperationAtom('let*', letrec_op,\n                           type_names=[AtomType.ATOM, AtomType.ATOM, AtomType.ATOM], unwrap=False)\nmatchAtom = OperationAtom('match', match_op,\n                          type_names=[\"Space\", AtomType.ATOM, AtomType.ATOM, AtomType.UNDEFINED], unwrap=False)\nprintAtom = OperationAtom('println!', print_op, [AtomType.UNDEFINED, 'IO'], unwrap=False)\ndef make_call_atom(token):\n    # NOTE: we could use \"call\" as a plain symbol (insted of \"call:...\")",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "letrecAtom",
        "kind": 5,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "letrecAtom = OperationAtom('let*', letrec_op,\n                           type_names=[AtomType.ATOM, AtomType.ATOM, AtomType.ATOM], unwrap=False)\nmatchAtom = OperationAtom('match', match_op,\n                          type_names=[\"Space\", AtomType.ATOM, AtomType.ATOM, AtomType.UNDEFINED], unwrap=False)\nprintAtom = OperationAtom('println!', print_op, [AtomType.UNDEFINED, 'IO'], unwrap=False)\ndef make_call_atom(token):\n    # NOTE: we could use \"call\" as a plain symbol (insted of \"call:...\")\n    #       with the method name as the parameter of call_atom_op\n    #       (but this parameter should be unwrapped)\n    # \"call:...\" is an interesting example of families of tokens for ops, though",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "matchAtom",
        "kind": 5,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "matchAtom = OperationAtom('match', match_op,\n                          type_names=[\"Space\", AtomType.ATOM, AtomType.ATOM, AtomType.UNDEFINED], unwrap=False)\nprintAtom = OperationAtom('println!', print_op, [AtomType.UNDEFINED, 'IO'], unwrap=False)\ndef make_call_atom(token):\n    # NOTE: we could use \"call\" as a plain symbol (insted of \"call:...\")\n    #       with the method name as the parameter of call_atom_op\n    #       (but this parameter should be unwrapped)\n    # \"call:...\" is an interesting example of families of tokens for ops, though\n    return OperationAtom(\n        token,",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "printAtom",
        "kind": 5,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "printAtom = OperationAtom('println!', print_op, [AtomType.UNDEFINED, 'IO'], unwrap=False)\ndef make_call_atom(token):\n    # NOTE: we could use \"call\" as a plain symbol (insted of \"call:...\")\n    #       with the method name as the parameter of call_atom_op\n    #       (but this parameter should be unwrapped)\n    # \"call:...\" is an interesting example of families of tokens for ops, though\n    return OperationAtom(\n        token,\n        lambda obj, *args: call_atom_op(obj, token[5:], *args),\n        unwrap=False)",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "superposeAtom",
        "kind": 5,
        "importPath": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "description": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "peekOfCode": "superposeAtom = OperationAtom('superpose', superpose_op, unwrap=False)\ndef color(t, c):\n    cmap = [90, 91, 31, 93, 92, 32, 36, 96, 94, 34, 35, 95, 38]\n    return f\"\\033[{cmap[c % len(cmap)]}m{t}\\033[0m\"\ndef oblique(t):\n    return f\"\\033[3m{t}\\033[0m\"\ndef underline(t):\n    return f\"\\033[4m{t}\\033[0m\"\ndef expr_vars(expr):\n    if isinstance(expr, SymbolAtom):",
        "detail": "examples.extended_compat.metta-examples.recursion-schemes.base",
        "documentation": {}
    },
    {
        "label": "updateSeed",
        "kind": 2,
        "importPath": "examples.extended_compat.metta-examples.SICP_book.additional_funcs",
        "description": "examples.extended_compat.metta-examples.SICP_book.additional_funcs",
        "peekOfCode": "def updateSeed():\n    random.seed(getCurTime())\ndef getRandInt(start, end):\n    updateSeed()\n    return random.randint(start, end)\ndef getCurTime():\n    return time.time_ns() / (10 ** 6)\n@register_atoms\ndef my_glob_atoms():\n    return {",
        "detail": "examples.extended_compat.metta-examples.SICP_book.additional_funcs",
        "documentation": {}
    },
    {
        "label": "getRandInt",
        "kind": 2,
        "importPath": "examples.extended_compat.metta-examples.SICP_book.additional_funcs",
        "description": "examples.extended_compat.metta-examples.SICP_book.additional_funcs",
        "peekOfCode": "def getRandInt(start, end):\n    updateSeed()\n    return random.randint(start, end)\ndef getCurTime():\n    return time.time_ns() / (10 ** 6)\n@register_atoms\ndef my_glob_atoms():\n    return {\n        'randomint!': OperationAtom(\"randomint!\", getRandInt),\n        'timems!': OperationAtom(\"timems!\", getCurTime),",
        "detail": "examples.extended_compat.metta-examples.SICP_book.additional_funcs",
        "documentation": {}
    },
    {
        "label": "getCurTime",
        "kind": 2,
        "importPath": "examples.extended_compat.metta-examples.SICP_book.additional_funcs",
        "description": "examples.extended_compat.metta-examples.SICP_book.additional_funcs",
        "peekOfCode": "def getCurTime():\n    return time.time_ns() / (10 ** 6)\n@register_atoms\ndef my_glob_atoms():\n    return {\n        'randomint!': OperationAtom(\"randomint!\", getRandInt),\n        'timems!': OperationAtom(\"timems!\", getCurTime),\n        }",
        "detail": "examples.extended_compat.metta-examples.SICP_book.additional_funcs",
        "documentation": {}
    },
    {
        "label": "my_glob_atoms",
        "kind": 2,
        "importPath": "examples.extended_compat.metta-examples.SICP_book.additional_funcs",
        "description": "examples.extended_compat.metta-examples.SICP_book.additional_funcs",
        "peekOfCode": "def my_glob_atoms():\n    return {\n        'randomint!': OperationAtom(\"randomint!\", getRandInt),\n        'timems!': OperationAtom(\"timems!\", getCurTime),\n        }",
        "detail": "examples.extended_compat.metta-examples.SICP_book.additional_funcs",
        "documentation": {}
    },
    {
        "label": "query",
        "kind": 2,
        "importPath": "examples.flybase.from_das.mettalog_das_client",
        "description": "examples.flybase.from_das.mettalog_das_client",
        "peekOfCode": "def query(das, symbol, node_type = None):\n    fbgns = _fbgns(das, symbol)\n    print(f\"FBgn: {fbgns}\")\n    answer = []\n    for fbgn in fbgns:\n        query_answer = das.query({\n            \"atom_type\": \"link\",\n            \"type\": \"Execution\",\n            \"targets\": [\n                {\"atom_type\": \"variable\", \"name\": \"v0\"},",
        "detail": "examples.flybase.from_das.mettalog_das_client",
        "documentation": {}
    },
    {
        "label": "host",
        "kind": 5,
        "importPath": "examples.flybase.from_das.mettalog_das_client",
        "description": "examples.flybase.from_das.mettalog_das_client",
        "peekOfCode": "host = '104.238.183.115'\nport = '8081'\ndas = DistributedAtomSpace(query_engine='remote', host=host, port=port)\nprint(f\"Connected to DAS at {host}:{port}\")\ndef _filter(query_answer, index, value):\n    filtered = []\n    for link in query_answer:\n        if link['targets'][index]['type'] == value:\n            filtered.append(link)\n    return filtered",
        "detail": "examples.flybase.from_das.mettalog_das_client",
        "documentation": {}
    },
    {
        "label": "port",
        "kind": 5,
        "importPath": "examples.flybase.from_das.mettalog_das_client",
        "description": "examples.flybase.from_das.mettalog_das_client",
        "peekOfCode": "port = '8081'\ndas = DistributedAtomSpace(query_engine='remote', host=host, port=port)\nprint(f\"Connected to DAS at {host}:{port}\")\ndef _filter(query_answer, index, value):\n    filtered = []\n    for link in query_answer:\n        if link['targets'][index]['type'] == value:\n            filtered.append(link)\n    return filtered\ndef _fbgns(das, symbol, handles=False):",
        "detail": "examples.flybase.from_das.mettalog_das_client",
        "documentation": {}
    },
    {
        "label": "das",
        "kind": 5,
        "importPath": "examples.flybase.from_das.mettalog_das_client",
        "description": "examples.flybase.from_das.mettalog_das_client",
        "peekOfCode": "das = DistributedAtomSpace(query_engine='remote', host=host, port=port)\nprint(f\"Connected to DAS at {host}:{port}\")\ndef _filter(query_answer, index, value):\n    filtered = []\n    for link in query_answer:\n        if link['targets'][index]['type'] == value:\n            filtered.append(link)\n    return filtered\ndef _fbgns(das, symbol, handles=False):\n    answer = das.query({",
        "detail": "examples.flybase.from_das.mettalog_das_client",
        "documentation": {}
    },
    {
        "label": "query",
        "kind": 2,
        "importPath": "examples.flybase.from_das.script_example_BIO",
        "description": "examples.flybase.from_das.script_example_BIO",
        "peekOfCode": "def query(das, symbol, node_type = None):\n    fbgns = _fbgns(das, symbol)\n    print(f\"FBgn: {fbgns}\")\n    answer = []\n    for fbgn in fbgns:\n        query_answer = das.query({\n            \"atom_type\": \"link\",\n            \"type\": \"Execution\",\n            \"targets\": [\n                {\"atom_type\": \"variable\", \"name\": \"v0\"},",
        "detail": "examples.flybase.from_das.script_example_BIO",
        "documentation": {}
    },
    {
        "label": "host",
        "kind": 5,
        "importPath": "examples.flybase.from_das.script_example_BIO",
        "description": "examples.flybase.from_das.script_example_BIO",
        "peekOfCode": "host = '104.238.183.115'\nport = '8081'\ndas = DistributedAtomSpace(query_engine='remote', host=host, port=port)\nprint(f\"Connected to DAS at {host}:{port}\")\ndef _filter(query_answer, index, value):\n    filtered = []\n    for link in query_answer:\n        if link['targets'][index]['type'] == value:\n            filtered.append(link)\n    return filtered",
        "detail": "examples.flybase.from_das.script_example_BIO",
        "documentation": {}
    },
    {
        "label": "port",
        "kind": 5,
        "importPath": "examples.flybase.from_das.script_example_BIO",
        "description": "examples.flybase.from_das.script_example_BIO",
        "peekOfCode": "port = '8081'\ndas = DistributedAtomSpace(query_engine='remote', host=host, port=port)\nprint(f\"Connected to DAS at {host}:{port}\")\ndef _filter(query_answer, index, value):\n    filtered = []\n    for link in query_answer:\n        if link['targets'][index]['type'] == value:\n            filtered.append(link)\n    return filtered\ndef _fbgns(das, symbol, handles=False):",
        "detail": "examples.flybase.from_das.script_example_BIO",
        "documentation": {}
    },
    {
        "label": "das",
        "kind": 5,
        "importPath": "examples.flybase.from_das.script_example_BIO",
        "description": "examples.flybase.from_das.script_example_BIO",
        "peekOfCode": "das = DistributedAtomSpace(query_engine='remote', host=host, port=port)\nprint(f\"Connected to DAS at {host}:{port}\")\ndef _filter(query_answer, index, value):\n    filtered = []\n    for link in query_answer:\n        if link['targets'][index]['type'] == value:\n            filtered.append(link)\n    return filtered\ndef _fbgns(das, symbol, handles=False):\n    answer = das.query({",
        "detail": "examples.flybase.from_das.script_example_BIO",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "examples.performance.gpt2-like.corpus.self_dialogue_corpus.old.get_data",
        "description": "examples.performance.gpt2-like.corpus.self_dialogue_corpus.old.get_data",
        "peekOfCode": "def main():\n    args = parse_args()\n    logger.info(\"Will write data to {0}.\".format(args.outDir))\n    # Create output directories\n    train_dir = create_dirs(args.outDir)\n    if os.path.isfile(\"blocked_workers.txt\"):\n        with open(\"blocked_workers.txt\") as f:\n            blocked_workers = f.read().splitlines()\n    else:\n        blocked_workers = []",
        "detail": "examples.performance.gpt2-like.corpus.self_dialogue_corpus.old.get_data",
        "documentation": {}
    },
    {
        "label": "write_dialogues",
        "kind": 2,
        "importPath": "examples.performance.gpt2-like.corpus.self_dialogue_corpus.old.get_data",
        "description": "examples.performance.gpt2-like.corpus.self_dialogue_corpus.old.get_data",
        "peekOfCode": "def write_dialogues(dialogues, keys, directory, args):\n    \"\"\"Writes dialogues given keys to directory.\"\"\"\n    counter = 0\n    for key in keys:\n        if args.output_naming == \"integer\":\n            filename = counter\n        elif args.output_naming == \"assignment_id\":\n            filename = key\n        dialogue = dialogues[key]\n        with open(\"{0}/{1}.txt\".format(directory, filename), 'w') as f:",
        "detail": "examples.performance.gpt2-like.corpus.self_dialogue_corpus.old.get_data",
        "documentation": {}
    },
    {
        "label": "read_data",
        "kind": 2,
        "importPath": "examples.performance.gpt2-like.corpus.self_dialogue_corpus.old.get_data",
        "description": "examples.performance.gpt2-like.corpus.self_dialogue_corpus.old.get_data",
        "peekOfCode": "def read_data(directory, blocked_workers=[]):\n    \"\"\"Reads data from CSVs in a directory and \n    returns a dictionary indexed by assignment IDs.\n    Ignores workers in blocked_workers list.\"\"\"\n    dialogues = {} # indexed by assignment IDs\n    for filename in glob(\"{0}/*.csv\".format(directory)):\n        with open(filename) as f:\n            csvreader = csv.DictReader(f)\n            for row in csvreader:\n                # if len(restrict_to) > 0:",
        "detail": "examples.performance.gpt2-like.corpus.self_dialogue_corpus.old.get_data",
        "documentation": {}
    },
    {
        "label": "create_dirs",
        "kind": 2,
        "importPath": "examples.performance.gpt2-like.corpus.self_dialogue_corpus.old.get_data",
        "description": "examples.performance.gpt2-like.corpus.self_dialogue_corpus.old.get_data",
        "peekOfCode": "def create_dirs(root_dir):\n    \"\"\"Create training directories. Returns their paths.\"\"\"\n    train_dir = \"{0}/\".format(root_dir)\n    for d in [train_dir]:\n        if not os.path.exists(d):\n            os.makedirs(d)\n    return train_dir \ndef parse_args():\n    \"\"\"Parse input arguments.\"\"\"\n    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter,",
        "detail": "examples.performance.gpt2-like.corpus.self_dialogue_corpus.old.get_data",
        "documentation": {}
    },
    {
        "label": "parse_args",
        "kind": 2,
        "importPath": "examples.performance.gpt2-like.corpus.self_dialogue_corpus.old.get_data",
        "description": "examples.performance.gpt2-like.corpus.self_dialogue_corpus.old.get_data",
        "peekOfCode": "def parse_args():\n    \"\"\"Parse input arguments.\"\"\"\n    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter,\n            description=\"\"\"Prepares data directories with dialogues from the\n            self-dialogue corpus.\"\"\",\n            epilog=\"Example usage: python get_data.py\")\n    parser.add_argument(\"--inDir\", \n            help=\"Source data directory.\",default=\"corpus\")\n    parser.add_argument(\"--outDir\",\n            help=\"Where to store output data directories (train, dev, test).\",default=\"dialogues\")",
        "detail": "examples.performance.gpt2-like.corpus.self_dialogue_corpus.old.get_data",
        "documentation": {}
    },
    {
        "label": "logger",
        "kind": 5,
        "importPath": "examples.performance.gpt2-like.corpus.self_dialogue_corpus.old.get_data",
        "description": "examples.performance.gpt2-like.corpus.self_dialogue_corpus.old.get_data",
        "peekOfCode": "logger = logging.getLogger('Self dialogue corpus')\ndef main():\n    args = parse_args()\n    logger.info(\"Will write data to {0}.\".format(args.outDir))\n    # Create output directories\n    train_dir = create_dirs(args.outDir)\n    if os.path.isfile(\"blocked_workers.txt\"):\n        with open(\"blocked_workers.txt\") as f:\n            blocked_workers = f.read().splitlines()\n    else:",
        "detail": "examples.performance.gpt2-like.corpus.self_dialogue_corpus.old.get_data",
        "documentation": {}
    },
    {
        "label": "PatternOperation",
        "kind": 6,
        "importPath": "examples.python_compat.extend.mettamorph",
        "description": "examples.python_compat.extend.mettamorph",
        "peekOfCode": "class PatternOperation(OperationObject):\n    def __init__(self, name, op, unwrap=False, rec=False):\n        super().__init__(name, op, unwrap)\n        self.rec = rec\n    def execute(self, *args, res_typ=AtomType.UNDEFINED):\n        return super().execute(*args, res_typ=res_typ)\ndef wrapnpop(func):\n    def wrapper(*args):\n        a = [str(\"'\"+arg) if arg is SymbolAtom else str(arg) for arg in args]\n        res = func(*a)",
        "detail": "examples.python_compat.extend.mettamorph",
        "documentation": {}
    },
    {
        "label": "wrapnpop",
        "kind": 2,
        "importPath": "examples.python_compat.extend.mettamorph",
        "description": "examples.python_compat.extend.mettamorph",
        "peekOfCode": "def wrapnpop(func):\n    def wrapper(*args):\n        a = [str(\"'\"+arg) if arg is SymbolAtom else str(arg) for arg in args]\n        res = func(*a)\n        return [res]\n    return wrapper\ndef func_mettamorph(evalstr):\n    bytes_literal = evalstr.encode('utf-8')\n    input_str = c_char_p(bytes_literal)\n    result = mettamorphlib.mettamorph(input_str)",
        "detail": "examples.python_compat.extend.mettamorph",
        "documentation": {}
    },
    {
        "label": "func_mettamorph",
        "kind": 2,
        "importPath": "examples.python_compat.extend.mettamorph",
        "description": "examples.python_compat.extend.mettamorph",
        "peekOfCode": "def func_mettamorph(evalstr):\n    bytes_literal = evalstr.encode('utf-8')\n    input_str = c_char_p(bytes_literal)\n    result = mettamorphlib.mettamorph(input_str)\n    result_str = ctypes.string_at(result).decode('utf-8')\n    return result_str\ndef quoteSymbol(index, x):\n    if index == 0: #first is function symbol\n        return x\n    if x[0] != \"$\" and not x.replace(\"-\",\"\").replace(\".\",\"\").isnumeric() and x!=\"#f\" and x!=\"#t\":",
        "detail": "examples.python_compat.extend.mettamorph",
        "documentation": {}
    },
    {
        "label": "quoteSymbol",
        "kind": 2,
        "importPath": "examples.python_compat.extend.mettamorph",
        "description": "examples.python_compat.extend.mettamorph",
        "peekOfCode": "def quoteSymbol(index, x):\n    if index == 0: #first is function symbol\n        return x\n    if x[0] != \"$\" and not x.replace(\"-\",\"\").replace(\".\",\"\").isnumeric() and x!=\"#f\" and x!=\"#t\":\n        return (\"'\" + x).replace(\"(\",\"(list \").replace(\" \", \" '\")\n    return x\ndef call_mettamorph(*a):\n    tokenizer = globalmetta.tokenizer()\n    EXPRESSION = \"(\" + (\" \".join([quoteSymbol(i, str(x)).replace(\"'(\",\"(\") for i,x in enumerate(a)])) + \")\"\n    parser = SExprParser(\"(superpose \" + str(func_mettamorph(EXPRESSION) + \")\"))",
        "detail": "examples.python_compat.extend.mettamorph",
        "documentation": {}
    },
    {
        "label": "call_mettamorph",
        "kind": 2,
        "importPath": "examples.python_compat.extend.mettamorph",
        "description": "examples.python_compat.extend.mettamorph",
        "peekOfCode": "def call_mettamorph(*a):\n    tokenizer = globalmetta.tokenizer()\n    EXPRESSION = \"(\" + (\" \".join([quoteSymbol(i, str(x)).replace(\"'(\",\"(\") for i,x in enumerate(a)])) + \")\"\n    parser = SExprParser(\"(superpose \" + str(func_mettamorph(EXPRESSION) + \")\"))\n    return parser.parse(tokenizer)\nwrapperfunctions = set([])\ndef inject_calltypewrapper(content):\n    global wrapperfunctions\n    wrappers = \"\"\n    for line in content.split(\"\\n\"):",
        "detail": "examples.python_compat.extend.mettamorph",
        "documentation": {}
    },
    {
        "label": "inject_calltypewrapper",
        "kind": 2,
        "importPath": "examples.python_compat.extend.mettamorph",
        "description": "examples.python_compat.extend.mettamorph",
        "peekOfCode": "def inject_calltypewrapper(content):\n    global wrapperfunctions\n    wrappers = \"\"\n    for line in content.split(\"\\n\"):\n        if line.startswith(\"(= (\"):\n            argstr = line.split(\"(= (\")[1]\n            name = argstr.split(\" \")[0]\n            i = 0\n            args = \"(\"\n            counter = 1",
        "detail": "examples.python_compat.extend.mettamorph",
        "documentation": {}
    },
    {
        "label": "call_compilefile",
        "kind": 2,
        "importPath": "examples.python_compat.extend.mettamorph",
        "description": "examples.python_compat.extend.mettamorph",
        "peekOfCode": "def call_compilefile(*a):\n    global mettamorphlib, globalmetta, compiled\n    if compiled:\n        return E(S(\"Compilation:\"), S(\"unsupported\"))\n    compiled = True\n    loadfiletoken = str(a[0]).replace(\") (=\", \")\\n(=\").replace(\") (:\", \")\\n(:\")\n    loadfile = loadfiletoken[1:-1] if loadfiletoken.startswith('\"') or loadfiletoken.startswith('(') else loadfiletoken\n    if not loadfile.endswith(\".metta\"):\n        content = loadfile\n        loadfile = \"TEMP.metta\"",
        "detail": "examples.python_compat.extend.mettamorph",
        "documentation": {}
    },
    {
        "label": "scheme_atoms",
        "kind": 2,
        "importPath": "examples.python_compat.extend.mettamorph",
        "description": "examples.python_compat.extend.mettamorph",
        "peekOfCode": "def scheme_atoms(metta):\n    global globalmetta\n    globalmetta = metta\n    with open(\"../mettamorph.metta\") as file:\n        metta.run(file.read()) #as \"!(import ../mettamorph.metta)\" doesn't work here\n    call_mettamorph_atom = G(PatternOperation('mettamorph', wrapnpop(call_mettamorph), unwrap=False))\n    call_compilefile_atom = G(PatternOperation('compile!', wrapnpop(call_compilefile), unwrap=False))\n    return { r\"compile!\": call_compilefile_atom, r\"mettamorph\": call_mettamorph_atom }",
        "detail": "examples.python_compat.extend.mettamorph",
        "documentation": {}
    },
    {
        "label": "wrapperfunctions",
        "kind": 5,
        "importPath": "examples.python_compat.extend.mettamorph",
        "description": "examples.python_compat.extend.mettamorph",
        "peekOfCode": "wrapperfunctions = set([])\ndef inject_calltypewrapper(content):\n    global wrapperfunctions\n    wrappers = \"\"\n    for line in content.split(\"\\n\"):\n        if line.startswith(\"(= (\"):\n            argstr = line.split(\"(= (\")[1]\n            name = argstr.split(\" \")[0]\n            i = 0\n            args = \"(\"",
        "detail": "examples.python_compat.extend.mettamorph",
        "documentation": {}
    },
    {
        "label": "compiled",
        "kind": 5,
        "importPath": "examples.python_compat.extend.mettamorph",
        "description": "examples.python_compat.extend.mettamorph",
        "peekOfCode": "compiled = False\ndef call_compilefile(*a):\n    global mettamorphlib, globalmetta, compiled\n    if compiled:\n        return E(S(\"Compilation:\"), S(\"unsupported\"))\n    compiled = True\n    loadfiletoken = str(a[0]).replace(\") (=\", \")\\n(=\").replace(\") (:\", \")\\n(:\")\n    loadfile = loadfiletoken[1:-1] if loadfiletoken.startswith('\"') or loadfiletoken.startswith('(') else loadfiletoken\n    if not loadfile.endswith(\".metta\"):\n        content = loadfile",
        "detail": "examples.python_compat.extend.mettamorph",
        "documentation": {}
    },
    {
        "label": "globalmetta",
        "kind": 5,
        "importPath": "examples.python_compat.extend.mettamorph",
        "description": "examples.python_compat.extend.mettamorph",
        "peekOfCode": "globalmetta = None\n@register_atoms(pass_metta=True)\ndef scheme_atoms(metta):\n    global globalmetta\n    globalmetta = metta\n    with open(\"../mettamorph.metta\") as file:\n        metta.run(file.read()) #as \"!(import ../mettamorph.metta)\" doesn't work here\n    call_mettamorph_atom = G(PatternOperation('mettamorph', wrapnpop(call_mettamorph), unwrap=False))\n    call_compilefile_atom = G(PatternOperation('compile!', wrapnpop(call_compilefile), unwrap=False))\n    return { r\"compile!\": call_compilefile_atom, r\"mettamorph\": call_mettamorph_atom }",
        "detail": "examples.python_compat.extend.mettamorph",
        "documentation": {}
    },
    {
        "label": "SORT_LINES",
        "kind": 2,
        "importPath": "examples.python_compat.extend.test",
        "description": "examples.python_compat.extend.test",
        "peekOfCode": "def SORT_LINES(name):\n    lines = \"\"\n    for line in name.split(\"\\n\"):\n        try:\n            my_list = ast.literal_eval(list_as_string)\n            my_list.sort()\n            lines += str(my_list) + \"\\n\"\n        except:\n            lines += line + \"\\n\"\n#5. Compare the postprocessed outputs, reporting failure on mismatch",
        "detail": "examples.python_compat.extend.test",
        "documentation": {}
    },
    {
        "label": "basefile",
        "kind": 5,
        "importPath": "examples.python_compat.extend.test",
        "description": "examples.python_compat.extend.test",
        "peekOfCode": "basefile = \"\"\nfilename = sys.argv[1]\nif filename.split(\"/\")[-1][0].isupper() or \"compileme.metta\" in filename: #temp files are skipped\n    exit(0)\nwith open(filename) as file:\n    basefile = file.read()\nprint(\"Testing:\", sys.argv[1])\n#2. For compilation-omitted code, replace includes with included code and omit compilation instructions\nnewfile = \"\"\nfor line in basefile.split(\"\\n\"):",
        "detail": "examples.python_compat.extend.test",
        "documentation": {}
    },
    {
        "label": "filename",
        "kind": 5,
        "importPath": "examples.python_compat.extend.test",
        "description": "examples.python_compat.extend.test",
        "peekOfCode": "filename = sys.argv[1]\nif filename.split(\"/\")[-1][0].isupper() or \"compileme.metta\" in filename: #temp files are skipped\n    exit(0)\nwith open(filename) as file:\n    basefile = file.read()\nprint(\"Testing:\", sys.argv[1])\n#2. For compilation-omitted code, replace includes with included code and omit compilation instructions\nnewfile = \"\"\nfor line in basefile.split(\"\\n\"):\n    if not line.startswith('\")') and not line.startswith(\"))\") and \\",
        "detail": "examples.python_compat.extend.test",
        "documentation": {}
    },
    {
        "label": "newfile",
        "kind": 5,
        "importPath": "examples.python_compat.extend.test",
        "description": "examples.python_compat.extend.test",
        "peekOfCode": "newfile = \"\"\nfor line in basefile.split(\"\\n\"):\n    if not line.startswith('\")') and not line.startswith(\"))\") and \\\n       not line.startswith(\"!(compile! \") and not line.startswith(\"!(extend-py mettamorph)\"):\n           newfile += line + \"\\n\"\n    if \"!(compile! \" in line and \".metta)\" in line:\n        includefile = \"./extend/\" + line.split(\"!(compile! \")[1].split(\")\")[0]\n        with open(includefile) as file:\n            newfile += file.read() + \"\\n\"\nwith open(\"TEST.metta\",\"w\") as file:",
        "detail": "examples.python_compat.extend.test",
        "documentation": {}
    },
    {
        "label": "OUTPUT_IS",
        "kind": 5,
        "importPath": "examples.python_compat.extend.test",
        "description": "examples.python_compat.extend.test",
        "peekOfCode": "OUTPUT_IS = SORT_LINES(OUTPUT_IS)\nOUTPUT_SHOULD = SORT_LINES(OUTPUT_SHOULD)\nif OUTPUT_IS != OUTPUT_SHOULD:\n    print(\"FAILED:\", filename)",
        "detail": "examples.python_compat.extend.test",
        "documentation": {}
    },
    {
        "label": "OUTPUT_SHOULD",
        "kind": 5,
        "importPath": "examples.python_compat.extend.test",
        "description": "examples.python_compat.extend.test",
        "peekOfCode": "OUTPUT_SHOULD = SORT_LINES(OUTPUT_SHOULD)\nif OUTPUT_IS != OUTPUT_SHOULD:\n    print(\"FAILED:\", filename)",
        "detail": "examples.python_compat.extend.test",
        "documentation": {}
    },
    {
        "label": "DASpace",
        "kind": 6,
        "importPath": "examples.python_compat.hyperon-experimental_python.sandbox.das_gate.dasgate",
        "description": "examples.python_compat.hyperon-experimental_python.sandbox.das_gate.dasgate",
        "peekOfCode": "class DASpace(AbstractSpace):\n    def __init__(self, unwrap=True):\n        super().__init__()\n        self.das = DistributedAtomSpace('ram_only')\n        self.unwrap = unwrap\n    def _atom2dict(self, atom):\n        if isinstance(atom, ExpressionAtom):\n            return {\n                \"type\": \"Expression\",\n                \"targets\": [self._atom2dict(ch) for ch in atom.get_children()]",
        "detail": "examples.python_compat.hyperon-experimental_python.sandbox.das_gate.dasgate",
        "documentation": {}
    },
    {
        "label": "das_atoms",
        "kind": 2,
        "importPath": "examples.python_compat.hyperon-experimental_python.sandbox.das_gate.dasgate",
        "description": "examples.python_compat.hyperon-experimental_python.sandbox.das_gate.dasgate",
        "peekOfCode": "def das_atoms(metta):\n    newDASpaceAtom = OperationAtom('new-das', lambda: [G(SpaceRef(DASpace()))], unwrap=False)\n    return {\n        r\"new-das\": newDASpaceAtom,\n    }",
        "detail": "examples.python_compat.hyperon-experimental_python.sandbox.das_gate.dasgate",
        "documentation": {}
    },
    {
        "label": "to_nested_expr",
        "kind": 2,
        "importPath": "examples.python_compat.hyperon-experimental_python.sandbox.neurospace.llm_gate",
        "description": "examples.python_compat.hyperon-experimental_python.sandbox.neurospace.llm_gate",
        "peekOfCode": "def to_nested_expr(xs):\n    if isinstance(xs, list):\n        return E(*list(map(to_nested_expr, xs)))\n    return ValueAtom(xs)\ndef get_message_list(msg_atoms):\n    '''\n    Convert atoms to ChatGPT messages and flatten a possibly nested message list\n    '''\n    messages = []\n    for msg in msg_atoms:",
        "detail": "examples.python_compat.hyperon-experimental_python.sandbox.neurospace.llm_gate",
        "documentation": {}
    },
    {
        "label": "get_message_list",
        "kind": 2,
        "importPath": "examples.python_compat.hyperon-experimental_python.sandbox.neurospace.llm_gate",
        "description": "examples.python_compat.hyperon-experimental_python.sandbox.neurospace.llm_gate",
        "peekOfCode": "def get_message_list(msg_atoms):\n    '''\n    Convert atoms to ChatGPT messages and flatten a possibly nested message list\n    '''\n    messages = []\n    for msg in msg_atoms:\n        if isinstance(msg, ExpressionAtom):\n            ch = msg.get_children()\n            if len(ch) == 0:\n                continue",
        "detail": "examples.python_compat.hyperon-experimental_python.sandbox.neurospace.llm_gate",
        "documentation": {}
    },
    {
        "label": "llm",
        "kind": 2,
        "importPath": "examples.python_compat.hyperon-experimental_python.sandbox.neurospace.llm_gate",
        "description": "examples.python_compat.hyperon-experimental_python.sandbox.neurospace.llm_gate",
        "peekOfCode": "def llm(metta: MeTTa, *args):\n    messages = []\n    functions = []\n    msgs = None\n    for arg in args:\n        if isinstance(arg, ExpressionAtom):\n            ch = arg.get_children()\n            if len(ch) > 1 and ch[0].get_name() == 'Messages':\n                msgs = arg\n                messages += get_message_list(ch[1:])",
        "detail": "examples.python_compat.hyperon-experimental_python.sandbox.neurospace.llm_gate",
        "documentation": {}
    },
    {
        "label": "llmgate_atoms",
        "kind": 2,
        "importPath": "examples.python_compat.hyperon-experimental_python.sandbox.neurospace.llm_gate",
        "description": "examples.python_compat.hyperon-experimental_python.sandbox.neurospace.llm_gate",
        "peekOfCode": "def llmgate_atoms(metta):\n    llmAtom = OperationAtom('llm', lambda *args: llm(metta, *args), unwrap=False)\n    return {\n        r\"llm\": llmAtom\n    }",
        "detail": "examples.python_compat.hyperon-experimental_python.sandbox.neurospace.llm_gate",
        "documentation": {}
    },
    {
        "label": "openai.api_key",
        "kind": 5,
        "importPath": "examples.python_compat.hyperon-experimental_python.sandbox.neurospace.llm_gate",
        "description": "examples.python_compat.hyperon-experimental_python.sandbox.neurospace.llm_gate",
        "peekOfCode": "openai.api_key = os.environ[\"OPENAI_API_KEY\"]\ndef to_nested_expr(xs):\n    if isinstance(xs, list):\n        return E(*list(map(to_nested_expr, xs)))\n    return ValueAtom(xs)\ndef get_message_list(msg_atoms):\n    '''\n    Convert atoms to ChatGPT messages and flatten a possibly nested message list\n    '''\n    messages = []",
        "detail": "examples.python_compat.hyperon-experimental_python.sandbox.neurospace.llm_gate",
        "documentation": {}
    },
    {
        "label": "NeuralSpace",
        "kind": 6,
        "importPath": "examples.python_compat.hyperon-experimental_python.sandbox.neurospace.neurospace",
        "description": "examples.python_compat.hyperon-experimental_python.sandbox.neurospace.neurospace",
        "peekOfCode": "class NeuralSpace(GroundingSpace):\n    def query(self, query_atom):\n        tot_str = \"Answer the question taking into account the following information (each fact is in brackets):\\n\"\n        for atom in self.atoms_iter():\n            tot_str += str(atom) + \"\\n\"\n        tot_str += \"If the question contains letters in brackets with $ sign, for example ($x), provide the answer in the json format in curly brackets, that is { $x: your answer }.\\n\"\n        # tot_str += \"If information is not provided, return the entry to be queried in JSON {unknown value: UNKNOWN}.\"\n        tot_str += \"The question is: \" + str(query_atom)[1:-1] + \"?\"\n        response = openai.ChatCompletion.create(\n                model=\"gpt-3.5-turbo-0613\",",
        "detail": "examples.python_compat.hyperon-experimental_python.sandbox.neurospace.neurospace",
        "documentation": {}
    },
    {
        "label": "IntentSpace",
        "kind": 6,
        "importPath": "examples.python_compat.hyperon-experimental_python.sandbox.neurospace.neurospace",
        "description": "examples.python_compat.hyperon-experimental_python.sandbox.neurospace.neurospace",
        "peekOfCode": "class IntentSpace(GroundingSpace):\n    def query(self, query_atom):\n        tot_str = \"Analyze the topic of the utterance: \" + str(query_atom)[1:-1] + \"\\n\"\n        tot_str += \"Try to pick the most relevant topic from the following list (each topic in brackets):\"\n        for atom in self.atoms_iter():\n            tot_str += str(atom) + \"\\n\"\n        tot_str += \"If neither of the listed topics seems relevant, answer (chit-chat).\"\n        tot_str += \"Provide the answer in the json format in curly brackets in the form { topic: your answer }.\\n\"\n        response = openai.ChatCompletion.create(\n                model=\"gpt-3.5-turbo-0613\",",
        "detail": "examples.python_compat.hyperon-experimental_python.sandbox.neurospace.neurospace",
        "documentation": {}
    },
    {
        "label": "neuralspace_atoms",
        "kind": 2,
        "importPath": "examples.python_compat.hyperon-experimental_python.sandbox.neurospace.neurospace",
        "description": "examples.python_compat.hyperon-experimental_python.sandbox.neurospace.neurospace",
        "peekOfCode": "def neuralspace_atoms():\n    newNSpaceAtom = OperationAtom('new-neural-space', lambda: [G(SpaceRef(NeuralSpace()))], unwrap=False)\n    newISpaceAtom = OperationAtom('new-intent-space', lambda: [G(SpaceRef(IntentSpace()))], unwrap=False)\n    return {\n        r\"new-neural-space\": newNSpaceAtom,\n        r\"new-intent-space\": newISpaceAtom,\n    }",
        "detail": "examples.python_compat.hyperon-experimental_python.sandbox.neurospace.neurospace",
        "documentation": {}
    },
    {
        "label": "openai.api_key",
        "kind": 5,
        "importPath": "examples.python_compat.hyperon-experimental_python.sandbox.neurospace.neurospace",
        "description": "examples.python_compat.hyperon-experimental_python.sandbox.neurospace.neurospace",
        "peekOfCode": "openai.api_key = os.environ[\"OPENAI_API_KEY\"]\ndef _response2bindings(txt):\n        res = re.findall(r'\\{.*?\\}', txt)\n        new_bindings_set = BindingsSet.empty()\n        if res == []:\n            return new_bindings_set\n        res = res[0][1:-1]\n        _var, val = res.split(':')\n        var = re.findall(r'\\\".*?\\\"', _var)\n        var = var[0][1:-1] if len(var) > 0 else _var.replace(\" \", \"\")",
        "detail": "examples.python_compat.hyperon-experimental_python.sandbox.neurospace.neurospace",
        "documentation": {}
    },
    {
        "label": "NumpyValue",
        "kind": 6,
        "importPath": "examples.python_compat.hyperon-experimental_python.sandbox.numpy.numme",
        "description": "examples.python_compat.hyperon-experimental_python.sandbox.numpy.numme",
        "peekOfCode": "class NumpyValue(MatchableObject):\n    def __eq__(self, other):\n        return isinstance(other, NumpyValue) and\\\n               (self.content.shape == other.content.shape) and\\\n               (self.content == other.content).all()\n    def match_(self, other):\n        sh = self.content.shape\n        bindings = {}\n        if isinstance(other, GroundedAtom):\n            other = other.get_object()",
        "detail": "examples.python_compat.hyperon-experimental_python.sandbox.numpy.numme",
        "documentation": {}
    },
    {
        "label": "PatternValue",
        "kind": 6,
        "importPath": "examples.python_compat.hyperon-experimental_python.sandbox.numpy.numme",
        "description": "examples.python_compat.hyperon-experimental_python.sandbox.numpy.numme",
        "peekOfCode": "class PatternValue(MatchableObject):\n    def match_(self, other):\n        if isinstance(other, GroundedAtom):\n            other = other.get_object().content\n        if not isinstance(other, PatternValue):\n            return other.match_(self)\n        # TODO: match to patterns\n        return []\nclass PatternOperation(OperationObject):\n    def __init__(self, name, op, unwrap=False, rec=False):",
        "detail": "examples.python_compat.hyperon-experimental_python.sandbox.numpy.numme",
        "documentation": {}
    },
    {
        "label": "PatternOperation",
        "kind": 6,
        "importPath": "examples.python_compat.hyperon-experimental_python.sandbox.numpy.numme",
        "description": "examples.python_compat.hyperon-experimental_python.sandbox.numpy.numme",
        "peekOfCode": "class PatternOperation(OperationObject):\n    def __init__(self, name, op, unwrap=False, rec=False):\n        super().__init__(name, op, unwrap)\n        self.rec = rec\n    def execute(self, *args, res_typ=AtomType.UNDEFINED):\n        if self.rec:\n            args = args[0].get_children()\n            args = [self.execute(arg)[0]\\\n                if isinstance(arg, ExpressionAtom) else arg for arg in args]\n        # If there is a variable or PatternValue in arguments, create PatternValue",
        "detail": "examples.python_compat.hyperon-experimental_python.sandbox.numpy.numme",
        "documentation": {}
    },
    {
        "label": "wrapnpop",
        "kind": 2,
        "importPath": "examples.python_compat.hyperon-experimental_python.sandbox.numpy.numme",
        "description": "examples.python_compat.hyperon-experimental_python.sandbox.numpy.numme",
        "peekOfCode": "def wrapnpop(func):\n    def wrapper(*args):\n        a = [arg.get_object().value for arg in args]\n        res = func(*a)\n        typ = _np_atom_type(res)\n        return [G(NumpyValue(res), typ)]\n    return wrapper\n@register_atoms\ndef numme_atoms():\n    # FIXME: we don't add types for operations, because numpy operations types",
        "detail": "examples.python_compat.hyperon-experimental_python.sandbox.numpy.numme",
        "documentation": {}
    },
    {
        "label": "numme_atoms",
        "kind": 2,
        "importPath": "examples.python_compat.hyperon-experimental_python.sandbox.numpy.numme",
        "description": "examples.python_compat.hyperon-experimental_python.sandbox.numpy.numme",
        "peekOfCode": "def numme_atoms():\n    # FIXME: we don't add types for operations, because numpy operations types\n    # are too loose\n    nmVectorAtom = G(PatternOperation('np.vector', wrapnpop(lambda *args: np.array(args)), unwrap=False))\n    nmArrayAtom = G(PatternOperation('np.array', wrapnpop(lambda *args: np.array(args)), unwrap=False, rec=True))\n    nmAddAtom = G(PatternOperation('np.add', wrapnpop(np.add), unwrap=False))\n    nmSubAtom = G(PatternOperation('np.sub', wrapnpop(np.subtract), unwrap=False))\n    nmMulAtom = G(PatternOperation('np.mul', wrapnpop(np.multiply), unwrap=False))\n    nmDivAtom = G(PatternOperation('np.div', wrapnpop(np.divide), unwrap=False))\n    nmMMulAtom = G(PatternOperation('np.matmul', wrapnpop(np.matmul), unwrap=False))",
        "detail": "examples.python_compat.hyperon-experimental_python.sandbox.numpy.numme",
        "documentation": {}
    },
    {
        "label": "MeTTaC",
        "kind": 6,
        "importPath": "examples.python_compat.hyperon-experimental_python.sandbox.resolve.r",
        "description": "examples.python_compat.hyperon-experimental_python.sandbox.resolve.r",
        "peekOfCode": "class MeTTaC(MeTTa):\n    def copy(self):\n        return self\n@register_atoms\ndef my_imported_runner_atom():\n    # We don't use metta here, but we could...\n    content = '''\n        (: fact (-> Number Number))\n        (= (fact $x)\n           (case $x",
        "detail": "examples.python_compat.hyperon-experimental_python.sandbox.resolve.r",
        "documentation": {}
    },
    {
        "label": "my_imported_runner_atom",
        "kind": 2,
        "importPath": "examples.python_compat.hyperon-experimental_python.sandbox.resolve.r",
        "description": "examples.python_compat.hyperon-experimental_python.sandbox.resolve.r",
        "peekOfCode": "def my_imported_runner_atom():\n    # We don't use metta here, but we could...\n    content = '''\n        (: fact (-> Number Number))\n        (= (fact $x)\n           (case $x\n            ((0 1)\n             ($_ (* $x (fact (- $x 1)))))\n           )\n        )",
        "detail": "examples.python_compat.hyperon-experimental_python.sandbox.resolve.r",
        "documentation": {}
    },
    {
        "label": "my_resolver_atoms",
        "kind": 2,
        "importPath": "examples.python_compat.hyperon-experimental_python.sandbox.resolve.resolve",
        "description": "examples.python_compat.hyperon-experimental_python.sandbox.resolve.resolve",
        "peekOfCode": "def my_resolver_atoms(metta):\n    def run_resolved_symbol_op(runner, atom, *args):\n        expr = E(atom, *args)\n        result = hp.metta_evaluate_atom(runner.cmetta, expr.catom)\n        result = [Atom._from_catom(catom) for catom in result]\n        return result\n    def resolve_atom(metta, token):\n        # TODO: nested modules...\n        runner_name, atom_name = token.split('::')\n        # FIXME: using `run` for this is an overkill,",
        "detail": "examples.python_compat.hyperon-experimental_python.sandbox.resolve.resolve",
        "documentation": {}
    },
    {
        "label": "SqlHelper",
        "kind": 6,
        "importPath": "examples.python_compat.hyperon-experimental_python.sandbox.sql_space.sql_space",
        "description": "examples.python_compat.hyperon-experimental_python.sandbox.sql_space.sql_space",
        "peekOfCode": "class SqlHelper:\n    colums_word = \"ColumnNames\"\n    insert_command_sql = \"INSERT INTO\"\n    @staticmethod\n    def get_query_atoms(query_atom):\n        children = query_atom.get_children()\n        new_query_atoms = []\n        for ch in children:\n            if 'limit' not in repr(ch).lower():\n                new_query_atoms.append(ch)",
        "detail": "examples.python_compat.hyperon-experimental_python.sandbox.sql_space.sql_space",
        "documentation": {}
    },
    {
        "label": "SqlSpace",
        "kind": 6,
        "importPath": "examples.python_compat.hyperon-experimental_python.sandbox.sql_space.sql_space",
        "description": "examples.python_compat.hyperon-experimental_python.sandbox.sql_space.sql_space",
        "peekOfCode": "class SqlSpace(GroundingSpace):\n    def __init__(self, database, host, user, password, port):\n        super().__init__()\n        self.conn = psycopg2.connect(database=database,\n                                     host=host,\n                                     user=user,\n                                     password=password,\n                                     port=port)\n        self.cursor = self.conn.cursor()\n    def from_space(self, cspace):",
        "detail": "examples.python_compat.hyperon-experimental_python.sandbox.sql_space.sql_space",
        "documentation": {}
    },
    {
        "label": "results2bindings",
        "kind": 2,
        "importPath": "examples.python_compat.hyperon-experimental_python.sandbox.sql_space.sql_space",
        "description": "examples.python_compat.hyperon-experimental_python.sandbox.sql_space.sql_space",
        "peekOfCode": "def results2bindings(vars, values):\n    new_bindings_set = BindingsSet.empty()\n    if len(values) == 0 or len(vars) != len(values[0]):\n        return new_bindings_set\n    for value in values:\n        bindings = Bindings()\n        for i in range(len(vars)):\n            bindings.add_var_binding(vars[i], ValueAtom(str(value[i])))\n        new_bindings_set.push(bindings)\n    return new_bindings_set",
        "detail": "examples.python_compat.hyperon-experimental_python.sandbox.sql_space.sql_space",
        "documentation": {}
    },
    {
        "label": "wrapsqlop",
        "kind": 2,
        "importPath": "examples.python_compat.hyperon-experimental_python.sandbox.sql_space.sql_space",
        "description": "examples.python_compat.hyperon-experimental_python.sandbox.sql_space.sql_space",
        "peekOfCode": "def wrapsqlop(func):\n    def wrapper(*args):\n        if len(args) > 1:\n            if isinstance(args[0], GroundedAtom):\n                space1 = args[0].get_object()\n                if isinstance(space1, SpaceRef):\n                    if isinstance(args[1], GroundedAtom):\n                        space2 = args[1].get_object()\n                        if isinstance(space2, SpaceRef):\n                            args = args[2:]",
        "detail": "examples.python_compat.hyperon-experimental_python.sandbox.sql_space.sql_space",
        "documentation": {}
    },
    {
        "label": "sql_space_atoms",
        "kind": 2,
        "importPath": "examples.python_compat.hyperon-experimental_python.sandbox.sql_space.sql_space",
        "description": "examples.python_compat.hyperon-experimental_python.sandbox.sql_space.sql_space",
        "peekOfCode": "def sql_space_atoms():\n    helper = SqlHelper()\n    newSQLSpaceAtom = OperationAtom('new-sql-space', lambda database, host, user, password, port: [\n        G(SpaceRef(SqlSpace(database, host, user, password, port)))], unwrap=False)\n    saveQueryResult = G(OperationObject('sql.save-query-result', wrapsqlop(helper.save_query_result), unwrap=False))\n    sqlInsert = G(OperationObject('sql.insert', wrapsqlop(helper.insert), unwrap=False))\n    return {\n        r\"new-sql-space\": newSQLSpaceAtom,\n        r\"sql.save-query-result\": saveQueryResult,\n        r\"sql.insert\": sqlInsert",
        "detail": "examples.python_compat.hyperon-experimental_python.sandbox.sql_space.sql_space",
        "documentation": {}
    },
    {
        "label": "set_global",
        "kind": 2,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.extension",
        "description": "examples.python_compat.hyperon-experimental_python.tests.extension",
        "peekOfCode": "def set_global(v):\n    global g_object\n    g_object = v\n@register_atoms\ndef my_dict_atoms():\n    return {\n        '&my-dict': ValueAtom({'A': 5, 6: 'B'}),\n        'get-by-key': OperationAtom('get-by-key', lambda d, k: d[k])\n        }\n@register_atoms",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.extension",
        "documentation": {}
    },
    {
        "label": "my_dict_atoms",
        "kind": 2,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.extension",
        "description": "examples.python_compat.hyperon-experimental_python.tests.extension",
        "peekOfCode": "def my_dict_atoms():\n    return {\n        '&my-dict': ValueAtom({'A': 5, 6: 'B'}),\n        'get-by-key': OperationAtom('get-by-key', lambda d, k: d[k])\n        }\n@register_atoms\ndef my_glob_atoms():\n    return {\n        'set-global!': OperationAtom(\"set-global!\", set_global),\n        'get-global': OperationAtom(\"get-global\", lambda: g_object),",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.extension",
        "documentation": {}
    },
    {
        "label": "my_glob_atoms",
        "kind": 2,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.extension",
        "description": "examples.python_compat.hyperon-experimental_python.tests.extension",
        "peekOfCode": "def my_glob_atoms():\n    return {\n        'set-global!': OperationAtom(\"set-global!\", set_global),\n        'get-global': OperationAtom(\"get-global\", lambda: g_object),\n        }\n@register_tokens(pass_metta=True)\ndef my_get_runner(metta):\n    return {\n        '&runner': lambda _: ValueAtom(metta)\n    }",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.extension",
        "documentation": {}
    },
    {
        "label": "my_get_runner",
        "kind": 2,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.extension",
        "description": "examples.python_compat.hyperon-experimental_python.tests.extension",
        "peekOfCode": "def my_get_runner(metta):\n    return {\n        '&runner': lambda _: ValueAtom(metta)\n    }",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.extension",
        "documentation": {}
    },
    {
        "label": "g_object",
        "kind": 5,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.extension",
        "description": "examples.python_compat.hyperon-experimental_python.tests.extension",
        "peekOfCode": "g_object = None\ndef set_global(v):\n    global g_object\n    g_object = v\n@register_atoms\ndef my_dict_atoms():\n    return {\n        '&my-dict': ValueAtom({'A': 5, 6: 'B'}),\n        'get-by-key': OperationAtom('get-by-key', lambda d, k: d[k])\n        }",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.extension",
        "documentation": {}
    },
    {
        "label": "AtomTest",
        "kind": 6,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "peekOfCode": "class AtomTest(unittest.TestCase):\n    def test_symbol_equals(self):\n        self.assertEqual(S(\"a\"), S(\"a\"))\n        self.assertNotEqual(S(\"a\"), S(\"b\"))\n    def test_symbol_str(self):\n        self.assertEqual(str(S(\"a\")), \"a\")\n    def test_symbol_type(self):\n        self.assertEqual(S(\"a\").get_type(), AtomKind.SYMBOL)\n    def test_symbol_get_symbol(self):\n        self.assertEqual(S(\"a\").get_name(), \"a\")",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "documentation": {}
    },
    {
        "label": "GroundedNoCopy",
        "kind": 6,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "peekOfCode": "class GroundedNoCopy:\n    pass\nclass MatchableObjectTest(MatchableObject):\n    def match_(self, atom):\n        return [{'atom_type': S(atom.get_children()[0].get_type().name)}]\ndef MatchableAtomTest(value, type_name=None, atom_id=None):\n    return G(MatchableObjectTest(value, atom_id), AtomType.UNDEFINED)\nif __name__ == \"__main__\":\n    unittest.main()",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "documentation": {}
    },
    {
        "label": "MatchableObjectTest",
        "kind": 6,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "peekOfCode": "class MatchableObjectTest(MatchableObject):\n    def match_(self, atom):\n        return [{'atom_type': S(atom.get_children()[0].get_type().name)}]\ndef MatchableAtomTest(value, type_name=None, atom_id=None):\n    return G(MatchableObjectTest(value, atom_id), AtomType.UNDEFINED)\nif __name__ == \"__main__\":\n    unittest.main()",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "documentation": {}
    },
    {
        "label": "x2_op",
        "kind": 2,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "peekOfCode": "def x2_op(atom):\n    return [ValueAtom(2 * atom.get_object().value)]\nx2Atom = OperationAtom('*2', x2_op, type_names=[\"int\", \"int\"], unwrap=False)\ndef no_reduce_op(atom):\n    raise NoReduceError()\nnoReduceAtom = OperationAtom('no-reduce', no_reduce_op, unwrap=False)\nclass GroundedNoCopy:\n    pass\nclass MatchableObjectTest(MatchableObject):\n    def match_(self, atom):",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "documentation": {}
    },
    {
        "label": "no_reduce_op",
        "kind": 2,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "peekOfCode": "def no_reduce_op(atom):\n    raise NoReduceError()\nnoReduceAtom = OperationAtom('no-reduce', no_reduce_op, unwrap=False)\nclass GroundedNoCopy:\n    pass\nclass MatchableObjectTest(MatchableObject):\n    def match_(self, atom):\n        return [{'atom_type': S(atom.get_children()[0].get_type().name)}]\ndef MatchableAtomTest(value, type_name=None, atom_id=None):\n    return G(MatchableObjectTest(value, atom_id), AtomType.UNDEFINED)",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "documentation": {}
    },
    {
        "label": "MatchableAtomTest",
        "kind": 2,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "peekOfCode": "def MatchableAtomTest(value, type_name=None, atom_id=None):\n    return G(MatchableObjectTest(value, atom_id), AtomType.UNDEFINED)\nif __name__ == \"__main__\":\n    unittest.main()",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "documentation": {}
    },
    {
        "label": "x2Atom",
        "kind": 5,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "peekOfCode": "x2Atom = OperationAtom('*2', x2_op, type_names=[\"int\", \"int\"], unwrap=False)\ndef no_reduce_op(atom):\n    raise NoReduceError()\nnoReduceAtom = OperationAtom('no-reduce', no_reduce_op, unwrap=False)\nclass GroundedNoCopy:\n    pass\nclass MatchableObjectTest(MatchableObject):\n    def match_(self, atom):\n        return [{'atom_type': S(atom.get_children()[0].get_type().name)}]\ndef MatchableAtomTest(value, type_name=None, atom_id=None):",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "documentation": {}
    },
    {
        "label": "noReduceAtom",
        "kind": 5,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "peekOfCode": "noReduceAtom = OperationAtom('no-reduce', no_reduce_op, unwrap=False)\nclass GroundedNoCopy:\n    pass\nclass MatchableObjectTest(MatchableObject):\n    def match_(self, atom):\n        return [{'atom_type': S(atom.get_children()[0].get_type().name)}]\ndef MatchableAtomTest(value, type_name=None, atom_id=None):\n    return G(MatchableObjectTest(value, atom_id), AtomType.UNDEFINED)\nif __name__ == \"__main__\":\n    unittest.main()",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_atom",
        "documentation": {}
    },
    {
        "label": "AtomTest",
        "kind": 6,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_atom_type",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_atom_type",
        "peekOfCode": "class AtomTest(unittest.TestCase):\n    def test_check_type(self):\n        space = GroundingSpaceRef()\n        space.add_atom(E(S(\":\"), S(\"a\"), S(\"A\")))\n        self.assertTrue(check_type(space, S(\"a\"), AtomType.UNDEFINED))\n        self.assertTrue(check_type(space, S(\"a\"), S(\"A\")))\n        self.assertFalse(check_type(space, S(\"a\"), S(\"B\")))\n    def test_validate_atom(self):\n        space = GroundingSpaceRef()\n        space.add_atom(E(S(\":\"), S(\"a\"), S(\"A\")))",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_atom_type",
        "documentation": {}
    },
    {
        "label": "BindingsTest",
        "kind": 6,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_bindings",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_bindings",
        "peekOfCode": "class BindingsTest(unittest.TestCase):\n    def setUp(self):\n        self.emptyBindings = Bindings()\n        self.bindings = Bindings()\n        self.bindings.add_var_binding(\"a\", S(\"b\"))\n        self.bindings.add_var_binding(\"x\", S(\"y\"))\n    def tearDown(self) -> None:\n        pass\n    def test_bindings_match_display(self):\n        pass",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_bindings",
        "documentation": {}
    },
    {
        "label": "HyperonTestCase",
        "kind": 6,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_common",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_common",
        "peekOfCode": "class HyperonTestCase(unittest.TestCase):\n    def __init__(self, methodName):\n        super().__init__(methodName)\n    def assertEqualNoOrder(self, left, right):\n        self.assertTrue(areEqualNoOrder(left, right),\n            f\"Lists differ: {left} != {right}\")\n    def assertEqualMettaRunnerResults(self, left, right):\n        self.assertTrue(areEqualMettaRunResults(left, right),\n            f\"MeTTa results differ: {left} != {right}\")\n    def assertAtomsAreEquivalent(self, actual, expected):",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_common",
        "documentation": {}
    },
    {
        "label": "areEqualNoOrder",
        "kind": 2,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_common",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_common",
        "peekOfCode": "def areEqualNoOrder(a, b):\n    class FakeHash:\n        def __init__(self, o):\n            self.o = o\n        def __hash__(self):\n            return 0\n        def __eq__(self, other):\n            return self.o.__eq__(other.o)\n    mapa = dict()\n    mapb = dict()",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_common",
        "documentation": {}
    },
    {
        "label": "areEqualMettaRunResults",
        "kind": 2,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_common",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_common",
        "peekOfCode": "def areEqualMettaRunResults(a, b):\n    if len(a) != len(b):\n        return False\n    for (a, b) in zip(a, b):\n        if not areEqualNoOrder(a, b):\n            return False\n    return True\nclass HyperonTestCase(unittest.TestCase):\n    def __init__(self, methodName):\n        super().__init__(methodName)",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_common",
        "documentation": {}
    },
    {
        "label": "TestSpace",
        "kind": 6,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_custom_space",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_custom_space",
        "peekOfCode": "class TestSpace(AbstractSpace):\n    def __init__(self, unwrap=True):\n        super().__init__()\n        self.atoms_list = []\n        self.unwrap = unwrap\n    # NOTE: this is a naive implementation barely good enough to pass the tests\n    # Don't take this as a guide to implementing a space query function\n    def query(self, query_atom):\n        # Extract only the variables from the query atom\n        query_vars = list(filter(lambda atom: atom.get_type() == AtomKind.VARIABLE, query_atom.iterate()))",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_custom_space",
        "documentation": {}
    },
    {
        "label": "CustomSpaceTest",
        "kind": 6,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_custom_space",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_custom_space",
        "peekOfCode": "class CustomSpaceTest(HyperonTestCase):\n    def test_custom_space(self):\n        test_space = TestSpace()\n        test_space.test_attrib = \"Test Space Payload Attrib\"\n        kb = SpaceRef(test_space)\n        kb.add_atom(S(\"a\"))\n        kb.add_atom(S(\"b\"))\n        self.assertEqual(kb.atom_count(), 2)\n        self.assertEqual(kb.get_payload().test_attrib, \"Test Space Payload Attrib\")\n        self.assertEqualNoOrder(kb.get_atoms(), [S(\"a\"), S(\"b\")])",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_custom_space",
        "documentation": {}
    },
    {
        "label": "HyperonTestCase",
        "kind": 6,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_environment",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_environment",
        "peekOfCode": "class HyperonTestCase(unittest.TestCase):\n    def __init__(self, methodName):\n        super().__init__(methodName)\n    def testEnvironment(self):\n        self.assertTrue(Environment.init_common_env(config_dir = \"/tmp/test_dir\", create_config = True))\n        self.assertEqual(Environment.config_dir(), \"/tmp/test_dir\")\n        self.assertFalse(Environment.init_common_env(disable_config = True))",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_environment",
        "documentation": {}
    },
    {
        "label": "ExamplesTest",
        "kind": 6,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_examples",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_examples",
        "peekOfCode": "class ExamplesTest(HyperonTestCase):\n    def test_grounded_functions(self):\n        metta = MeTTa(env_builder=Environment.test_env())\n        obj = SomeObject()\n        # using & as a prefix is not obligatory, but is naming convention\n        metta.register_atom(\"&obj\", ValueAtom(obj))\n        target = metta.parse_single('(call:foo &obj)')\n        # interpreting this target in another space still works,\n        # because substitution '&obj' -> obj is done by metta\n        metta2 = MeTTa(env_builder=Environment.test_env())",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_examples",
        "documentation": {}
    },
    {
        "label": "SomeObject",
        "kind": 6,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_examples",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_examples",
        "peekOfCode": "class SomeObject():\n    def __init__(self):\n        self.called = False\n    def foo(self):\n        self.called = True\n# New object example\ndef new_atom_op(klass, unwrap, *params):\n    if unwrap:\n        unwrapped = [param.get_object().value for param in params]\n        return [ValueAtom(klass(*unwrapped))]",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_examples",
        "documentation": {}
    },
    {
        "label": "Global",
        "kind": 6,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_examples",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_examples",
        "peekOfCode": "class Global:\n    def __init__(self, x):\n        self.set(x)\n    def set(self, x):\n        self.x = x\n    def get(self):\n        return self.x\nclass Setter:\n    def __init__(self, var, val):\n        self.var = var",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_examples",
        "documentation": {}
    },
    {
        "label": "Setter",
        "kind": 6,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_examples",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_examples",
        "peekOfCode": "class Setter:\n    def __init__(self, var, val):\n        self.var = var\n        self.val = val\n    def act(self):\n        self.var.set(self.val)\n    def let(self):\n        self.var = self.val\n    def latom(self):\n        # if var/val are not unwrapped",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_examples",
        "documentation": {}
    },
    {
        "label": "new_atom_op",
        "kind": 2,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_examples",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_examples",
        "peekOfCode": "def new_atom_op(klass, unwrap, *params):\n    if unwrap:\n        unwrapped = [param.get_object().value for param in params]\n        return [ValueAtom(klass(*unwrapped))]\n    else:\n        return [ValueAtom(klass(*params))]\ndef newNewAtom(token, klass, unwrap=True):\n    return OperationAtom(\n        token,\n        lambda *params: new_atom_op(klass, unwrap, *params),",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_examples",
        "documentation": {}
    },
    {
        "label": "newNewAtom",
        "kind": 2,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_examples",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_examples",
        "peekOfCode": "def newNewAtom(token, klass, unwrap=True):\n    return OperationAtom(\n        token,\n        lambda *params: new_atom_op(klass, unwrap, *params),\n        unwrap=False)\nclass Global:\n    def __init__(self, x):\n        self.set(x)\n    def set(self, x):\n        self.x = x",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_examples",
        "documentation": {}
    },
    {
        "label": "ExtendTest",
        "kind": 6,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_extend",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_extend",
        "peekOfCode": "class ExtendTest(unittest.TestCase):\n    def test_extend(self):\n        '''\n        This test verifies that extend-py! along with @register_atoms and @register_tokens works\n        '''\n        metta = MeTTa(env_builder=Environment.test_env())\n        self.assertEqual(\n            metta.run('''\n              !(extend-py! extension)\n              !(get-by-key &my-dict \"A\")",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_extend",
        "documentation": {}
    },
    {
        "label": "ExtendGlobalTest",
        "kind": 6,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_extend",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_extend",
        "peekOfCode": "class ExtendGlobalTest(unittest.TestCase):\n    def test_extend_global(self):\n        '''\n        This test is intended to check that if the extension uses internal states,\n        they are not lost between metta.run's and are also accessible from Python\n        '''\n        from extension import g_object\n        # Sanity check\n        self.assertEqual(g_object, None)\n        metta = MeTTa(env_builder=Environment.test_env())",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_extend",
        "documentation": {}
    },
    {
        "label": "GroundedTypeTest",
        "kind": 6,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_grounded_type",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_grounded_type",
        "peekOfCode": "class GroundedTypeTest(unittest.TestCase):\n    def test_apply_type(self):\n        metta = MeTTa(env_builder=Environment.test_env())\n        self.assertEqual(\n            metta.parse_single(\"+\").get_grounded_type(),\n            metta.parse_single(\"*\").get_grounded_type())\n        self.assertEqual(\n            metta.run(\"!(+ (* 1 4) 2)\")[0][0].get_grounded_type(),\n            metta.parse_single(\"0\").get_grounded_type())\n        self.assertEqual(",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_grounded_type",
        "documentation": {}
    },
    {
        "label": "GroundingSpaceTest",
        "kind": 6,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_grounding_space",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_grounding_space",
        "peekOfCode": "class GroundingSpaceTest(HyperonTestCase):\n    def test_add(self):\n        kb = GroundingSpaceRef()\n        kb.add_atom(S(\"a\"))\n        kb.add_atom(S(\"b\"))\n        self.assertEqualNoOrder(kb.get_atoms(), [S(\"a\"), S(\"b\")])\n    def test_remove(self):\n        kb = GroundingSpaceRef()\n        kb.add_atom(S(\"a\"))\n        kb.add_atom(S(\"b\"))",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_grounding_space",
        "documentation": {}
    },
    {
        "label": "MettaTest",
        "kind": 6,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_metta",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_metta",
        "peekOfCode": "class MettaTest(unittest.TestCase):\n    def test_adding_tokens_while_parsing(self):\n        metta = MeTTa(env_builder=Environment.test_env())\n        atom = metta.parse_single('(A B)')\n        self.assertEqual(atom, E(S('A'), S('B')))\n        metta.register_atom('A', S('C'))\n        atom = metta.parse_single('(A B)')\n        self.assertEqual(atom, E(S('C'), S('B')))\n        metta.register_atom('A', S('F'))\n        atom = metta.parse_single('(A B)')",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_metta",
        "documentation": {}
    },
    {
        "label": "MinecraftTest",
        "kind": 6,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_minecraft",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_minecraft",
        "peekOfCode": "class MinecraftTest(unittest.TestCase):\n    def test_minecraft_planning(self):\n        metta = MeTTa(env_builder=Environment.test_env())\n        inventory = [S('inventory'), S('hands')]\n        metta.register_token(\"in-inventory\", lambda _: newInInventory(inventory))\n        metta.register_token(\"craft\", lambda _: newCraftOp(inventory))\n        metta.register_token(\"mine\", lambda _: newMineOp(inventory))\n        metta.run('''\n            (= (wood) (spruce-wood))\n            (= (spruce-wood) (mine spruce-tree hand))",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_minecraft",
        "documentation": {}
    },
    {
        "label": "newInInventory",
        "kind": 2,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_minecraft",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_minecraft",
        "peekOfCode": "def newInInventory(inventory):\n    return OperationAtom(\n        \"in-inventory\",\n        lambda obj: [ValueAtom(obj in inventory)],\n        unwrap=False)\ndef craft_op(inventory, obj, where, comp):\n    print(str(obj) + \" crafted in \" + str(where) + \" from \" + str(comp))\n    inventory.append(obj)\n    return [obj]\ndef newCraftOp(inventory):",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_minecraft",
        "documentation": {}
    },
    {
        "label": "craft_op",
        "kind": 2,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_minecraft",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_minecraft",
        "peekOfCode": "def craft_op(inventory, obj, where, comp):\n    print(str(obj) + \" crafted in \" + str(where) + \" from \" + str(comp))\n    inventory.append(obj)\n    return [obj]\ndef newCraftOp(inventory):\n    return OperationAtom(\n        \"craft\",\n        lambda obj, where, comp: craft_op(inventory, obj, where, comp),\n        unwrap=False)\ndef mine_op(inventory, obj, tool):",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_minecraft",
        "documentation": {}
    },
    {
        "label": "newCraftOp",
        "kind": 2,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_minecraft",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_minecraft",
        "peekOfCode": "def newCraftOp(inventory):\n    return OperationAtom(\n        \"craft\",\n        lambda obj, where, comp: craft_op(inventory, obj, where, comp),\n        unwrap=False)\ndef mine_op(inventory, obj, tool):\n    print(str(obj) + \" mined by \" + str(tool))\n    inventory.append(obj)\n    return [obj]\ndef newMineOp(inventory):",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_minecraft",
        "documentation": {}
    },
    {
        "label": "mine_op",
        "kind": 2,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_minecraft",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_minecraft",
        "peekOfCode": "def mine_op(inventory, obj, tool):\n    print(str(obj) + \" mined by \" + str(tool))\n    inventory.append(obj)\n    return [obj]\ndef newMineOp(inventory):\n    return OperationAtom(\n        \"mine\",\n        lambda obj, tool: mine_op(inventory, obj, tool),\n        unwrap=False)\nclass MinecraftTest(unittest.TestCase):",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_minecraft",
        "documentation": {}
    },
    {
        "label": "newMineOp",
        "kind": 2,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_minecraft",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_minecraft",
        "peekOfCode": "def newMineOp(inventory):\n    return OperationAtom(\n        \"mine\",\n        lambda obj, tool: mine_op(inventory, obj, tool),\n        unwrap=False)\nclass MinecraftTest(unittest.TestCase):\n    def test_minecraft_planning(self):\n        metta = MeTTa(env_builder=Environment.test_env())\n        inventory = [S('inventory'), S('hands')]\n        metta.register_token(\"in-inventory\", lambda _: newInInventory(inventory))",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_minecraft",
        "documentation": {}
    },
    {
        "label": "MinelogyTest",
        "kind": 6,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_minelogy",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_minelogy",
        "peekOfCode": "class MinelogyTest(HyperonTestCase):\n    def test_minelogy(self):\n        # A nearly direct reimplementation of minelogy as it\n        # was in the minecraft demo. Not optimal representation -\n        # just testing.\n        mines = MeTTa(env_builder=Environment.test_env())\n        mines.run('''\n            (((: log type) (: $x variant))\n             (: (stone_axe wooden_axe None) tools)\n             ((: log type) (: $x variant))",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_minelogy",
        "documentation": {}
    },
    {
        "label": "PLNTVTest",
        "kind": 6,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_pln_tv",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_pln_tv",
        "peekOfCode": "class PLNTVTest(HyperonTestCase):\n    def test_fuzzy_conjunction_fn(self):\n        metta = MeTTa(env_builder=Environment.test_env())\n        # `stv` as a mix of function and constructor\n        # working through ordinary equalities\n        metta.run('''\n                (= (min $a $b) (if (< $a $b) $a $b))\n                (= (s-tv (stv $s $c)) $s)\n                (= (c-tv (stv $s $c)) $c)\n                (= (stv (And $a $b))",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_pln_tv",
        "documentation": {}
    },
    {
        "label": "MeTTaTest",
        "kind": 6,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_run_metta",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_run_metta",
        "peekOfCode": "class MeTTaTest(HyperonTestCase):\n    def test_run_metta(self):\n        program = '''\n            (isa red color)\n            (isa green color)\n            (isa blue color)\n            ;(isa comment color)\n            !(match &self (isa $color color) $color)\n            (= (f) (+ 2 3))\n            !(f)",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_run_metta",
        "documentation": {}
    },
    {
        "label": "pwd",
        "kind": 5,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_run_metta",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_run_metta",
        "peekOfCode": "pwd = Path(__file__).parent\nclass MeTTaTest(HyperonTestCase):\n    def test_run_metta(self):\n        program = '''\n            (isa red color)\n            (isa green color)\n            (isa blue color)\n            ;(isa comment color)\n            !(match &self (isa $color color) $color)\n            (= (f) (+ 2 3))",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_run_metta",
        "documentation": {}
    },
    {
        "label": "HyperonTestCase",
        "kind": 6,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_sexparser",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_sexparser",
        "peekOfCode": "class HyperonTestCase(unittest.TestCase):\n    def __init__(self, methodName):\n        super().__init__(methodName)\n    def testParseToSyntaxNodes(self):\n        parser = SExprParser(\"(+ one \\\"one\\\")\")\n        syntax_node = parser.parse_to_syntax_tree()\n        leaf_node_list = syntax_node.unroll()\n        leaf_node_types = [];\n        for node in leaf_node_list:\n            leaf_node_types.append(node.get_type())",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_sexparser",
        "documentation": {}
    },
    {
        "label": "StdlibTest",
        "kind": 6,
        "importPath": "examples.python_compat.hyperon-experimental_python.tests.test_stdlib",
        "description": "examples.python_compat.hyperon-experimental_python.tests.test_stdlib",
        "peekOfCode": "class StdlibTest(HyperonTestCase):\n    def test_text_ops(self):\n        metta = MeTTa(env_builder=Environment.test_env())\n        # Check that (repr (my atom)) == \"(my atom)\"\n        self.assertEqualMettaRunnerResults(metta.run(\"!(repr (my atom))\"),\n                                           [[ValueAtom(\"(my atom)\")]])\n        # Check that (parse \"(my atom)\") == (my atom)\n        self.assertEqualMettaRunnerResults(metta.run(\"!(parse \\\"(my atom)\\\")\"),\n                                           [[ValueAtom(E(S(\"my\"), S(\"atom\")))]])\n        # Check that (stringToChars \"ABC\") == ('A' 'B' 'C')",
        "detail": "examples.python_compat.hyperon-experimental_python.tests.test_stdlib",
        "documentation": {}
    },
    {
        "label": "rand",
        "kind": 2,
        "importPath": "examples.python_compat.janus.mymodule",
        "description": "examples.python_compat.janus.mymodule",
        "peekOfCode": "def rand():\n    return 4",
        "detail": "examples.python_compat.janus.mymodule",
        "documentation": {}
    },
    {
        "label": "tests",
        "kind": 5,
        "importPath": "examples.python_compat.timing.timing",
        "description": "examples.python_compat.timing.timing",
        "peekOfCode": "tests = [\n     \"!(factorial 30)\",\n     \"!(range 1 30)\",\n     \"!(TupleCount (1 2 3 4 5 6 7 8 9 10 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30))\",\n   \"\"\"!(StampDisjoint (1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30) \n                      (1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30))\"\"\"\n]\n#Run and time them:\nruns=10\nprint(f\"Starting {len(tests)} tests with {runs} runs each, grab a coffee!\")",
        "detail": "examples.python_compat.timing.timing",
        "documentation": {}
    },
    {
        "label": "workdir",
        "kind": 5,
        "importPath": "examples.python_compat.timing.timing",
        "description": "examples.python_compat.timing.timing",
        "peekOfCode": "workdir = os.getcwd()\nfor test in tests:\n    os.chdir(workdir)\n    os.system(\"cp timing.metta RUN.metta\")\n    with open(\"RUN.metta\", \"a\") as file:\n        file.write(test)\n    os.chdir(\"../\")\n    os.system(\"sh run.sh ./timing/RUN.metta cat-only\")\n    os.system(\"sh compile_scheme.sh\")\n    os.system(\"./RUN > /dev/null\") #make sure binary is already in file cache",
        "detail": "examples.python_compat.timing.timing",
        "documentation": {}
    },
    {
        "label": "DistributedAtomSpaceTest",
        "kind": 6,
        "importPath": "metta_vspace.das_client.das_api",
        "description": "metta_vspace.das_client.das_api",
        "peekOfCode": "class DistributedAtomSpaceTest:\n    @record_execution_time()\n    def __init__(\n        self,\n        database: DatabaseType,\n        host: Optional[str] = None,\n        port: Optional[str] = None,\n    ) -> None:\n        self._db_type = database\n        try:",
        "detail": "metta_vspace.das_client.das_api",
        "documentation": {}
    },
    {
        "label": "main_apt_test",
        "kind": 2,
        "importPath": "metta_vspace.das_client.das_api",
        "description": "metta_vspace.das_client.das_api",
        "peekOfCode": "def main_apt_test():\n    from hyperon_das import DistributedAtomSpace\n    from . import DistributedAtomSpaceTest\n    from hyperon_das.utils import QueryOutputFormat\n    from hyperon_das.pattern_matcher.pattern_matcher import And, Link, Not, Variable\n    def print_pm_answer(pm_answer):\n        for mapping in pm_answer[\"mapping\"]:\n            print([[key, value[\"name\"]] for key, value in mapping.items()])\n    def print_query_answer(query_answer):\n        for link in query_answer:",
        "detail": "metta_vspace.das_client.das_api",
        "documentation": {}
    },
    {
        "label": "TestAWSClientIntegration",
        "kind": 6,
        "importPath": "metta_vspace.das_client.das_client_api",
        "description": "metta_vspace.das_client.das_client_api",
        "peekOfCode": "class TestAWSClientIntegration:\n    @pytest.fixture()\n    def server(self):\n        return FunctionsClient(url='http://44.198.65.35/prod/query-engine')\n    def test_get_node(self, server: FunctionsClient):\n        human_handle = ExpressionHasher.terminal_hash('Concept', 'human')\n        ret = server.get_node(\n            node_type=\"Concept\",\n            node_name=\"human\",\n            output_format=QueryOutputFormat.HANDLE,",
        "detail": "metta_vspace.das_client.das_client_api",
        "documentation": {}
    },
    {
        "label": "TestVultrClientIntegration",
        "kind": 6,
        "importPath": "metta_vspace.das_client.das_client_api",
        "description": "metta_vspace.das_client.das_client_api",
        "peekOfCode": "class TestVultrClientIntegration:\n    @pytest.fixture()\n    def server(self):\n        return FunctionsClient(\n            url='http://104.238.183.115:8081/function/query-engine'\n        )\n    def test_get_node(self, server: FunctionsClient):\n        human_handle = ExpressionHasher.terminal_hash('Concept', 'human')\n        ret = server.get_node(\n            node_type=\"Concept\",",
        "detail": "metta_vspace.das_client.das_client_api",
        "documentation": {}
    },
    {
        "label": "TestAWSClientIntegration",
        "kind": 6,
        "importPath": "metta_vspace.das_client.das_test_client",
        "description": "metta_vspace.das_client.das_test_client",
        "peekOfCode": "class TestAWSClientIntegration:\n    @pytest.fixture()\n    def server(self):\n        return FunctionsClient(url='http://44.198.65.35/prod/query-engine')\n    def test_get_node(self, server: FunctionsClient):\n        human_handle = ExpressionHasher.terminal_hash('Concept', 'human')\n        ret = server.get_node(\n            node_type=\"Concept\",\n            node_name=\"human\",\n            output_format=QueryOutputFormat.HANDLE,",
        "detail": "metta_vspace.das_client.das_test_client",
        "documentation": {}
    },
    {
        "label": "TestVultrClientIntegration",
        "kind": 6,
        "importPath": "metta_vspace.das_client.das_test_client",
        "description": "metta_vspace.das_client.das_test_client",
        "peekOfCode": "class TestVultrClientIntegration:\n    @pytest.fixture()\n    def server(self):\n        return FunctionsClient(\n            url='http://104.238.183.115:8081/function/query-engine'\n        )\n    def test_get_node(self, server: FunctionsClient):\n        human_handle = ExpressionHasher.terminal_hash('Concept', 'human')\n        ret = server.get_node(\n            node_type=\"Concept\",",
        "detail": "metta_vspace.das_client.das_test_client",
        "documentation": {}
    },
    {
        "label": "check_for_duplicates",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.check_duplicates",
        "description": "metta_vspace.extra_pytests.check_duplicates",
        "peekOfCode": "def check_for_duplicates(filename):\n    try:\n        # Read the TSV file into a Pandas DataFrame, skipping lines starting with '#'\n        df = pd.read_csv(filename, delimiter='\\t', comment=\"#\", dtype=str )\n        # Initialize an empty list to store columns with no duplicates\n        columns_with_no_duplicates = []\n        # Check each column for duplicate rows and collect column numbers\n        for idx, column in enumerate(df.columns):\n            if not df[column].duplicated().any():\n                columns_with_no_duplicates.append(f'({idx+1} \"{column}\")')",
        "detail": "metta_vspace.extra_pytests.check_duplicates",
        "documentation": {}
    },
    {
        "label": "VSpaceRef",
        "kind": 6,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "class VSpaceRef(SpaceRef):\n    def __init__(self, space_obj):\n        super().__init__(space_obj)\n        #if type(space_obj) is hp.CSpace:\n        #    self.cspace = space_obj\n        #else:\n        #    self.cspace = hp.space_new_custom(space_obj)\n    def subst(self, pattern, templ):\n        \"\"\"\n        Performs a substitution within the Space",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "VSpace",
        "kind": 6,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "class VSpace(AbstractSpace):\n    def __init__(self, space_name=None, unwrap=True):\n        super().__init__()\n        global vspace_ordinal\n        ispace_name = f\"&vspace_{vspace_ordinal}\"\n        vspace_ordinal=+1\n        addSpaceName(ispace_name,self)\n        if space_name is None:\n            space_name = ispace_name\n        self.sp_name = PySwipAtom(space_name)",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "FederatedSpace",
        "kind": 6,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "class FederatedSpace(VSpace):\n    def __init__(self, space_name, unwrap=True):\n        super().__init__(space_name, unwrap)\n    def _checked_impl(self, method_name, *args):\n        if access_error:\n            raise Exception(f\"Error in FederatedSpace.{method_name}: Implementation for {method_name}({', '.join(map(str, args))}) is not complete.\")\n        return super()\n    def query(self, query_atom):\n        return self._checked_impl(\"query\", query_atom).query(query_atom)\n    def add(self, atom):",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "VSNumpyValue",
        "kind": 6,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "class VSNumpyValue(MatchableObject):\n    def __eq__(self, metta_obj):\n        return isinstance(metta_obj, VSNumpyValue) and\\\n               (self.content.shape == metta_obj.content.shape) and\\\n               (self.content == metta_obj.content).all()\n    def match_(self, metta_obj):\n        sh = self.content.shape\n        bindings = {}\n        if isinstance(metta_obj, GroundedAtom):\n            metta_obj = metta_obj.get_object()",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "VSPatternValue",
        "kind": 6,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "class VSPatternValue(MatchableObject):\n    def match_(self, metta_obj):\n        if isinstance(metta_obj, GroundedAtom):\n            metta_obj = metta_obj.get_object().content\n        if not isinstance(metta_obj, VSPatternValue):\n            return metta_obj.match_(self)\n        # TODO: match to patterns\n        return []\nclass VSPatternOperation(OperationObject):\n    def __init__(self, name, op, unwrap=False, rec=False):",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "VSPatternOperation",
        "kind": 6,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "class VSPatternOperation(OperationObject):\n    def __init__(self, name, op, unwrap=False, rec=False):\n        super().__init__(name, op, unwrap)\n        self.rec = rec\n    def execute(self, *args, res_typ=AtomType.UNDEFINED):\n        if self.rec:\n            args = args[0].get_children()\n            args = [self.execute(arg)[0]\\\n                if isinstance(arg, ExpressionAtom) else arg for arg in args]\n        # If there is a variable or VSPatternValue in arguments, create VSPatternValue",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "VSpacePatternOperation",
        "kind": 6,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "class VSpacePatternOperation(OperationObject):\n    def __init__(self, name, op, unwrap=False, rec=False):\n        super().__init__(name, op, unwrap)\n        self.rec = rec\n    def execute(self, *args, res_typ=AtomType.UNDEFINED):\n        if self.rec:\n            args = args[0].get_children()\n            args = [self.execute(arg)[0]\\\n                if isinstance(arg, ExpressionAtom) else arg for arg in args]\n        # If there is a variable or VSPatternValue in arguments, create VSPatternValue",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "ExtendedMeTTa",
        "kind": 6,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "class ExtendedMeTTa:\n    def __init__(self, space = None, cwd = \".\", cmetta = None):\n        if cmetta is not None:\n            self.cmetta = cmetta\n        else:\n            if space is None:\n                space = GroundingSpaceRef()\n            tokenizer = Tokenizer()\n            self.py_space = space\n            self.py_tokenizer = tokenizer",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "LazyMeTTa",
        "kind": 6,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "class LazyMeTTa(ExtendedMeTTa):\n    def lazy_import_file(self, fname):\n        path = fname.split(os.sep)\n        with open(os.sep.join(self.cwd + path), \"r\") as f:\n            program = f.read()\n        self.lazy_run(self._parse_all(program))\n    def lazy_run(self, stream):\n        for i, (expr, result_set) in enumerate(self.lazy_run_loop(stream)):\n            if result_set:\n                print(f\"> {color_expr(expr)}\")",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "GptSpace",
        "kind": 6,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "class GptSpace(GroundingSpace):\n    def query(self, query_atom):\n        tot_str = \"Answer the question taking into account the following information (each fact is in brackets):\\n\"\n        for atom in self.atoms_iter():\n            tot_str += str(atom) + \"\\n\"\n        tot_str += \"If the question contains letters in brackets with $ sign, for example ($x), provide the answer in the json format in curly brackets, that is { $x: your answer }.\\n\"\n        # tot_str += \"If information is not provided, return the entry to be queried in JSON {unknown value: UNKNOWN}.\"\n        tot_str += \"The question is: \" + str(query_atom)[1:-1] + \"?\"\n        response = openai.ChatCompletion.create(\n                model=\"gpt-3.5-turbo-0613\",",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "GptIntentSpace",
        "kind": 6,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "class GptIntentSpace(GroundingSpace):\n    def query(self, query_atom):\n        tot_str = \"Analyze the topic of the utterance: \" + str(query_atom)[1:-1] + \"\\n\"\n        tot_str += \"Try to pick the most relevant topic from the following list (each topic in brackets):\"\n        for atom in self.atoms_iter():\n            tot_str += str(atom) + \"\\n\"\n        tot_str += \"If neither of the listed topics seems relevant, answer (chit-chat).\"\n        tot_str += \"Provide the answer in the json format in curly brackets in the form { topic: your answer }.\\n\"\n        response = openai.ChatCompletion.create(\n                model=\"gpt-3.5-turbo-0613\",",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "InteractiveMeTTa",
        "kind": 6,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "class InteractiveMeTTa(LazyMeTTa):\n    def __init__(self):\n        super().__init__()\n        # parent == self\n        #   means no parent MeTTa yet\n        self.parent = self\n    def maybe_submode(self, line):\n        lastchar = line[-1]\n        if \"+-?!^\".find(lastchar)>=0:\n            self.submode=lastchar",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "insert_to_history",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def insert_to_history(item, position_from_last=5):\n    hist = [readline.get_history_item(i) for i in range(1, readline.get_current_history_length() + 1)]\n    hist.insert(max(0, len(hist) - position_from_last), item)\n    readline.clear_history()\n    for h in hist: readline.add_history(h)\ninsert_to_history('!(get-by-key &my-dict \"A\")')\ninsert_to_history(\"@metta !\")\ninsert_to_history(\"!(mine-overlaps)\")\ninsert_to_history(\"!(try-overlaps)\")\ninsert_to_history(\"!(load-flybase-full)\")",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "save",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def save(prev_h_len, histfile):\n    new_h_len = readline.get_current_history_length()\n    readline.set_history_length(300)\n    readline.append_history_file(new_h_len - prev_h_len, histfile)\natexit.register(save, h_len, histfile)\ndef add_to_history_if_unique(item):\n    for i in range(1, readline.get_current_history_length() + 1):\n        if readline.get_history_item(i) == item: return\n    insert_to_history(item)\ndef export_to_metta(func, name=None):",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "add_to_history_if_unique",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def add_to_history_if_unique(item):\n    for i in range(1, readline.get_current_history_length() + 1):\n        if readline.get_history_item(i) == item: return\n    insert_to_history(item)\ndef export_to_metta(func, name=None):\n    setattr(func, 'export_to_metta', True)\n    setattr(func, 'named', name)\n    if verbose>3: print(f\"{func}={getattr(func, 'export_to_metta', False)}\")\n    return func\ndef export_to_pyswip(func, name=None):",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "export_to_metta",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def export_to_metta(func, name=None):\n    setattr(func, 'export_to_metta', True)\n    setattr(func, 'named', name)\n    if verbose>3: print(f\"{func}={getattr(func, 'export_to_metta', False)}\")\n    return func\ndef export_to_pyswip(func, name=None):\n    setattr(func, 'export_to_pyswip', True)\n    setattr(func, 'named', name)\n    if verbose>3: print(f\"{func}={getattr(func, 'export_to_pyswip', False)}\")\n    return func",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "export_to_pyswip",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def export_to_pyswip(func, name=None):\n    setattr(func, 'export_to_pyswip', True)\n    setattr(func, 'named', name)\n    if verbose>3: print(f\"{func}={getattr(func, 'export_to_pyswip', False)}\")\n    return func\n@export_to_metta\ndef add_exported_methods(module, dict = oper_dict):\n    for name, obj in inspect.getmembers(module):\n        if inspect.isfunction(obj):\n            if getattr(obj, 'export_to_metta', False):",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "add_exported_methods",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def add_exported_methods(module, dict = oper_dict):\n    for name, obj in inspect.getmembers(module):\n        if inspect.isfunction(obj):\n            if getattr(obj, 'export_to_metta', False):\n                suggestName = getattr(func, 'named', None)\n                if suggestName is not None:\n                    use_name = suggestName\n                else: use_name = name\n                sig = inspect.signature(obj)\n                params = sig.parameters",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "add_pyop",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def add_pyop(name, length, dict = oper_dict):\n    hyphens, underscores = name.replace('_', '-'), name.replace('-', '_')\n    mettavars, pyvars = (' '.join(f\"${chr(97 + i)}\" for i in range(length))).strip(), (', '.join(chr(97 + i) for i in range(length))).strip()\n    s = f\"!({hyphens})\" if mettavars == \"\" else f\"!({hyphens} {mettavars})\"\n    add_to_history_if_unique(s); #print(s)\n    if hyphens not in dict:\n        src, local_vars = f'op = OperationAtom( \"{hyphens}\", lambda {pyvars}: [{underscores}({pyvars})])', {}\n        exec(src, globals(), local_vars)  #print(f'metta: OperationAtom(\"{hyphens}\",{src}, unwrap=False)')\n        dict[hyphens] = local_vars['op']\n        dict[underscores] = local_vars['op']",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "add_swip",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def add_swip(name, dict = oper_dict):\n    hyphens, underscores = name.replace('_', '-'), name.replace('-', '_')\n    add_to_history_if_unique(f\"!({hyphens})\")\n    if hyphens not in dict:\n        src, local_vars = f'op = lambda : [swip_exec(\"{underscores}\")]', {}\n        exec(src, {}, local_vars)\n        print(f\"swip: {hyphens}\")\n        dict[hyphens] = OperationAtom(hyphens, local_vars['op'], unwrap=False)\ndef addSpaceName(name, space):\n    global syms_dict",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "addSpaceName",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def addSpaceName(name, space):\n    global syms_dict\n    global space_refs\n    syms_dict[name] = lambda _: G(VSpaceRef(space))\n    space_refs[name] = lambda : space\n# subclass to later capture any utility we can add to 'subst'\nclass VSpaceRef(SpaceRef):\n    def __init__(self, space_obj):\n        super().__init__(space_obj)\n        #if type(space_obj) is hp.CSpace:",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "test_custom_v_space",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def test_custom_v_space():\n    test_custom_space(lambda: VSpace())\ndef test_custom_space(LambdaSpaceFn):\n    def passTest(msg):\n        print(f\"Pass Test:({msg})\")\n    def failTest(msg):\n        print(f\"raise AssertionError({msg})\")\n        #raise AssertionError(msg)\n    def self_assertEqualNoOrder(list1, list2, msg=None):\n        \"\"\"",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "test_custom_space",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def test_custom_space(LambdaSpaceFn):\n    def passTest(msg):\n        print(f\"Pass Test:({msg})\")\n    def failTest(msg):\n        print(f\"raise AssertionError({msg})\")\n        #raise AssertionError(msg)\n    def self_assertEqualNoOrder(list1, list2, msg=None):\n        \"\"\"\n        Asserts that two lists are equal, regardless of their order.\n        \"\"\"",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "s2m",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def s2m(swip_obj):\n    # Handle numbers and convert them to ValueAtom objects in MeTTa\n    if isinstance(swip_obj, (int, float)):\n        return ValueAtom(swip_obj)\n    if isinstance(swip_obj, str):\n        return S(swip_obj)\n    if isinstance(swip_obj, PySwipAtom):\n        return S(str(swip_obj))\n    if isinstance(swip_obj, Variable):\n        n = swip_obj.chars",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "sv2mv",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def sv2mv(s):\n    return s.replace(\"_\", \"$\", 1) if s.startswith(\"_\") else \"$\" + s\ndef pt(s):\n    print(f\"{type(s)} {s}\")\n@export_to_metta\ndef test_s(metta_obj):\n    pt(metta_obj)\n    swip_obj = m2s(metta_obj)\n    pt(swip_obj)\n    new_mo = s2m(swip_obj)",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "pt",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def pt(s):\n    print(f\"{type(s)} {s}\")\n@export_to_metta\ndef test_s(metta_obj):\n    pt(metta_obj)\n    swip_obj = m2s(metta_obj)\n    pt(swip_obj)\n    new_mo = s2m(swip_obj)\n    pt(new_mo)\n    return new_mo",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "test_s",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def test_s(metta_obj):\n    pt(metta_obj)\n    swip_obj = m2s(metta_obj)\n    pt(swip_obj)\n    new_mo = s2m(swip_obj)\n    pt(new_mo)\n    return new_mo\n# Do not @export_to_metta\ndef m2s(metta_obj, depth=0):\n    r = m2s1(metta_obj, depth)",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "m2s",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def m2s(metta_obj, depth=0):\n    r = m2s1(metta_obj, depth)\n    if depth==0:\n        v = swipRef(r)\n    else:\n        v = r\n    if verbose<=0: return v\n    for i in range(depth+1):\n        print(\"   \",end='')\n    print(f\"r({type(r)})={r}\")",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "swipAtom",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def swipAtom(m):\n    a = PySwipAtom(str(m))\n    return a\ndef swipRef(a):\n    if isinstance(a, (Variable, Term)):\n        return a\n    v = Variable()\n    v.unify(a)\n    return v\ndef m2s1(metta_obj, depth=0, preferStringToAtom = None, preferListToCompound = False):",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "swipRef",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def swipRef(a):\n    if isinstance(a, (Variable, Term)):\n        return a\n    v = Variable()\n    v.unify(a)\n    return v\ndef m2s1(metta_obj, depth=0, preferStringToAtom = None, preferListToCompound = False):\n    if isinstance(metta_obj, GroundedAtom):\n        metta_obj = metta_obj.get_object()\n    if isinstance(metta_obj, ValueObject):",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "m2s1",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def m2s1(metta_obj, depth=0, preferStringToAtom = None, preferListToCompound = False):\n    if isinstance(metta_obj, GroundedAtom):\n        metta_obj = metta_obj.get_object()\n    if isinstance(metta_obj, ValueObject):\n        metta_obj = metta_obj.value\n    try:\n        if verbose>0:\n            for i in range(depth):\n                print(\"   \",end='')\n            print(f'm2s({type(metta_obj)}): {metta_obj}')",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "swiplist_to_swip",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def swiplist_to_swip(retargs, depth=0):\n    sv = [m2s1(item,depth) for item in retargs]\n    v = Variable()\n    v.unify(sv)\n    return v\ndef list_to_termv(retargs, depth=0):\n    sv = [m2s1(item,depth) for item in retargs]\n    return sv\nimport numpy as np\nclass VSNumpyValue(MatchableObject):",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "list_to_termv",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def list_to_termv(retargs, depth=0):\n    sv = [m2s1(item,depth) for item in retargs]\n    return sv\nimport numpy as np\nclass VSNumpyValue(MatchableObject):\n    def __eq__(self, metta_obj):\n        return isinstance(metta_obj, VSNumpyValue) and\\\n               (self.content.shape == metta_obj.content.shape) and\\\n               (self.content == metta_obj.content).all()\n    def match_(self, metta_obj):",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "wrapnpop",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def wrapnpop(func):\n    def wrapper(*args):\n        a = [arg.get_object().value for arg in args]\n        res = func(*a)\n        typ = _np_atom_type(res)\n        return [G(VSNumpyValue(res), typ)]\n    return wrapper\ndef color(t, c):\n    cmap = [90, 91, 31, 93, 92, 32, 36, 96, 94, 34, 35, 95, 38]\n    return f\"\\033[{cmap[c % len(cmap)]}m{t}\\033[0m\"",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "color",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def color(t, c):\n    cmap = [90, 91, 31, 93, 92, 32, 36, 96, 94, 34, 35, 95, 38]\n    return f\"\\033[{cmap[c % len(cmap)]}m{t}\\033[0m\"\ndef oblique(t):\n    return f\"\\033[3m{t}\\033[0m\"\ndef underline(t):\n    return f\"\\033[4m{t}\\033[0m\"\ndef expr_vars(expr):\n    if isinstance(expr, SymbolAtom):\n        return []",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "oblique",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def oblique(t):\n    return f\"\\033[3m{t}\\033[0m\"\ndef underline(t):\n    return f\"\\033[4m{t}\\033[0m\"\ndef expr_vars(expr):\n    if isinstance(expr, SymbolAtom):\n        return []\n    elif isinstance(expr, VariableAtom):\n        return [str(expr)]\n    elif isinstance(expr, ExpressionAtom):",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "underline",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def underline(t):\n    return f\"\\033[4m{t}\\033[0m\"\ndef expr_vars(expr):\n    if isinstance(expr, SymbolAtom):\n        return []\n    elif isinstance(expr, VariableAtom):\n        return [str(expr)]\n    elif isinstance(expr, ExpressionAtom):\n        return [e for c in expr.get_children() for e in expr_vars(c)]\n    elif isinstance(expr, GroundedAtom):",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "expr_vars",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def expr_vars(expr):\n    if isinstance(expr, SymbolAtom):\n        return []\n    elif isinstance(expr, VariableAtom):\n        return [str(expr)]\n    elif isinstance(expr, ExpressionAtom):\n        return [e for c in expr.get_children() for e in expr_vars(c)]\n    elif isinstance(expr, GroundedAtom):\n        return []\n    else:",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "color_expr",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def color_expr(expr, level=0, unif_vars=None):\n    name = str(expr)\n    if level == 0:\n        unif_vars = frozenset(e for e, c in Counter(expr_vars(expr)).items() if c > 1) \\\n            if unif_vars is None else frozenset()\n    if isinstance(expr, SymbolAtom):\n        return name\n    elif isinstance(expr, VariableAtom):\n        return oblique(name) if name in unif_vars else name\n    elif isinstance(expr, ExpressionAtom):",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "print_l",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def print_l(obj):\n    if obj is None:\n        print(\"None!\")\n        return obj\n    if isinstance(obj, str):\n        print(obj)\n        return obj\n    try:\n        # Attempt to iterate over the object\n        for item in obj:",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "println",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def println(obj):\n    \"\"\"\n    Prints the given object and returns it.\n    Args:\n        obj: The object to be printed.\n    Returns:\n        The same object that was passed in.\n    \"\"\"\n    print(obj)\n    return obj",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "get_sexpr_input",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def get_sexpr_input(prmpt):\n    expr, inside_quotes, prev_char = \"\", False, None\n    while True:\n        line = input(prmpt)\n        for char in line:\n            if char == '\"' and prev_char != '\\\\':\n                inside_quotes = not inside_quotes\n            expr += char\n            prev_char = char\n        if not inside_quotes and expr.count(\"(\") == expr.count(\")\"):",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "the_running_metta_space",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def the_running_metta_space():\n    #if the_python_runner.parent!=the_python_runner:\n    #    return the_python_runner.parent.space()\n    return the_new_runner_space\n# Borrowed impl from Adam Vandervorst\nimport os\nfrom importlib import import_module\nimport hyperonpy as hp\nfrom hyperon.atoms import Atom, AtomType, OperationAtom\nfrom hyperon.base import GroundingSpaceRef, Tokenizer, SExprParser",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "split_or_none",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def split_or_none(s, delimiter):\n    parts = s.split(delimiter, 1)  # split only at the first occurrence\n    return parts[0], parts[1] if len(parts) > 1 else None\n# from awakening health\ndef _response2bindings(txt):\n        res = re.findall(r'\\{.*?\\}', txt)\n        new_bindings_set = BindingsSet.empty()\n        if res == []:\n            return new_bindings_set\n        res = res[0][1:-1]",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "self_space_info",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def self_space_info():\n    return \"\"\n@register_atoms(pass_metta=True)\ndef register_vspace_atoms(metta):\n    global oper_dict\n    the_python_runner.set_cmetta(metta)\n    counter = 0\n    if verbose>0: print(f\"register_vspace_atoms metta={metta} {self_space_info()}\")\n    if not isinstance(metta, VSpace):\n        the_python_runner.parent = metta",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "register_vspace_atoms",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def register_vspace_atoms(metta):\n    global oper_dict\n    the_python_runner.set_cmetta(metta)\n    counter = 0\n    if verbose>0: print(f\"register_vspace_atoms metta={metta} {self_space_info()}\")\n    if not isinstance(metta, VSpace):\n        the_python_runner.parent = metta\n    def new_value_atom_func():\n        nonlocal counter\n        counter += 1",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "register_vspace_tokens",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def register_vspace_tokens(metta):\n    if verbose>0: print(f\"register_vspace_tokens metta={metta} {self_space_info()}\")\n    the_python_runner.set_cmetta(metta.cmetta)\n    if not isinstance(metta, VSpace):\n        the_python_runner.parent = metta\n    def run_resolved_symbol_op(the_python_runner, atom, *args):\n        expr = E(atom, *args)\n        if verbose>0: print(f\"run_resolved_symbol_op: atom={atom}, args={args}, expr={expr} metta={metta} {self_space_info()}\")\n        result1 = hp.metta_evaluate_atom(the_python_runner.cmetta, expr.catom)\n        result = [MeTTaAtom._from_catom(catom) for catom in result1]",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "test_nondeterministic_foreign",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def test_nondeterministic_foreign():\n    def nondet(a, context):\n        control = PL_foreign_control(context)\n        context = PL_foreign_context(context)\n        if control == PL_FIRST_CALL:\n            context = 0\n            a.unify(int(context))\n            context += 1\n            return PL_retry(context)\n        elif control == PL_REDO:",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "swip_to_metta_wrapper",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def swip_to_metta_wrapper(swip_obj, metta_obj):\n    result1 = m2s(s2m(swip_obj))\n    result2 = m2s(metta_obj)\n    #metta_obj.unify(m2s(result))\n    return result2.unify(result1)\n    #return True\n@export_to_pyswip\ndef metta_to_swip_wrapper(metta_obj, swip_obj):\n    result1 = m2s(metta_obj)\n    result2 = m2s(swip_obj)",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "metta_to_swip_wrapper",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def metta_to_swip_wrapper(metta_obj, swip_obj):\n    result1 = m2s(metta_obj)\n    result2 = m2s(swip_obj)\n    #swip_obj.unify(result)\n    return result2.unify(result1)\n    #return True\n@export_to_metta\ndef metta_to_swip_tests1():\n    # Register the methods as foreign predicates\n    registerForeign(swip_to_metta_wrapper, arity=2)",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "metta_to_swip_tests1",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def metta_to_swip_tests1():\n    # Register the methods as foreign predicates\n    registerForeign(swip_to_metta_wrapper, arity=2)\n    registerForeign(metta_to_swip_wrapper, arity=2)\n    # Usage:\n    swip_functor = Functor(PySwipAtom(\"example\"), 2, [PySwipAtom(\"sub1\"), 3.14])\n    print(f\"swip_functor={swip_functor}\"),\n    metta_expr = s2m(swip_functor)\n    print(f\"metta_expr={metta_expr}\"),\n    converted_back_to_swip = m2s(metta_expr)",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "metta_to_swip_tests2",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def metta_to_swip_tests2():\n    # Register the methods as foreign predicates\n    registerForeign(swip_to_metta_wrapper, arity=2)\n    registerForeign(metta_to_swip_wrapper, arity=2)\n    # Now you can use the methods in PySwip queries\n    printl(list(swip.query(\"swip_to_metta_wrapper('example', X).\")))\n    printl(list(swip.query(\"metta_to_swip_wrapper(X, 'example').\")))\n    # Usage:\n    swip_list = [\"a\", \"b\", 3]\n    metta_expr = s2m(swip_list)",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "load_vspace",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def load_vspace():\n   swip_exec(f\"ensure_loaded('{os.path.dirname(__file__)}/pyswip/swi_flybase')\")\n@export_to_metta\ndef mine_overlaps():\n   load_vspace()\n   swip_exec(\"mine_overlaps\")\n@export_to_metta\ndef try_overlaps():\n   load_vspace()\n   swip_exec(\"try_overlaps\")",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "mine_overlaps",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def mine_overlaps():\n   load_vspace()\n   swip_exec(\"mine_overlaps\")\n@export_to_metta\ndef try_overlaps():\n   load_vspace()\n   swip_exec(\"try_overlaps\")\n@export_to_metta\ndef learn_vspace():\n   load_vspace()",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "try_overlaps",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def try_overlaps():\n   load_vspace()\n   swip_exec(\"try_overlaps\")\n@export_to_metta\ndef learn_vspace():\n   load_vspace()\n   swip_exec(\"learn_vspace(60)\")\ndef load_flybase(size):\n   load_vspace()\n   swip_exec(f\"load_flybase({size})\")",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "learn_vspace",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def learn_vspace():\n   load_vspace()\n   swip_exec(\"learn_vspace(60)\")\ndef load_flybase(size):\n   load_vspace()\n   swip_exec(f\"load_flybase({size})\")\n@export_to_metta\ndef swip_exec(qry):\n    #from metta_vspace import swip\n    #if is_init==True:",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "load_flybase",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def load_flybase(size):\n   load_vspace()\n   swip_exec(f\"load_flybase({size})\")\n@export_to_metta\ndef swip_exec(qry):\n    #from metta_vspace import swip\n    #if is_init==True:\n    #   print(\"Not running Query: \",qry)\n    #   return\n    for r in swip.query(qry):",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "swip_exec",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def swip_exec(qry):\n    #from metta_vspace import swip\n    #if is_init==True:\n    #   print(\"Not running Query: \",qry)\n    #   return\n    for r in swip.query(qry):\n        print(r)\n@export_to_metta\ndef test_custom_m_space():\n    class TestSpace(AbstractSpace):",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "test_custom_m_space",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def test_custom_m_space():\n    class TestSpace(AbstractSpace):\n        def __init__(self, unwrap=True):\n            super().__init__()\n            self.atoms_list = []\n            self.unwrap = unwrap\n        # NOTE: this is a naive implementation barely good enough to pass the tests\n        # Don't take this as a guide to implementing a space query function\n        def query(self, query_atom):\n            # Extract only the variables from the query atom",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "vspace_main",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def vspace_main():\n    is_init=False\n    #os.system('clear')\n    t0 = monotonic_ns()\n    print(underline(\"Version-Space Main\\n\"))\n    #if is_init==False: load_vspace()\n    #if is_init==False: load_flybase()\n    #if is_init==False:\n    the_python_runner.repl()\n    print(f\"\\nmain took {(monotonic_ns() - t0)/1e9:.5} seconds in walltime\")",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "vspace_init",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "def vspace_init():\n    t0 = monotonic_ns()\n    #os.system('clear')\n    print(underline(f\"Version-Space Init: {__file__}\\n\"))\n    #import site\n    #print (\"Site Packages: \",site.getsitepackages())\n    #test_nondeterministic_foreign()\n    if os.path.isfile(f\"{the_python_runner.cwd}autoexec.metta\"):\n        the_python_runner.lazy_import_file(\"autoexec.metta\")\n    # @TODO fix this metta_to_swip_tests1()",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "verbose",
        "kind": 5,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "verbose = 1\nhistfile = os.path.join(os.path.expanduser(\"~\"), \".metta_history\")\nis_init = True\noper_dict = {}\nsyms_dict = {}\nspace_refs = {\n    #'&vspace': lambda: the_vspace,\n    '&gptspace': lambda: the_gptspace,\n    #'&flybase': lambda: the_flybase,\n    '&parent': lambda: the_python_runner.parent.space(),",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "histfile",
        "kind": 5,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "histfile = os.path.join(os.path.expanduser(\"~\"), \".metta_history\")\nis_init = True\noper_dict = {}\nsyms_dict = {}\nspace_refs = {\n    #'&vspace': lambda: the_vspace,\n    '&gptspace': lambda: the_gptspace,\n    #'&flybase': lambda: the_flybase,\n    '&parent': lambda: the_python_runner.parent.space(),\n    '&child': lambda: the_python_runner.space()}",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "is_init",
        "kind": 5,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "is_init = True\noper_dict = {}\nsyms_dict = {}\nspace_refs = {\n    #'&vspace': lambda: the_vspace,\n    '&gptspace': lambda: the_gptspace,\n    #'&flybase': lambda: the_flybase,\n    '&parent': lambda: the_python_runner.parent.space(),\n    '&child': lambda: the_python_runner.space()}\ntry:",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "oper_dict",
        "kind": 5,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "oper_dict = {}\nsyms_dict = {}\nspace_refs = {\n    #'&vspace': lambda: the_vspace,\n    '&gptspace': lambda: the_gptspace,\n    #'&flybase': lambda: the_flybase,\n    '&parent': lambda: the_python_runner.parent.space(),\n    '&child': lambda: the_python_runner.space()}\ntry:\n    readline.set_history_length(300)",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "syms_dict",
        "kind": 5,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "syms_dict = {}\nspace_refs = {\n    #'&vspace': lambda: the_vspace,\n    '&gptspace': lambda: the_gptspace,\n    #'&flybase': lambda: the_flybase,\n    '&parent': lambda: the_python_runner.parent.space(),\n    '&child': lambda: the_python_runner.space()}\ntry:\n    readline.set_history_length(300)\n    readline.read_history_file(histfile)",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "space_refs",
        "kind": 5,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "space_refs = {\n    #'&vspace': lambda: the_vspace,\n    '&gptspace': lambda: the_gptspace,\n    #'&flybase': lambda: the_flybase,\n    '&parent': lambda: the_python_runner.parent.space(),\n    '&child': lambda: the_python_runner.space()}\ntry:\n    readline.set_history_length(300)\n    readline.read_history_file(histfile)\n    h_len = readline.get_current_history_length()",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "vspace_ordinal",
        "kind": 5,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "vspace_ordinal = 0\n@export_to_metta\nclass VSpace(AbstractSpace):\n    def __init__(self, space_name=None, unwrap=True):\n        super().__init__()\n        global vspace_ordinal\n        ispace_name = f\"&vspace_{vspace_ordinal}\"\n        vspace_ordinal=+1\n        addSpaceName(ispace_name,self)\n        if space_name is None:",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "access_error",
        "kind": 5,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "access_error = True\n@export_to_metta\nclass FederatedSpace(VSpace):\n    def __init__(self, space_name, unwrap=True):\n        super().__init__(space_name, unwrap)\n    def _checked_impl(self, method_name, *args):\n        if access_error:\n            raise Exception(f\"Error in FederatedSpace.{method_name}: Implementation for {method_name}({', '.join(map(str, args))}) is not complete.\")\n        return super()\n    def query(self, query_atom):",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "#export_to_metta",
        "kind": 5,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "#export_to_metta = mark_decorator(\"export_to_metta\")\n#export_to_pyswip = mark_decorator(\"export_to_pyswip\")\n#staticmethod = mark_decorator(\"staticmethod\")\nswip = PySwip()\nthe_gptspace = GptSpace()\nthe_vspace = VSpace(\"&vspace\")\nthe_flybase = VSpace(\"&flybase\")\nthe_python_runner = InteractiveMeTTa();\nthe_python_runner.cwd = [os.path.dirname(os.path.dirname(__file__))]\nthe_old_runner_space = the_python_runner.space()",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "#export_to_pyswip",
        "kind": 5,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "#export_to_pyswip = mark_decorator(\"export_to_pyswip\")\n#staticmethod = mark_decorator(\"staticmethod\")\nswip = PySwip()\nthe_gptspace = GptSpace()\nthe_vspace = VSpace(\"&vspace\")\nthe_flybase = VSpace(\"&flybase\")\nthe_python_runner = InteractiveMeTTa();\nthe_python_runner.cwd = [os.path.dirname(os.path.dirname(__file__))]\nthe_old_runner_space = the_python_runner.space()\nthe_python_runner.run(\"!(extend-py! metta_learner)\")",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "#staticmethod",
        "kind": 5,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "#staticmethod = mark_decorator(\"staticmethod\")\nswip = PySwip()\nthe_gptspace = GptSpace()\nthe_vspace = VSpace(\"&vspace\")\nthe_flybase = VSpace(\"&flybase\")\nthe_python_runner = InteractiveMeTTa();\nthe_python_runner.cwd = [os.path.dirname(os.path.dirname(__file__))]\nthe_old_runner_space = the_python_runner.space()\nthe_python_runner.run(\"!(extend-py! metta_learner)\")\nthe_new_runner_space = the_python_runner.space()",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "swip",
        "kind": 5,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "swip = PySwip()\nthe_gptspace = GptSpace()\nthe_vspace = VSpace(\"&vspace\")\nthe_flybase = VSpace(\"&flybase\")\nthe_python_runner = InteractiveMeTTa();\nthe_python_runner.cwd = [os.path.dirname(os.path.dirname(__file__))]\nthe_old_runner_space = the_python_runner.space()\nthe_python_runner.run(\"!(extend-py! metta_learner)\")\nthe_new_runner_space = the_python_runner.space()\n#the_python_runner.run(\"!(extend-py! VSpace)\")",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "the_gptspace",
        "kind": 5,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "the_gptspace = GptSpace()\nthe_vspace = VSpace(\"&vspace\")\nthe_flybase = VSpace(\"&flybase\")\nthe_python_runner = InteractiveMeTTa();\nthe_python_runner.cwd = [os.path.dirname(os.path.dirname(__file__))]\nthe_old_runner_space = the_python_runner.space()\nthe_python_runner.run(\"!(extend-py! metta_learner)\")\nthe_new_runner_space = the_python_runner.space()\n#the_python_runner.run(\"!(extend-py! VSpace)\")\n#the_python_runner.run(\"!(extend-py! GptSpace)\")",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "the_vspace",
        "kind": 5,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "the_vspace = VSpace(\"&vspace\")\nthe_flybase = VSpace(\"&flybase\")\nthe_python_runner = InteractiveMeTTa();\nthe_python_runner.cwd = [os.path.dirname(os.path.dirname(__file__))]\nthe_old_runner_space = the_python_runner.space()\nthe_python_runner.run(\"!(extend-py! metta_learner)\")\nthe_new_runner_space = the_python_runner.space()\n#the_python_runner.run(\"!(extend-py! VSpace)\")\n#the_python_runner.run(\"!(extend-py! GptSpace)\")\nis_init_ran = False",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "the_flybase",
        "kind": 5,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "the_flybase = VSpace(\"&flybase\")\nthe_python_runner = InteractiveMeTTa();\nthe_python_runner.cwd = [os.path.dirname(os.path.dirname(__file__))]\nthe_old_runner_space = the_python_runner.space()\nthe_python_runner.run(\"!(extend-py! metta_learner)\")\nthe_new_runner_space = the_python_runner.space()\n#the_python_runner.run(\"!(extend-py! VSpace)\")\n#the_python_runner.run(\"!(extend-py! GptSpace)\")\nis_init_ran = False\nif is_init_ran == False:",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "the_python_runner",
        "kind": 5,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "the_python_runner = InteractiveMeTTa();\nthe_python_runner.cwd = [os.path.dirname(os.path.dirname(__file__))]\nthe_old_runner_space = the_python_runner.space()\nthe_python_runner.run(\"!(extend-py! metta_learner)\")\nthe_new_runner_space = the_python_runner.space()\n#the_python_runner.run(\"!(extend-py! VSpace)\")\n#the_python_runner.run(\"!(extend-py! GptSpace)\")\nis_init_ran = False\nif is_init_ran == False:\n    is_init_ran = True",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "the_python_runner.cwd",
        "kind": 5,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "the_python_runner.cwd = [os.path.dirname(os.path.dirname(__file__))]\nthe_old_runner_space = the_python_runner.space()\nthe_python_runner.run(\"!(extend-py! metta_learner)\")\nthe_new_runner_space = the_python_runner.space()\n#the_python_runner.run(\"!(extend-py! VSpace)\")\n#the_python_runner.run(\"!(extend-py! GptSpace)\")\nis_init_ran = False\nif is_init_ran == False:\n    is_init_ran = True\n    vspace_init()",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "the_old_runner_space",
        "kind": 5,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "the_old_runner_space = the_python_runner.space()\nthe_python_runner.run(\"!(extend-py! metta_learner)\")\nthe_new_runner_space = the_python_runner.space()\n#the_python_runner.run(\"!(extend-py! VSpace)\")\n#the_python_runner.run(\"!(extend-py! GptSpace)\")\nis_init_ran = False\nif is_init_ran == False:\n    is_init_ran = True\n    vspace_init()\nif __name__ == \"__main__\":",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "the_new_runner_space",
        "kind": 5,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "the_new_runner_space = the_python_runner.space()\n#the_python_runner.run(\"!(extend-py! VSpace)\")\n#the_python_runner.run(\"!(extend-py! GptSpace)\")\nis_init_ran = False\nif is_init_ran == False:\n    is_init_ran = True\n    vspace_init()\nif __name__ == \"__main__\":\n    vspace_main()\n#from . import metta_learner",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "is_init_ran",
        "kind": 5,
        "importPath": "metta_vspace.extra_pytests.flyspace",
        "description": "metta_vspace.extra_pytests.flyspace",
        "peekOfCode": "is_init_ran = False\nif is_init_ran == False:\n    is_init_ran = True\n    vspace_init()\nif __name__ == \"__main__\":\n    vspace_main()\n#from . import metta_learner",
        "detail": "metta_vspace.extra_pytests.flyspace",
        "documentation": {}
    },
    {
        "label": "NeuralSpace",
        "kind": 6,
        "importPath": "metta_vspace.extra_pytests.neurospace",
        "description": "metta_vspace.extra_pytests.neurospace",
        "peekOfCode": "class NeuralSpace(GroundingSpace):\n    def query(self, query_atom):\n        tot_str = \"Answer the question taking into account the following information (each fact is in brackets):\\n\"\n        for atom in self.atoms_iter():\n            tot_str += str(atom) + \"\\n\"\n        tot_str += \"If the question contains letters in brackets with $ sign, for example ($x), provide the answer in the json format in curly brackets, that is { $x: your answer }.\\n\"\n        # tot_str += \"If information is not provided, return the entry to be queried in JSON {unknown value: UNKNOWN}.\"\n        tot_str += \"The question is: \" + str(query_atom)[1:-1] + \"?\"\n        response = openai.ChatCompletion.create(\n                model=\"gpt-3.5-turbo-0613\",",
        "detail": "metta_vspace.extra_pytests.neurospace",
        "documentation": {}
    },
    {
        "label": "IntentSpace",
        "kind": 6,
        "importPath": "metta_vspace.extra_pytests.neurospace",
        "description": "metta_vspace.extra_pytests.neurospace",
        "peekOfCode": "class IntentSpace(GroundingSpace):\n    def query(self, query_atom):\n        tot_str = \"Analyze the topic of the utterance: \" + str(query_atom)[1:-1] + \"\\n\"\n        tot_str += \"Try to pick the most relevant topic from the following list (each topic in brackets):\"\n        for atom in self.atoms_iter():\n            tot_str += str(atom) + \"\\n\"\n        tot_str += \"If neither of the listed topics seems relevant, answer (chit-chat).\"\n        tot_str += \"Provide the answer in the json format in curly brackets in the form { topic: your answer }.\\n\"\n        response = openai.ChatCompletion.create(\n                model=\"gpt-3.5-turbo-0613\",",
        "detail": "metta_vspace.extra_pytests.neurospace",
        "documentation": {}
    },
    {
        "label": "neuralspace_atoms",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.neurospace",
        "description": "metta_vspace.extra_pytests.neurospace",
        "peekOfCode": "def neuralspace_atoms():\n    newNSpaceAtom = OperationAtom('new-neural-space', lambda: [G(SpaceRef(NeuralSpace()))], unwrap=False)\n    newISpaceAtom = OperationAtom('new-intent-space', lambda: [G(SpaceRef(IntentSpace()))], unwrap=False)\n    return {\n        r\"new-neural-space\": newNSpaceAtom,\n        r\"new-intent-space\": newISpaceAtom,\n    }",
        "detail": "metta_vspace.extra_pytests.neurospace",
        "documentation": {}
    },
    {
        "label": "openai.api_key",
        "kind": 5,
        "importPath": "metta_vspace.extra_pytests.neurospace",
        "description": "metta_vspace.extra_pytests.neurospace",
        "peekOfCode": "openai.api_key = os.environ[\"OPENAI_API_KEY\"]\nimport os\nimport re\ndef _response2bindings(txt):\n        res = re.findall(r'\\{.*?\\}', txt)\n        new_bindings_set = BindingsSet.empty()\n        if res == []:\n            return new_bindings_set\n        res = res[0][1:-1]\n        _var, val = res.split(':')",
        "detail": "metta_vspace.extra_pytests.neurospace",
        "documentation": {}
    },
    {
        "label": "NumpyValue",
        "kind": 6,
        "importPath": "metta_vspace.extra_pytests.numme",
        "description": "metta_vspace.extra_pytests.numme",
        "peekOfCode": "class NumpyValue(MatchableObject):\n    def __eq__(self, other):\n        return isinstance(other, NumpyValue) and\\\n               (self.content.shape == other.content.shape) and\\\n               (self.content == other.content).all()\n    def match_(self, other):\n        sh = self.content.shape\n        bindings = {}\n        if isinstance(other, GroundedAtom):\n            other = other.get_object()",
        "detail": "metta_vspace.extra_pytests.numme",
        "documentation": {}
    },
    {
        "label": "PatternValue",
        "kind": 6,
        "importPath": "metta_vspace.extra_pytests.numme",
        "description": "metta_vspace.extra_pytests.numme",
        "peekOfCode": "class PatternValue(MatchableObject):\n    def match_(self, other):\n        if isinstance(other, GroundedAtom):\n            other = other.get_object().content\n        if not isinstance(other, PatternValue):\n            return other.match_(self)\n        # TODO: match to patterns\n        return []\nclass PatternOperation(OperationObject):\n    def __init__(self, name, op, unwrap=False, rec=False):",
        "detail": "metta_vspace.extra_pytests.numme",
        "documentation": {}
    },
    {
        "label": "PatternOperation",
        "kind": 6,
        "importPath": "metta_vspace.extra_pytests.numme",
        "description": "metta_vspace.extra_pytests.numme",
        "peekOfCode": "class PatternOperation(OperationObject):\n    def __init__(self, name, op, unwrap=False, rec=False):\n        super().__init__(name, op, unwrap)\n        self.rec = rec\n    def execute(self, *args, res_typ=AtomType.UNDEFINED):\n        if self.rec:\n            args = args[0].get_children()\n            args = [self.execute(arg)[0]\\\n                if isinstance(arg, ExpressionAtom) else arg for arg in args]\n        # If there is a variable or PatternValue in arguments, create PatternValue",
        "detail": "metta_vspace.extra_pytests.numme",
        "documentation": {}
    },
    {
        "label": "wrapnpop",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.numme",
        "description": "metta_vspace.extra_pytests.numme",
        "peekOfCode": "def wrapnpop(func):\n    def wrapper(*args):\n        a = [arg.get_object().value for arg in args]\n        res = func(*a)\n        typ = _np_atom_type(res)\n        return [G(NumpyValue(res), typ)]\n    return wrapper\n@register_atoms\ndef numme_atoms():\n    # FIXME: we don't add types for operations, because numpy operations types",
        "detail": "metta_vspace.extra_pytests.numme",
        "documentation": {}
    },
    {
        "label": "numme_atoms",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.numme",
        "description": "metta_vspace.extra_pytests.numme",
        "peekOfCode": "def numme_atoms():\n    # FIXME: we don't add types for operations, because numpy operations types\n    # are too loose\n    nmVectorAtom = G(PatternOperation('np.vector', wrapnpop(lambda *args: np.array(args)), unwrap=False))\n    nmArrayAtom = G(PatternOperation('np.array', wrapnpop(lambda *args: np.array(args)), unwrap=False, rec=True))\n    nmAddAtom = G(PatternOperation('np.add', wrapnpop(np.add), unwrap=False))\n    nmSubAtom = G(PatternOperation('np.sub', wrapnpop(np.subtract), unwrap=False))\n    nmMulAtom = G(PatternOperation('np.mul', wrapnpop(np.multiply), unwrap=False))\n    nmDivAtom = G(PatternOperation('np.div', wrapnpop(np.divide), unwrap=False))\n    nmMMulAtom = G(PatternOperation('np.matmul', wrapnpop(np.matmul), unwrap=False))",
        "detail": "metta_vspace.extra_pytests.numme",
        "documentation": {}
    },
    {
        "label": "MeTTaC",
        "kind": 6,
        "importPath": "metta_vspace.extra_pytests.r",
        "description": "metta_vspace.extra_pytests.r",
        "peekOfCode": "class MeTTaC(MeTTa):\n    def copy(self):\n        return self\n@register_atoms\ndef my_imported_runner_atom():\n    # We don't use metta here, but we could...\n    content = '''\n        (: fact (-> Number Number))\n        (= (fact $x)\n           (case $x",
        "detail": "metta_vspace.extra_pytests.r",
        "documentation": {}
    },
    {
        "label": "my_imported_runner_atom",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.r",
        "description": "metta_vspace.extra_pytests.r",
        "peekOfCode": "def my_imported_runner_atom():\n    # We don't use metta here, but we could...\n    content = '''\n        (: fact (-> Number Number))\n        (= (fact $x)\n           (case $x\n            ((0 1)\n             ($_ (* $x (fact (- $x 1)))))\n           )\n        )",
        "detail": "metta_vspace.extra_pytests.r",
        "documentation": {}
    },
    {
        "label": "my_resolver_atoms",
        "kind": 2,
        "importPath": "metta_vspace.extra_pytests.resolve",
        "description": "metta_vspace.extra_pytests.resolve",
        "peekOfCode": "def my_resolver_atoms(metta):\n    def run_resolved_symbol_op(runner, atom, *args):\n        expr = E(atom, *args)\n        result = hp.metta_evaluate_atom(runner.cmetta, expr.catom)\n        result = [Atom._from_catom(catom) for catom in result]\n        return result\n    def resolve_atom(metta, token):\n        # TODO: nested modules...\n        runner_name, atom_name = token.split('::')\n        # FIXME: using `run` for this is an overkill,",
        "detail": "metta_vspace.extra_pytests.resolve",
        "documentation": {}
    },
    {
        "label": "ChatGptDriver",
        "kind": 6,
        "importPath": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "description": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "peekOfCode": "class ChatGptDriver:\n    '''\n    An unofficial Python wrapper for OpenAI's ChatGPT API\n    '''\n    def __init__(\n        self,\n        session_token: str = None,\n        conversation_id: str = '',\n        auth_type: str = None,\n        email: str = None,",
        "detail": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "documentation": {}
    },
    {
        "label": "cf_challenge_form",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "description": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "peekOfCode": "cf_challenge_form = (By.ID, 'challenge-form')\nchatgpt_textbox = (By.TAG_NAME, 'textarea')\nchatgpt_streaming = (By.CLASS_NAME, 'result-streaming')\nchatgpt_big_response = (By.XPATH, '//div[@class=\"flex-1 overflow-hidden\"]//div[p]')\nchatgpt_small_response = (\n    By.XPATH,\n    '//div[starts-with(@class, \"markdown prose w-full break-words\")]',\n)\nchatgpt_alert = (By.XPATH, '//div[@role=\"alert\"]')\nchatgpt_dialog = (By.XPATH, '//div[@role=\"dialog\"]')",
        "detail": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "documentation": {}
    },
    {
        "label": "chatgpt_textbox",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "description": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "peekOfCode": "chatgpt_textbox = (By.TAG_NAME, 'textarea')\nchatgpt_streaming = (By.CLASS_NAME, 'result-streaming')\nchatgpt_big_response = (By.XPATH, '//div[@class=\"flex-1 overflow-hidden\"]//div[p]')\nchatgpt_small_response = (\n    By.XPATH,\n    '//div[starts-with(@class, \"markdown prose w-full break-words\")]',\n)\nchatgpt_alert = (By.XPATH, '//div[@role=\"alert\"]')\nchatgpt_dialog = (By.XPATH, '//div[@role=\"dialog\"]')\nchatgpt_intro = (By.ID, 'headlessui-portal-root')",
        "detail": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "documentation": {}
    },
    {
        "label": "chatgpt_streaming",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "description": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "peekOfCode": "chatgpt_streaming = (By.CLASS_NAME, 'result-streaming')\nchatgpt_big_response = (By.XPATH, '//div[@class=\"flex-1 overflow-hidden\"]//div[p]')\nchatgpt_small_response = (\n    By.XPATH,\n    '//div[starts-with(@class, \"markdown prose w-full break-words\")]',\n)\nchatgpt_alert = (By.XPATH, '//div[@role=\"alert\"]')\nchatgpt_dialog = (By.XPATH, '//div[@role=\"dialog\"]')\nchatgpt_intro = (By.ID, 'headlessui-portal-root')\nchatgpt_login_btn = (By.XPATH, '//button[text()=\"Log in\"]')",
        "detail": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "documentation": {}
    },
    {
        "label": "chatgpt_big_response",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "description": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "peekOfCode": "chatgpt_big_response = (By.XPATH, '//div[@class=\"flex-1 overflow-hidden\"]//div[p]')\nchatgpt_small_response = (\n    By.XPATH,\n    '//div[starts-with(@class, \"markdown prose w-full break-words\")]',\n)\nchatgpt_alert = (By.XPATH, '//div[@role=\"alert\"]')\nchatgpt_dialog = (By.XPATH, '//div[@role=\"dialog\"]')\nchatgpt_intro = (By.ID, 'headlessui-portal-root')\nchatgpt_login_btn = (By.XPATH, '//button[text()=\"Log in\"]')\nchatgpt_login_h1 = (By.XPATH, '//h1[text()=\"Welcome back\"]')",
        "detail": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "documentation": {}
    },
    {
        "label": "chatgpt_small_response",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "description": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "peekOfCode": "chatgpt_small_response = (\n    By.XPATH,\n    '//div[starts-with(@class, \"markdown prose w-full break-words\")]',\n)\nchatgpt_alert = (By.XPATH, '//div[@role=\"alert\"]')\nchatgpt_dialog = (By.XPATH, '//div[@role=\"dialog\"]')\nchatgpt_intro = (By.ID, 'headlessui-portal-root')\nchatgpt_login_btn = (By.XPATH, '//button[text()=\"Log in\"]')\nchatgpt_login_h1 = (By.XPATH, '//h1[text()=\"Welcome back\"]')\nchatgpt_logged_h1 = (By.XPATH, '//h1[text()=\"ChatGPT\"]')",
        "detail": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "documentation": {}
    },
    {
        "label": "chatgpt_alert",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "description": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "peekOfCode": "chatgpt_alert = (By.XPATH, '//div[@role=\"alert\"]')\nchatgpt_dialog = (By.XPATH, '//div[@role=\"dialog\"]')\nchatgpt_intro = (By.ID, 'headlessui-portal-root')\nchatgpt_login_btn = (By.XPATH, '//button[text()=\"Log in\"]')\nchatgpt_login_h1 = (By.XPATH, '//h1[text()=\"Welcome back\"]')\nchatgpt_logged_h1 = (By.XPATH, '//h1[text()=\"ChatGPT\"]')\nchatgpt_new_chat = (By.LINK_TEXT, 'New chat')\nchatgpt_clear_convo = (By.LINK_TEXT, 'Clear conversations')\nchatgpt_confirm_clear_convo = (By.LINK_TEXT, 'Confirm clear conversations')\nchatgpt_chats_list_first_node = (",
        "detail": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "documentation": {}
    },
    {
        "label": "chatgpt_dialog",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "description": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "peekOfCode": "chatgpt_dialog = (By.XPATH, '//div[@role=\"dialog\"]')\nchatgpt_intro = (By.ID, 'headlessui-portal-root')\nchatgpt_login_btn = (By.XPATH, '//button[text()=\"Log in\"]')\nchatgpt_login_h1 = (By.XPATH, '//h1[text()=\"Welcome back\"]')\nchatgpt_logged_h1 = (By.XPATH, '//h1[text()=\"ChatGPT\"]')\nchatgpt_new_chat = (By.LINK_TEXT, 'New chat')\nchatgpt_clear_convo = (By.LINK_TEXT, 'Clear conversations')\nchatgpt_confirm_clear_convo = (By.LINK_TEXT, 'Confirm clear conversations')\nchatgpt_chats_list_first_node = (\n    By.XPATH,",
        "detail": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "documentation": {}
    },
    {
        "label": "chatgpt_intro",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "description": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "peekOfCode": "chatgpt_intro = (By.ID, 'headlessui-portal-root')\nchatgpt_login_btn = (By.XPATH, '//button[text()=\"Log in\"]')\nchatgpt_login_h1 = (By.XPATH, '//h1[text()=\"Welcome back\"]')\nchatgpt_logged_h1 = (By.XPATH, '//h1[text()=\"ChatGPT\"]')\nchatgpt_new_chat = (By.LINK_TEXT, 'New chat')\nchatgpt_clear_convo = (By.LINK_TEXT, 'Clear conversations')\nchatgpt_confirm_clear_convo = (By.LINK_TEXT, 'Confirm clear conversations')\nchatgpt_chats_list_first_node = (\n    By.XPATH,\n    \"//li[@class='relative z-[15]']//a\",",
        "detail": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "documentation": {}
    },
    {
        "label": "chatgpt_login_btn",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "description": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "peekOfCode": "chatgpt_login_btn = (By.XPATH, '//button[text()=\"Log in\"]')\nchatgpt_login_h1 = (By.XPATH, '//h1[text()=\"Welcome back\"]')\nchatgpt_logged_h1 = (By.XPATH, '//h1[text()=\"ChatGPT\"]')\nchatgpt_new_chat = (By.LINK_TEXT, 'New chat')\nchatgpt_clear_convo = (By.LINK_TEXT, 'Clear conversations')\nchatgpt_confirm_clear_convo = (By.LINK_TEXT, 'Confirm clear conversations')\nchatgpt_chats_list_first_node = (\n    By.XPATH,\n    \"//li[@class='relative z-[15]']//a\",\n)",
        "detail": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "documentation": {}
    },
    {
        "label": "chatgpt_login_h1",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "description": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "peekOfCode": "chatgpt_login_h1 = (By.XPATH, '//h1[text()=\"Welcome back\"]')\nchatgpt_logged_h1 = (By.XPATH, '//h1[text()=\"ChatGPT\"]')\nchatgpt_new_chat = (By.LINK_TEXT, 'New chat')\nchatgpt_clear_convo = (By.LINK_TEXT, 'Clear conversations')\nchatgpt_confirm_clear_convo = (By.LINK_TEXT, 'Confirm clear conversations')\nchatgpt_chats_list_first_node = (\n    By.XPATH,\n    \"//li[@class='relative z-[15]']//a\",\n)\nregenerate_response = (By.XPATH, \"//*[.//div[contains(text(), 'Regenerate')]]\")",
        "detail": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "documentation": {}
    },
    {
        "label": "chatgpt_logged_h1",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "description": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "peekOfCode": "chatgpt_logged_h1 = (By.XPATH, '//h1[text()=\"ChatGPT\"]')\nchatgpt_new_chat = (By.LINK_TEXT, 'New chat')\nchatgpt_clear_convo = (By.LINK_TEXT, 'Clear conversations')\nchatgpt_confirm_clear_convo = (By.LINK_TEXT, 'Confirm clear conversations')\nchatgpt_chats_list_first_node = (\n    By.XPATH,\n    \"//li[@class='relative z-[15]']//a\",\n)\nregenerate_response = (By.XPATH, \"//*[.//div[contains(text(), 'Regenerate')]]\")\nclass ChatGptDriver:",
        "detail": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "documentation": {}
    },
    {
        "label": "chatgpt_new_chat",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "description": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "peekOfCode": "chatgpt_new_chat = (By.LINK_TEXT, 'New chat')\nchatgpt_clear_convo = (By.LINK_TEXT, 'Clear conversations')\nchatgpt_confirm_clear_convo = (By.LINK_TEXT, 'Confirm clear conversations')\nchatgpt_chats_list_first_node = (\n    By.XPATH,\n    \"//li[@class='relative z-[15]']//a\",\n)\nregenerate_response = (By.XPATH, \"//*[.//div[contains(text(), 'Regenerate')]]\")\nclass ChatGptDriver:\n    '''",
        "detail": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "documentation": {}
    },
    {
        "label": "chatgpt_clear_convo",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "description": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "peekOfCode": "chatgpt_clear_convo = (By.LINK_TEXT, 'Clear conversations')\nchatgpt_confirm_clear_convo = (By.LINK_TEXT, 'Confirm clear conversations')\nchatgpt_chats_list_first_node = (\n    By.XPATH,\n    \"//li[@class='relative z-[15]']//a\",\n)\nregenerate_response = (By.XPATH, \"//*[.//div[contains(text(), 'Regenerate')]]\")\nclass ChatGptDriver:\n    '''\n    An unofficial Python wrapper for OpenAI's ChatGPT API",
        "detail": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "documentation": {}
    },
    {
        "label": "chatgpt_confirm_clear_convo",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "description": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "peekOfCode": "chatgpt_confirm_clear_convo = (By.LINK_TEXT, 'Confirm clear conversations')\nchatgpt_chats_list_first_node = (\n    By.XPATH,\n    \"//li[@class='relative z-[15]']//a\",\n)\nregenerate_response = (By.XPATH, \"//*[.//div[contains(text(), 'Regenerate')]]\")\nclass ChatGptDriver:\n    '''\n    An unofficial Python wrapper for OpenAI's ChatGPT API\n    '''",
        "detail": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "documentation": {}
    },
    {
        "label": "chatgpt_chats_list_first_node",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "description": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "peekOfCode": "chatgpt_chats_list_first_node = (\n    By.XPATH,\n    \"//li[@class='relative z-[15]']//a\",\n)\nregenerate_response = (By.XPATH, \"//*[.//div[contains(text(), 'Regenerate')]]\")\nclass ChatGptDriver:\n    '''\n    An unofficial Python wrapper for OpenAI's ChatGPT API\n    '''\n    def __init__(",
        "detail": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "documentation": {}
    },
    {
        "label": "regenerate_response",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "description": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "peekOfCode": "regenerate_response = (By.XPATH, \"//*[.//div[contains(text(), 'Regenerate')]]\")\nclass ChatGptDriver:\n    '''\n    An unofficial Python wrapper for OpenAI's ChatGPT API\n    '''\n    def __init__(\n        self,\n        session_token: str = None,\n        conversation_id: str = '',\n        auth_type: str = None,",
        "detail": "metta_vspace.gpt4-openai-api.gpt4_openai.driver",
        "documentation": {}
    },
    {
        "label": "llm",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.test.test",
        "description": "metta_vspace.gpt4-openai-api.test.test",
        "peekOfCode": "llm = GPT4OpenAI(token=os.environ[\"OPENAI_SESSION_TOKEN\"], headless=False, model='gpt-4')\n# GPT3.5 will answer 8, while GPT4 should be smart enough to answer 10\nresponse = llm('If there are 10 books in a room and I read 2, how many books are still in the room?')\nprint(response)\nllm.close()",
        "detail": "metta_vspace.gpt4-openai-api.test.test",
        "documentation": {}
    },
    {
        "label": "response",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.test.test",
        "description": "metta_vspace.gpt4-openai-api.test.test",
        "peekOfCode": "response = llm('If there are 10 books in a room and I read 2, how many books are still in the room?')\nprint(response)\nllm.close()",
        "detail": "metta_vspace.gpt4-openai-api.test.test",
        "documentation": {}
    },
    {
        "label": "llm",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.test.test_browsing",
        "description": "metta_vspace.gpt4-openai-api.test.test_browsing",
        "peekOfCode": "llm = GPT4OpenAI(token=os.environ[\"OPENAI_SESSION_TOKEN\"],\n                 headless=False, model='gpt-4')\nresponse = llm('What is the age difference between Dua Lipa and her boyfriend?')\nprint(response)",
        "detail": "metta_vspace.gpt4-openai-api.test.test_browsing",
        "documentation": {}
    },
    {
        "label": "response",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.test.test_browsing",
        "description": "metta_vspace.gpt4-openai-api.test.test_browsing",
        "peekOfCode": "response = llm('What is the age difference between Dua Lipa and her boyfriend?')\nprint(response)",
        "detail": "metta_vspace.gpt4-openai-api.test.test_browsing",
        "documentation": {}
    },
    {
        "label": "llm",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.test.test_code_interpretter",
        "description": "metta_vspace.gpt4-openai-api.test.test_code_interpretter",
        "peekOfCode": "llm = GPT4OpenAI(token=os.environ[\"OPENAI_SESSION_TOKEN\"],\n                headless=True,\n                # Either \"text-davinci-002-render-sha\" (GPT-3.5), \"gpt-4\", or \"gpt-4-plugins\"\n                model='gpt-4')\nresponse = llm('What are all prime numbers between 1 and 200?')\nprint(response)\nllm.close()",
        "detail": "metta_vspace.gpt4-openai-api.test.test_code_interpretter",
        "documentation": {}
    },
    {
        "label": "response",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.test.test_code_interpretter",
        "description": "metta_vspace.gpt4-openai-api.test.test_code_interpretter",
        "peekOfCode": "response = llm('What are all prime numbers between 1 and 200?')\nprint(response)\nllm.close()",
        "detail": "metta_vspace.gpt4-openai-api.test.test_code_interpretter",
        "documentation": {}
    },
    {
        "label": "llm",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.test.test_continue_generating",
        "description": "metta_vspace.gpt4-openai-api.test.test_continue_generating",
        "peekOfCode": "llm = GPT4OpenAI(token=os.environ[\"OPENAI_SESSION_TOKEN\"], model='gpt-4', auto_continue=True, headless=False)\nprompt = \"\"\"\nPlease write a detailed and comprehensive guide to developing a small business, starting from a business idea and\ngoing through all the necessary steps, such as writing a business plan, choosing a legal structure, obtaining financing,\nchoosing a location, setting up your workspace, recruiting and hiring employees, developing products and services,\nmarketing, sales, customer service, accounting and bookkeeping, reviewing business performance, and finally planning for\ngrowth and expansion. Be sure to include examples, tips, and potential pitfalls to watch out for along the way.\n\"\"\"\nresponse = llm(prompt)\n# GPT4 should now return all 15 different steps of the business plan, one by one",
        "detail": "metta_vspace.gpt4-openai-api.test.test_continue_generating",
        "documentation": {}
    },
    {
        "label": "prompt",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.test.test_continue_generating",
        "description": "metta_vspace.gpt4-openai-api.test.test_continue_generating",
        "peekOfCode": "prompt = \"\"\"\nPlease write a detailed and comprehensive guide to developing a small business, starting from a business idea and\ngoing through all the necessary steps, such as writing a business plan, choosing a legal structure, obtaining financing,\nchoosing a location, setting up your workspace, recruiting and hiring employees, developing products and services,\nmarketing, sales, customer service, accounting and bookkeeping, reviewing business performance, and finally planning for\ngrowth and expansion. Be sure to include examples, tips, and potential pitfalls to watch out for along the way.\n\"\"\"\nresponse = llm(prompt)\n# GPT4 should now return all 15 different steps of the business plan, one by one\nprint(response)",
        "detail": "metta_vspace.gpt4-openai-api.test.test_continue_generating",
        "documentation": {}
    },
    {
        "label": "response",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.test.test_continue_generating",
        "description": "metta_vspace.gpt4-openai-api.test.test_continue_generating",
        "peekOfCode": "response = llm(prompt)\n# GPT4 should now return all 15 different steps of the business plan, one by one\nprint(response)\nllm.close()",
        "detail": "metta_vspace.gpt4-openai-api.test.test_continue_generating",
        "documentation": {}
    },
    {
        "label": "llm",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.test.test_dalle3",
        "description": "metta_vspace.gpt4-openai-api.test.test_dalle3",
        "peekOfCode": "llm = GPT4OpenAI(token=os.environ[\"OPENAI_SESSION_TOKEN\"],\n                headless=False,\n                model='gpt-4' # DALL-E 3 only works with gpt-4\n                )\nbytes = llm.generate_image('Generate an isometric image of a cute doggo inside a house.', image_path = './optional_path.png')\n# Convert image bytes to numpy array\nimg = cv2.imdecode(np.frombuffer(bytes, np.uint8), -1)\ncv2.imshow('image', img)\ncv2.waitKey(0)\nllm.close()",
        "detail": "metta_vspace.gpt4-openai-api.test.test_dalle3",
        "documentation": {}
    },
    {
        "label": "bytes",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.test.test_dalle3",
        "description": "metta_vspace.gpt4-openai-api.test.test_dalle3",
        "peekOfCode": "bytes = llm.generate_image('Generate an isometric image of a cute doggo inside a house.', image_path = './optional_path.png')\n# Convert image bytes to numpy array\nimg = cv2.imdecode(np.frombuffer(bytes, np.uint8), -1)\ncv2.imshow('image', img)\ncv2.waitKey(0)\nllm.close()",
        "detail": "metta_vspace.gpt4-openai-api.test.test_dalle3",
        "documentation": {}
    },
    {
        "label": "img",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.test.test_dalle3",
        "description": "metta_vspace.gpt4-openai-api.test.test_dalle3",
        "peekOfCode": "img = cv2.imdecode(np.frombuffer(bytes, np.uint8), -1)\ncv2.imshow('image', img)\ncv2.waitKey(0)\nllm.close()",
        "detail": "metta_vspace.gpt4-openai-api.test.test_dalle3",
        "documentation": {}
    },
    {
        "label": "system_message_prompt",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.test.test_langchain",
        "description": "metta_vspace.gpt4-openai-api.test.test_langchain",
        "peekOfCode": "system_message_prompt = SystemMessagePromptTemplate.from_template(template)\nexample_human = HumanMessagePromptTemplate.from_template(\"Hi\")\nexample_ai = AIMessagePromptTemplate.from_template(\"Argh me mateys\")\nhuman_message_prompt = HumanMessagePromptTemplate.from_template(\"{text}\")\nchat_prompt = ChatPromptTemplate.from_messages([system_message_prompt, example_human, example_ai, human_message_prompt])\n# Token is the __Secure-next-auth.session-token from chat.openai.com\nllm = GPT4OpenAI(token=os.environ[\"OPENAI_SESSION_TOKEN\"], headless=False)\nchain = LLMChain(llm=llm, prompt=chat_prompt)\nprint(chain.run(\"My name is John and I like to eat pizza.\"))\nllm.close()",
        "detail": "metta_vspace.gpt4-openai-api.test.test_langchain",
        "documentation": {}
    },
    {
        "label": "example_human",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.test.test_langchain",
        "description": "metta_vspace.gpt4-openai-api.test.test_langchain",
        "peekOfCode": "example_human = HumanMessagePromptTemplate.from_template(\"Hi\")\nexample_ai = AIMessagePromptTemplate.from_template(\"Argh me mateys\")\nhuman_message_prompt = HumanMessagePromptTemplate.from_template(\"{text}\")\nchat_prompt = ChatPromptTemplate.from_messages([system_message_prompt, example_human, example_ai, human_message_prompt])\n# Token is the __Secure-next-auth.session-token from chat.openai.com\nllm = GPT4OpenAI(token=os.environ[\"OPENAI_SESSION_TOKEN\"], headless=False)\nchain = LLMChain(llm=llm, prompt=chat_prompt)\nprint(chain.run(\"My name is John and I like to eat pizza.\"))\nllm.close()",
        "detail": "metta_vspace.gpt4-openai-api.test.test_langchain",
        "documentation": {}
    },
    {
        "label": "example_ai",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.test.test_langchain",
        "description": "metta_vspace.gpt4-openai-api.test.test_langchain",
        "peekOfCode": "example_ai = AIMessagePromptTemplate.from_template(\"Argh me mateys\")\nhuman_message_prompt = HumanMessagePromptTemplate.from_template(\"{text}\")\nchat_prompt = ChatPromptTemplate.from_messages([system_message_prompt, example_human, example_ai, human_message_prompt])\n# Token is the __Secure-next-auth.session-token from chat.openai.com\nllm = GPT4OpenAI(token=os.environ[\"OPENAI_SESSION_TOKEN\"], headless=False)\nchain = LLMChain(llm=llm, prompt=chat_prompt)\nprint(chain.run(\"My name is John and I like to eat pizza.\"))\nllm.close()",
        "detail": "metta_vspace.gpt4-openai-api.test.test_langchain",
        "documentation": {}
    },
    {
        "label": "human_message_prompt",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.test.test_langchain",
        "description": "metta_vspace.gpt4-openai-api.test.test_langchain",
        "peekOfCode": "human_message_prompt = HumanMessagePromptTemplate.from_template(\"{text}\")\nchat_prompt = ChatPromptTemplate.from_messages([system_message_prompt, example_human, example_ai, human_message_prompt])\n# Token is the __Secure-next-auth.session-token from chat.openai.com\nllm = GPT4OpenAI(token=os.environ[\"OPENAI_SESSION_TOKEN\"], headless=False)\nchain = LLMChain(llm=llm, prompt=chat_prompt)\nprint(chain.run(\"My name is John and I like to eat pizza.\"))\nllm.close()",
        "detail": "metta_vspace.gpt4-openai-api.test.test_langchain",
        "documentation": {}
    },
    {
        "label": "chat_prompt",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.test.test_langchain",
        "description": "metta_vspace.gpt4-openai-api.test.test_langchain",
        "peekOfCode": "chat_prompt = ChatPromptTemplate.from_messages([system_message_prompt, example_human, example_ai, human_message_prompt])\n# Token is the __Secure-next-auth.session-token from chat.openai.com\nllm = GPT4OpenAI(token=os.environ[\"OPENAI_SESSION_TOKEN\"], headless=False)\nchain = LLMChain(llm=llm, prompt=chat_prompt)\nprint(chain.run(\"My name is John and I like to eat pizza.\"))\nllm.close()",
        "detail": "metta_vspace.gpt4-openai-api.test.test_langchain",
        "documentation": {}
    },
    {
        "label": "llm",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.test.test_langchain",
        "description": "metta_vspace.gpt4-openai-api.test.test_langchain",
        "peekOfCode": "llm = GPT4OpenAI(token=os.environ[\"OPENAI_SESSION_TOKEN\"], headless=False)\nchain = LLMChain(llm=llm, prompt=chat_prompt)\nprint(chain.run(\"My name is John and I like to eat pizza.\"))\nllm.close()",
        "detail": "metta_vspace.gpt4-openai-api.test.test_langchain",
        "documentation": {}
    },
    {
        "label": "chain",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.test.test_langchain",
        "description": "metta_vspace.gpt4-openai-api.test.test_langchain",
        "peekOfCode": "chain = LLMChain(llm=llm, prompt=chat_prompt)\nprint(chain.run(\"My name is John and I like to eat pizza.\"))\nllm.close()",
        "detail": "metta_vspace.gpt4-openai-api.test.test_langchain",
        "documentation": {}
    },
    {
        "label": "root",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.setup",
        "description": "metta_vspace.gpt4-openai-api.setup",
        "peekOfCode": "root = Path(__file__).parent.resolve()\nreadme_file = root / 'readme.md'\nlong_description = readme_file.read_text(encoding='utf-8')\nsetup(\n    name=\"gpt4-openai-api\",\n    version=\"0.9.0\",\n    description=\"Python package for unofficial GPT-4 API access via chat.openai.com using Chrome browser via Selenium\",\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n    author=\"Erol444\",",
        "detail": "metta_vspace.gpt4-openai-api.setup",
        "documentation": {}
    },
    {
        "label": "readme_file",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.setup",
        "description": "metta_vspace.gpt4-openai-api.setup",
        "peekOfCode": "readme_file = root / 'readme.md'\nlong_description = readme_file.read_text(encoding='utf-8')\nsetup(\n    name=\"gpt4-openai-api\",\n    version=\"0.9.0\",\n    description=\"Python package for unofficial GPT-4 API access via chat.openai.com using Chrome browser via Selenium\",\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n    author=\"Erol444\",\n    author_email=\"erol123444@gmail.com\",",
        "detail": "metta_vspace.gpt4-openai-api.setup",
        "documentation": {}
    },
    {
        "label": "long_description",
        "kind": 5,
        "importPath": "metta_vspace.gpt4-openai-api.setup",
        "description": "metta_vspace.gpt4-openai-api.setup",
        "peekOfCode": "long_description = readme_file.read_text(encoding='utf-8')\nsetup(\n    name=\"gpt4-openai-api\",\n    version=\"0.9.0\",\n    description=\"Python package for unofficial GPT-4 API access via chat.openai.com using Chrome browser via Selenium\",\n    long_description=long_description,\n    long_description_content_type='text/markdown',\n    author=\"Erol444\",\n    author_email=\"erol123444@gmail.com\",\n    url=\"https://github.com/Erol444/gpt4-openai-api\",",
        "detail": "metta_vspace.gpt4-openai-api.setup",
        "documentation": {}
    },
    {
        "label": "test_longchain",
        "kind": 2,
        "importPath": "metta_vspace.chat_gpt_webapi",
        "description": "metta_vspace.chat_gpt_webapi",
        "peekOfCode": "def test_longchain():\n    from langchain import LLMChain  # pip install langchain[chains]\n    from langchain import (ChatPromptTemplate, SystemMessagePromptTemplate, AIMessagePromptTemplate, HumanMessagePromptTemplate)\n    template=\"You are a helpful assistant that translates english to KIF.\"\n    system_message_prompt = SystemMessagePromptTemplate.from_template(template)\n    example_human = HumanMessagePromptTemplate.from_template(\"Fido is a Dog\")\n    example_ai = AIMessagePromptTemplate.from_template(\"(instance-of Fido Dog)\")\n    human_message_prompt = HumanMessagePromptTemplate.from_template(\"{text}\")\n    chat_prompt = ChatPromptTemplate.from_messages([system_message_prompt, example_human, example_ai, human_message_prompt])\n    # Token is the __Secure-next-auth.session-token from chat.openai.com",
        "detail": "metta_vspace.chat_gpt_webapi",
        "documentation": {}
    },
    {
        "label": "main_test",
        "kind": 2,
        "importPath": "metta_vspace.chat_gpt_webapi",
        "description": "metta_vspace.chat_gpt_webapi",
        "peekOfCode": "def main_test():\n    llm = GPT4OpenAI(token=os.environ[\"OPENAI_SESSION_TOKEN\"], headless=False, model='gpt-4')\n    # GPT3.5 will answer 8, while GPT4 should be smart enough to answer 10\n    response = llm('If there are 10 books in a room and I read 2, how many books are still in the room?')\n    print(response)\n    llm.close()\nif __name__ == \"__main__\":\n    main_test()\n    test_longchain()",
        "detail": "metta_vspace.chat_gpt_webapi",
        "documentation": {}
    },
    {
        "label": "my_session_token",
        "kind": 5,
        "importPath": "metta_vspace.chat_gpt_webapi",
        "description": "metta_vspace.chat_gpt_webapi",
        "peekOfCode": "my_session_token = os.environ[\"OPENAI_SESSION_TOKEN\"]\nif my_session_token is None:\n    os.environ[\"OPENAI_SESSION_TOKEN\"] = \"eyJhbGciOiJkaXIiLCJlbmMiOiJBMjU2R0NNIn0..yHSeSng67bEvv6PF.AFzdgn_wRGfiLiXiJpGih15IWLPGtrpseHInprQR2fDVMFDC5Eiqx_jwLAv69ChVGBe5AHVeKUuVIKeUoud1HBwl9hKCOJqlzGG1dtySFarPY35RZ-d5tyGfjz8HBepDlxST1kov-vpSN3Ihua2bLXOwkmKq7OKMPUT13M2hyAH8SMurIV36d2gDKLluoU87zDxxi9eKHxEiOU1_Osgg4WbrkeZXVpJtFWzzODg4VfKE1WjT_ERIF2dpsVIZewoHtH14SPTBiZL8refn4NqnMmgr5qWH3ZLvlImzv6m0imNtwFFifM39j3i552AZPXkfTvV3DMSYyEHKU2bkT0rUqRxXnSTA3MhWZAR-4gIcWtRlZcc4Qx4xblJse4X8HJT1N8ccm92QJHUn3-r19LUUWuDsKYn1H3TNnsxKJVmKOhf_W-F04tuAcHxx7eBT6w43Z1apX8Wz0EaV7Eu9ogpXwbgk_6WvK3deX52YcjrRSwpMM7nVvGf-PxfiEiuMZwU3B0E7-Iu4PyqzmVyO52_Kepo9Ll4psKADV9Cz3jQNrfOEKX7rANCsckzXZ79XdAEg1ymBFCDf-_O_SBZFJ7Nnoyet88JHVb4VaOCoOJJ0TWp5sXS4E6PKzrnpovHFn2L_iBYpNXiOAXS_WLUmHuCnjiZuLh5ziwrUXPmXKs2DiK4G6U8FSlTpZeOE9qW4eXhmUgQKRuzEGlT4jwI23GlGEL2nq5aRTS1C0jVR2ZO9al5Un-3SltN6-7Om63OQ0U9tAmgNsrp3a6z7IP_9ZPM4wxkhShHxBxRfWGhZ6KlINByo6_E5e1bSsHCFSHrnDXfIXEgvSu1NNkG2yKTd5vPW7euqp-LdxwIkmmcS0dnBw10MBBROBciMqCantDyemfAkGDfHxn_FF3YCZfumKhr6cQE8c6-EP3AHgMzNNEPxvnoH6K_ojwxRmmx5Ml0gyahFUIyBq00IaYHQGVC_rfJ67za9OsSMKBPAEv1pfKHuWQc_1lETaR8zmyF2ymbh1_qoxKM5-Q-eB7ieyhH6AhlUNOkydLPdGKGNfBA28GQW3ydXYsnFf8vzhxDgKIlAjuBwT0Lq33lCrQ2RFSBZ0oKJvxStRAYVoi2WO49NzkYk8loj6r-s9j0rgh6dKDJq_vf4ZeX3CqajOsHsOnTZL4oRy1nKCF9RnU0cQhx-v37kRSvPNsOGrOdupj-6uIkVSw3e4UogsMKZValBbBq1EddbcHENbkH5NFuzyCswwsZZg1p-9kat_7Jypxu3IqXnDZ4gVXlRSngAUYCZq4kJxZJYlzyaTmswt-eNO02tSDBtowfawbkRUmSpNf6bF5DfrHCXC1kFKp0QJPKcAlnB4woKfDdIE6P3XS5Jfh1_ZHdxSanJCW_Ef3hJ2w1fgpLlrZ8o3KTYBHufEp__Fg5JtW4BbtqmJy8Vi5O6mhQs-pGszQ8wt9o3fus9AJXQTdAgAKfx9ujO8SGrHq0k3BapfC0_ViHd2Ko9t4gl_AtPWWgy8EmLM4MAZB7OqF75vUQJEXDRLh0WidXCTsqJrLSZgUsjeJEG9-zGrxRryDumM-dmYWoXDAibWPaDZXUquueTwU4kEFIfXzsv_K_bmRHl_a2-yVRSFKKHa5lKZn3yeHPWKYvCxBVzAdi_rInZGY0_08KZHPqnHbU5omBjkq17a48RObax7rbL1DdAWvPiPHHM2yfJivOXi8e5m8knXyB_dWKHckgfWsXLJ5FS3ZBjY1QwIlpVUuDTGQoHVzyyuFDTbFPZIQAbeUp8YZdsSqatLppG52Y0EUEJS7iGdw-gFhaCeHWs2NTgZ5MsQgbWV_sETXDrPrRYiR_vGNMmPQsiDJIX5Agso5GQcDbJfRNGBbcdSMBrilb5PbvP8k3SUGgoaHB2bWkZTC4uhrM4O9yo1alDdGFjMk0zZrH70eJbiOhZC3rpEIenc5vvyIO-lsPatBN9SvGGGzqW7mFtY0Mi2fnGU3mQsqCnVVhikwFwDv9Lg5LhM0LDAVwM6APOcmTwShV8fse6onCneGer3zHpk17bPMC5c-e8WXYnRHtaOMcenRK--yHCyInSz_hakS2m0PLZj07s9z8vRdXD1IOk2pYloHEWLFPN0g3en8ajfri4jSsDqh39BjqGKDl3JG0K2OtwpNECpNI2hfiyhp4aYrZk9ocPZdhOCuHfw2nSpk6dH-fLDbbdpdkNJeLbjgjSZuePOis-LQMGQkGlaCd8Z0yhsfsvck4APE_jotLpF5cbL_ntcZXdhf4n0y_h6fDoa77l3Kmsv0Dibql1NbXnu9vVhGkQgM0tXx6-Mg_zGTdoNGc9McSrbvJ5HeOaOR9okxDjJfDshMElvykaNJuJUK6ofrWR2iFiF81XVnxsQ7pX2LnDQhXwKbhdOaQL4Ctx7V_wBJUrcCdKXRW1a9NmZwx4DiG4Jk22Y6hP6d1Rx5KRHQjRdlJ9cxlfOv-JDO2ou9_6Zh42ItfBgsqNOoi0yYLd_bV36jGplAJxKUH8gWV2kM2Boj3BKWUy4OLuwY9QeFK2OI9SKzK0bZk6d4Gn3IZfoQkddJ5s5nFbe0RKoDk_zj2JbjtxYdvV8_bIMwFowF7l4Sot5KRRhdZOjoCQkTngifm1taIZeek5upcinyFRngdETkkzUu3XCyzeIVJP8CzBfJrAH_OHduv0w2Q7_hMFwj44lqimcEpB3hXcGT55DfZW41On51qjnlXdifrq1WktdofArrK2ZovH0M5L1FmmDhRhOtonVpk2HYM2zeMyUAvdcL2GZUex4d1r2kxlGcBl8U3SC3LrxbB_x29ioEWNS7VM8RMtWIniY9bW7nihCuwRvvxCA_2A937CQbed.e5Yevuc43oas5F5i7AyHxw\"\ndef test_longchain():\n    from langchain import LLMChain  # pip install langchain[chains]\n    from langchain import (ChatPromptTemplate, SystemMessagePromptTemplate, AIMessagePromptTemplate, HumanMessagePromptTemplate)\n    template=\"You are a helpful assistant that translates english to KIF.\"\n    system_message_prompt = SystemMessagePromptTemplate.from_template(template)\n    example_human = HumanMessagePromptTemplate.from_template(\"Fido is a Dog\")\n    example_ai = AIMessagePromptTemplate.from_template(\"(instance-of Fido Dog)\")",
        "detail": "metta_vspace.chat_gpt_webapi",
        "documentation": {}
    },
    {
        "label": "setup_and_run_chromedriver",
        "kind": 2,
        "importPath": "metta_vspace.chrome_test",
        "description": "metta_vspace.chrome_test",
        "peekOfCode": "def setup_and_run_chromedriver():\n    import subprocess\n    import shutil\n    # List of required packages\n    required_packages = [\"selenium\",\"undetected-chromedriver\",\"markdownify\"\",langchain\",\"gpt4-openai-api==0.2\"]\n    # Check if each required package is installed, and install it if not\n    for package in required_packages:\n        try:\n            __import__(package)\n        except ImportError:",
        "detail": "metta_vspace.chrome_test",
        "documentation": {}
    },
    {
        "label": "service",
        "kind": 5,
        "importPath": "metta_vspace.chrome_test2",
        "description": "metta_vspace.chrome_test2",
        "peekOfCode": "service = Service('/usr/local/bin/chromedriver')\nservice.start()\ndriver = webdriver.Remote(service.service_url)\ndriver.get('http://www.google.com/');\ntime.sleep(5) # Let the user actually see something!\ndriver.quit()",
        "detail": "metta_vspace.chrome_test2",
        "documentation": {}
    },
    {
        "label": "driver",
        "kind": 5,
        "importPath": "metta_vspace.chrome_test2",
        "description": "metta_vspace.chrome_test2",
        "peekOfCode": "driver = webdriver.Remote(service.service_url)\ndriver.get('http://www.google.com/');\ntime.sleep(5) # Let the user actually see something!\ndriver.quit()",
        "detail": "metta_vspace.chrome_test2",
        "documentation": {}
    },
    {
        "label": "MeTTaKernel",
        "kind": 6,
        "importPath": "metta_vspace.metta_jupyter_kernel",
        "description": "metta_vspace.metta_jupyter_kernel",
        "peekOfCode": "class MeTTaKernel(Kernel):\n    implementation = 'MeTTa'\n    implementation_version = '0.16'\n    language = 'MeTTa'\n    language_version = '0.16'\n    language_info = {\n        'name': 'MeTTa',\n        'codemirror_mode': 'scheme',\n        'mimetype': 'text/plain',\n        'file_extension': '.metta'",
        "detail": "metta_vspace.metta_jupyter_kernel",
        "documentation": {}
    },
    {
        "label": "MeTTaRepl",
        "kind": 6,
        "importPath": "metta_vspace.metta_jupyter_kernel",
        "description": "metta_vspace.metta_jupyter_kernel",
        "peekOfCode": "class MeTTaRepl(MetaKernel):\n    global ENVIRONMENT\n    implementation = 'metta'\n    implementation_version = '0.16'\n    language = 'metta'\n    language_version = '0.16'\n    banner = \"MeTTa %s\" % implementation_version\n    language_info = {\n        'mimetype': 'text/x-metta',\n        'name': 'metta',",
        "detail": "metta_vspace.metta_jupyter_kernel",
        "documentation": {}
    },
    {
        "label": "flush_console",
        "kind": 2,
        "importPath": "metta_vspace.metta_jupyter_kernel",
        "description": "metta_vspace.metta_jupyter_kernel",
        "peekOfCode": "def flush_console():\n    try:\n      sys.stdout.flush()\n    except Exception: \"\"\n    try:\n      sys.stderr.flush()\n    except Exception: \"\"\nclass MeTTaKernel(Kernel):\n    implementation = 'MeTTa'\n    implementation_version = '0.16'",
        "detail": "metta_vspace.metta_jupyter_kernel",
        "documentation": {}
    },
    {
        "label": "latex_matches",
        "kind": 2,
        "importPath": "metta_vspace.metta_jupyter_kernel",
        "description": "metta_vspace.metta_jupyter_kernel",
        "peekOfCode": "def latex_matches(text):\n    \"\"\"\n    Match Latex syntax for unicode characters.\n    After IPython.core.completer\n    \"\"\"\n    slashpos = text.rfind('\\\\')\n    if slashpos > -1:\n        s = text[slashpos:]\n        if s in latex_symbols:\n            # Try to complete a full latex symbol to unicode",
        "detail": "metta_vspace.metta_jupyter_kernel",
        "documentation": {}
    },
    {
        "label": "crlf_pat",
        "kind": 5,
        "importPath": "metta_vspace.metta_jupyter_kernel",
        "description": "metta_vspace.metta_jupyter_kernel",
        "peekOfCode": "crlf_pat = re.compile(r'[\\r\\n]+')\ndef flush_console():\n    try:\n      sys.stdout.flush()\n    except Exception: \"\"\n    try:\n      sys.stderr.flush()\n    except Exception: \"\"\nclass MeTTaKernel(Kernel):\n    implementation = 'MeTTa'",
        "detail": "metta_vspace.metta_jupyter_kernel",
        "documentation": {}
    },
    {
        "label": "PY3",
        "kind": 5,
        "importPath": "metta_vspace.metta_jupyter_kernel",
        "description": "metta_vspace.metta_jupyter_kernel",
        "peekOfCode": "PY3 = (sys.version_info[0] >= 3)\nif PY3:\n    PY_STRINGS = (str,)\nelse:\n    PY_STRINGS = (str, unicode)\nENVIRONMENT = {}\nclass MeTTaRepl(MetaKernel):\n    global ENVIRONMENT\n    implementation = 'metta'\n    implementation_version = '0.16'",
        "detail": "metta_vspace.metta_jupyter_kernel",
        "documentation": {}
    },
    {
        "label": "ENVIRONMENT",
        "kind": 5,
        "importPath": "metta_vspace.metta_jupyter_kernel",
        "description": "metta_vspace.metta_jupyter_kernel",
        "peekOfCode": "ENVIRONMENT = {}\nclass MeTTaRepl(MetaKernel):\n    global ENVIRONMENT\n    implementation = 'metta'\n    implementation_version = '0.16'\n    language = 'metta'\n    language_version = '0.16'\n    banner = \"MeTTa %s\" % implementation_version\n    language_info = {\n        'mimetype': 'text/x-metta',",
        "detail": "metta_vspace.metta_jupyter_kernel",
        "documentation": {}
    },
    {
        "label": "MettaLearner",
        "kind": 6,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "class MettaLearner:\n    \"\"\nclass Circles:\n    def __init__(self, initial_data=None):\n        self.data = {}\n        if initial_data:\n            for key, value in initial_data.items():\n                self.__setitem__(key, value)\n    def _get_key(self, key):\n        try:",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "Circles",
        "kind": 6,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "class Circles:\n    def __init__(self, initial_data=None):\n        self.data = {}\n        if initial_data:\n            for key, value in initial_data.items():\n                self.__setitem__(key, value)\n    def _get_key(self, key):\n        try:\n            hash_key = hash(key)\n            return ('hash', hash_key)",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "VSpaceRef",
        "kind": 6,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "class VSpaceRef(SpaceRef):\n    \"\"\"\n    A reference to a Space, which may be accessed directly, wrapped in a grounded atom,\n    or passed to a MeTTa interpreter.\n    \"\"\"\n    def __init__(self, space_obj):\n        \"\"\"\n        Initialize a new SpaceRef based on the given space object, either a CSpace\n        or a custom Python object.\n        \"\"\"",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "VSpace",
        "kind": 6,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "class VSpace(AbstractSpace):\n    def from_space(self, cspace):\n        self.gspace = GroundingSpaceRef(cspace)\n    def __init__(self, space_name=None, unwrap=False):\n        super().__init__()\n        #addSpaceName(ispace_name,self)\n        if space_name is None:\n            global vspace_ordinal\n            ispace_name = f\"&vspace_{vspace_ordinal}\"\n            vspace_ordinal=vspace_ordinal+1",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "VSpaceCallRust",
        "kind": 6,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "class VSpaceCallRust(VSpace):\n    def __init__(self, space_name=None, unwrap=False):\n        super().__init__()\n    #def eval_in_rust_mettaf():\nclass PySwipQ(Query):\n    def __init__(self, *terms, **kwargs):\n        if verbose > 1:\n            for obj in terms:\n                println(obj)\n        super().__init__(*terms, **kwargs)",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "PySwipQ",
        "kind": 6,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "class PySwipQ(Query):\n    def __init__(self, *terms, **kwargs):\n        if verbose > 1:\n            for obj in terms:\n                println(obj)\n        super().__init__(*terms, **kwargs)\n    def nextSolution(self):\n        return Query.nextSolution()\n        #return PL_next_solution(Query.qid)\n    #nextSolution = staticmethod(nextSolution)",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "FederatedSpace",
        "kind": 6,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "class FederatedSpace(VSpace):\n    def __init__(self, space_name, unwrap=False):\n        super().__init__(space_name, unwrap)\n    def _checked_impl(self, method_name, *args):\n        if access_error:\n            raise Exception(f\"Error in FederatedSpace.{method_name}: Implementation for {method_name}({', '.join(map(str, args))}) is not complete.\")\n        return super()\n    def query(self, query_atom):\n        return self._checked_impl(\"query\", query_atom).query(query_atom)\n    def add(self, atom):",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "VSNumpyValue",
        "kind": 6,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "class VSNumpyValue(MatchableObject):\n    def __eq__(self, metta_obj):\n        return isinstance(metta_obj, VSNumpyValue) and\\\n               (self.content.shape == metta_obj.content.shape) and\\\n               (self.content == metta_obj.content).all()\n    def match_(self, metta_obj):\n        sh = self.content.shape\n        bindings = {}\n        if isinstance(metta_obj, GroundedAtom):\n            metta_obj = metta_obj.get_object()",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "VSPatternValue",
        "kind": 6,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "class VSPatternValue(MatchableObject):\n    def match_(self, orig_metta_obj):\n        metta_obj = orig_metta_obj\n        if isinstance(metta_obj, GroundedAtom):\n            metta_obj = metta_obj.get_object().content\n        #if not isinstance(metta_obj, VSPatternValue):\n        #    return metta_obj.match_(self)\n        # TODO: match to patterns\n        #return []\n        metta_obj = orig_metta_obj",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "VSPatternOperation",
        "kind": 6,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "class VSPatternOperation(OperationObject):\n    def __init__(self, name, op, unwrap=False, rec=False):\n        super().__init__(name, op, unwrap)\n        self.rec = rec\n    def execute(self, *args, res_typ=AtomType.UNDEFINED):\n        print(f\"args={args}\")\n        if self.rec and isinstance(args[0], ExpressionAtom):\n            args = args[0].get_children()\n            args = [self.execute(arg)[0]\\\n                if isinstance(arg, ExpressionAtom) else arg for arg in args]",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "VSpacePatternOperation",
        "kind": 6,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "class VSpacePatternOperation(OperationObject):\n    def __init__(self, name, op, unwrap=False, rec=False):\n        super().__init__(name, op, unwrap)\n        self.rec = rec\n        self._catom = None\n    @property\n    def catom(self):\n        return self.get_catom()\n    @catom.setter\n    def catom(self, value):",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "ExtendedMeTTa",
        "kind": 6,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "class ExtendedMeTTa(MeTTa):\n    def __init__(self, cmetta = None, space = None, env_builder = None):\n        self.pymods = {}\n        if cmetta is not None:\n            self.cmetta = cmetta\n        else:\n            if space is None:\n                space = GroundingSpaceRef()\n            if env_builder is None:\n                env_builder = hp.env_builder_use_default()",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "LazyMeTTa",
        "kind": 6,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "class LazyMeTTa(ExtendedMeTTa):\n    #def __init__(self, space = None, cwd = \".\", cmetta = None):\n    #    super.__init__(space, cwd, cmetta)\n    def lazy_import_file(self, fname):\n        path = fname.split(os.sep)\n        with open(os.sep.join(self.cwd + path), \"r\") as f:\n            program = f.read()\n        self.lazy_run(self._parse_all(program))\n    def lazy_run(self, stream):\n        for i, (expr, result_set) in enumerate(self.lazy_run_loop(stream)):",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "GptSpace",
        "kind": 6,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "class GptSpace(GroundingSpace):\n    def query(self, query_atom):\n        tot_str = \"Answer the question taking into account the following information (each fact is in brackets):\\n\"\n        for atom in self.atoms_iter():\n            tot_str += str(atom) + \"\\n\"\n        tot_str += \"If the question contains letters in brackets with $ sign, for example ($x), provide the answer in the json format in curly brackets, that is { $x: your answer }.\\n\"\n        # tot_str += \"If information is not provided, return the entry to be queried in JSON {unknown value: UNKNOWN}.\"\n        tot_str += \"The question is: \" + str(query_atom)[1:-1] + \"?\"\n        response = openai.ChatCompletion.create(\n                model=\"gpt-3.5-turbo-0613\",",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "GptIntentSpace",
        "kind": 6,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "class GptIntentSpace(GroundingSpace):\n    def query(self, query_atom):\n        tot_str = \"Analyze the topic of the utterance: \" + str(query_atom)[1:-1] + \"\\n\"\n        tot_str += \"Try to pick the most relevant topic from the following list (each topic in brackets):\"\n        for atom in self.atoms_iter():\n            tot_str += str(atom) + \"\\n\"\n        tot_str += \"If neither of the listed topics seems relevant, answer (chit-chat).\"\n        tot_str += \"Provide the answer in the json format in curly brackets in the form { topic: your answer }.\\n\"\n        response = openai.ChatCompletion.create(\n                model=\"gpt-3.5-turbo-0613\",",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "SqlHelper",
        "kind": 6,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "class SqlHelper:\n    colums_word = \"ColumnNames\"\n    insert_command_sql = \"INSERT INTO\"\n    @staticmethod\n    def get_query_atoms(query_atom):\n        children = query_atom.get_children()\n        new_query_atoms = []\n        for ch in children:\n            if 'limit' not in repr(ch).lower():\n                new_query_atoms.append(ch)",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "SqlSpace",
        "kind": 6,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "class SqlSpace(GroundingSpace):\n    def __init__(self, database, host, user, password, port):\n        super().__init__()\n        import psycopg2\n        self.conn = psycopg2.connect(database=database,\n                                     host=host,\n                                     user=user,\n                                     password=password,\n                                     port=port)\n        self.cursor = self.conn.cursor()",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "IteratorAndConversionDict",
        "kind": 6,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "class IteratorAndConversionDict:\n    def __init__(self, iterator=None, conversion_dict=None):\n        self.iterator = iterator\n        self.conversion_dict = conversion_dict if conversion_dict is not None else {}\n    def set_iterator(self, iterator):\n        self.iterator = iterator\n    def set_conversion_dict(self, conversion_dict):\n        self.conversion_dict = conversion_dict\n    def get_iterator(self):\n        return self.iterator",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "InteractiveMeTTa",
        "kind": 6,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "class InteractiveMeTTa(ExtendedMeTTa): # LazyMeTTa ExtendedMeTTa\n    def __init__(self):\n        super().__init__()\n        # parent == self\n        #   means no parent MeTTa yet\n        self.parent = self\n        self.mode = \"metta\"\n    def maybe_submode(self, line):\n        lastchar = line[-1]\n        if \"+-?!^\".find(lastchar)>=0:",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "print_ast",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def print_ast(module_name_or_source_code):\n    try:\n        source_code = get_src(module_name_or_source_code)\n        # Parse the source code into an AST\n        parsed_ast = ast.parse(source_code)\n        # Use ast.dump to get a formatted string of the AST\n        print(ast.dump(parsed_ast, indent=4))\n        return parsed_ast\n    except ImportError:\n        print(f\"Error: Module {module_name} not found.\")",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "get_src",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def get_src(module_name_or_source_code):\n    try:\n        # Import the module dynamically using __import__ function\n        module = __import__(module_name_or_source_code)\n        # Construct the module file path\n        file_path = module.__file__\n        # Read the source code from the module file\n        with open(file_path, \"r\") as file:\n            source_code = file.read()\n        return source_code",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "src_ast",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def src_ast(module_name_or_source_code):\n    try:\n        source_code = get_src(module_name_or_source_code)\n        # Parse the source code into an AST\n        parsed_ast = ast.parse(source_code)\n        # Use ast.dump to get a formatted string of the AST\n        return parsed_ast\n    except ImportError:\n        print(f\"Error: Module {module_name} not found.\")\n    except Exception as e:",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "src_ast_str",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def src_ast_str(source_code):\n    try:\n        # Parse the source code into an AST\n        parsed_ast = src_ast(source_code)\n        # Use ast.dump to get a formatted string of the AST\n        return ast.dump(parsed_ast, indent=4)\n    except ImportError:\n        print(f\"Error: Module {module_name} not found.\")\n    except Exception as e:\n        print(f\"An error occurred: {e}\")",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "parent_space",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def parent_space():\n    return the_python_runner.parent.space()\ndef  child_space():\n    return the_python_runner.space()\ndef   self_space():\n    return the_new_runner_space\nspace_refs = {\n    #'&vspace': lambda: the_verspace,\n    '&gptspace': lambda: the_gptspace,\n    #'&flybase': lambda: the_flybase,",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": {
            "name": "",
            "kind": 2,
            "peekOfCode": "def  child_space():\n    return the_python_runner.space()\ndef   self_space():\n    return the_new_runner_space\nspace_refs = {\n    #'&vspace': lambda: the_verspace,\n    '&gptspace': lambda: the_gptspace,\n    #'&flybase': lambda: the_flybase,\n    '&parent': lambda: parent_space(),\n    '&child': lambda: child_space(),"
        },
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def  child_space():\n    return the_python_runner.space()\ndef   self_space():\n    return the_new_runner_space\nspace_refs = {\n    #'&vspace': lambda: the_verspace,\n    '&gptspace': lambda: the_gptspace,\n    #'&flybase': lambda: the_flybase,\n    '&parent': lambda: parent_space(),\n    '&child': lambda: child_space(),",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": {
            "name": "",
            "kind": 2,
            "peekOfCode": "def   self_space():\n    return the_new_runner_space\nspace_refs = {\n    #'&vspace': lambda: the_verspace,\n    '&gptspace': lambda: the_gptspace,\n    #'&flybase': lambda: the_flybase,\n    '&parent': lambda: parent_space(),\n    '&child': lambda: child_space(),\n    '&self': self_space}\ntry:"
        },
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def   self_space():\n    return the_new_runner_space\nspace_refs = {\n    #'&vspace': lambda: the_verspace,\n    '&gptspace': lambda: the_gptspace,\n    #'&flybase': lambda: the_flybase,\n    '&parent': lambda: parent_space(),\n    '&child': lambda: child_space(),\n    '&self': self_space}\ntry:",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "add_to_history_if_unique",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def add_to_history_if_unique(item, position_from_last=1):\n    for i in range(1, readline.get_current_history_length() + 1):\n        if readline.get_history_item(i) == item: return\n    insert_to_history(item, position_from_last)\ndef insert_to_history(item, position_from_last=5):\n    hist = [readline.get_history_item(i) for i in range(1, readline.get_current_history_length() + 1)]\n    # Remove the item from the list if it already exists before the insertion position\n    insertion_position = max(0, len(hist) - position_from_last)\n    if item in hist[:insertion_position]:\n        hist.remove(item)",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "insert_to_history",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def insert_to_history(item, position_from_last=5):\n    hist = [readline.get_history_item(i) for i in range(1, readline.get_current_history_length() + 1)]\n    # Remove the item from the list if it already exists before the insertion position\n    insertion_position = max(0, len(hist) - position_from_last)\n    if item in hist[:insertion_position]:\n        hist.remove(item)\n    # Insert the item at the desired position\n    hist.insert(insertion_position, item)\n    # Clear and repopulate the history\n    readline.clear_history()",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "readline_add_history",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def readline_add_history(t):\n    readline.add_history(t)\ninsert_to_history('!(get-by-key &my-dict \"A\")')\ninsert_to_history(\"@metta !\")\ninsert_to_history(\"!(mine-overlaps)\")\ninsert_to_history(\"!(try-overlaps)\")\ninsert_to_history(\"!(load-flybase-full)\")\ninsert_to_history(\"!(load-flybase-tiny)\")\n#insert_to_history(\"!(load-vspace)\")\ninsert_to_history(\"!(learn-vspace)\")",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "completer",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def completer(text, state):\n    options = [i for i in OPTIONS if i.startswith(text)]\n    if state < len(options):\n        return options[state]\n    else:\n        return None\n# Register the completer function\nreadline.set_completer(completer)\n# Use the tab key for completion\nreadline.parse_and_bind('tab: complete')",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "save",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def save(prev_h_len, histfile):\n    new_h_len = readline.get_current_history_length()\n    readline.set_history_length(400)\n    readline.append_history_file(new_h_len - prev_h_len, histfile)\natexit.register(save, h_len, histfile)\ndef export_to_metta(func):\n    setattr(func, 'metta', True)\n    if verbose>3: print_cmt(f\"{func}={getattr(func, 'export_to_metta', False)}\")\n    return func\ndef export_flags(**kwargs):",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "export_to_metta",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def export_to_metta(func):\n    setattr(func, 'metta', True)\n    if verbose>3: print_cmt(f\"{func}={getattr(func, 'export_to_metta', False)}\")\n    return func\ndef export_flags(**kwargs):\n    def decorator(func):\n        if verbose > 1: print(f\";   export_flags({repr(func)})\", end=\" \")\n        for n in kwargs:\n            setattr(func, n, kwargs[n])\n        if verbose > 1:",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "export_flags",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def export_flags(**kwargs):\n    def decorator(func):\n        if verbose > 1: print(f\";   export_flags({repr(func)})\", end=\" \")\n        for n in kwargs:\n            setattr(func, n, kwargs[n])\n        if verbose > 1:\n            for n in kwargs:\n                print(f\"{repr(n)}={repr(getattr(func, n, None))}\", end=\" \")\n            print()\n        return func",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "get_call_parts",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def get_call_parts(func):\n    sig = inspect.signature(func)\n    params = sig.parameters\n    # Constructing full parameter strings\n    param_parts = []\n    params_call_parts = []\n    var_args = var_kwargs = None\n    for param_name, param in params.items():\n        part = param_name\n        call_part = param_name",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "add_janus_methods",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def add_janus_methods(module, dict = janus_dict):\n    for name, func in inspect.getmembers(module):\n        if inspect.isfunction(func):\n            if getattr(func, \"Janus\", False) or getattr(func, \"MeTTa\", False):\n                use_name = getattr(func, 'name', name)\n                non_underscore_attrs = {attr: getattr(func, attr) for attr in dir(func) if not attr.startswith('_')}\n                if len(non_underscore_attrs)==0: continue\n                param_parts, params_call_parts = get_call_parts(func)\n                add_to_janus(use_name, param_parts, params_call_parts, func,non_underscore_attrs, janus_dict)\n@export_flags(MeTTa=True)",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "add_python_module",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def add_python_module(module, dict=oper_dict):\n    for name, func in inspect.getmembers(module):\n        if inspect.isfunction(func):\n           add_python_function(name, func, dict)\ndef add_python_function(name, func, dict):\n    use_name = getattr(func, 'name', name)\n    non_underscore_attrs = {attr: getattr(func, attr) for attr in dir(func) if not attr.startswith('_')}\n    if len(non_underscore_attrs)==0: return False\n    param_parts, params_call_parts = get_call_parts(func)\n    added = False",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "add_python_function",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def add_python_function(name, func, dict):\n    use_name = getattr(func, 'name', name)\n    non_underscore_attrs = {attr: getattr(func, attr) for attr in dir(func) if not attr.startswith('_')}\n    if len(non_underscore_attrs)==0: return False\n    param_parts, params_call_parts = get_call_parts(func)\n    added = False\n    if getattr(func, \"Janus\", False):\n        added = add_to_janus(use_name, param_parts, params_call_parts,\n            func, non_underscore_attrs, janus_dict) or added\n    if getattr(func, 'MeTTa', False):",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "add_to_metta",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def add_to_metta(name, param_parts, params_call_parts, op_kind, unwrap, func, non_underscore_attrs, dict=oper_dict):\n    hyphens, underscores = name.replace('_', '-'), name.replace('-', '_')\n    # Construct the param_str from param_parts\n    metta_params_str = ' '.join(param_parts)\n    s = f\"!({hyphens})\" if metta_params_str == \"\" else f\"!({hyphens} {metta_params_str})\"\n    add_to_history_if_unique(s)\n    if hyphens in dict:\n        return True\n    # Construct the param_str from param_parts\n    param_str = ', '.join(param_parts)",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "add_to_janus",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def add_to_janus(name, param_parts, params_call_parts, func, non_underscore_attrs, dict = janus_dict):\n    if getattr(func, 'CallsVSpace', False): return False\n    #if not getattr(func, \"Janus\", False): return False\n    suggestedName = getattr(func, 'name', name)\n    if suggestedName is not None:\n        use_name = suggestedName\n    else: use_name = name\n    for key, item in dict.items():\n        if key==use_name:\n            return True",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "find_methods_with_annotation",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def find_methods_with_annotation(module_name, annotation_string):\n    # Load the module\n    module = importlib.import_module(module_name)\n    # List to hold methods that match the annotation\n    matching_methods = []\n    # Iterate over all attributes in the module\n    for attr_name in dir(module):\n        attr = getattr(module, attr_name)\n        # Check if the attribute is a callable (function/method)\n        if callable(attr):",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "find_subclasses_of",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def find_subclasses_of(module, clazz):\n    subclasses = {}\n    for name, obj in inspect.getmembers(module):\n        if inspect.isclass(obj) and issubclass(obj, clazz) and obj is not clazz:\n            subclasses[name]=obj\n    return subclasses.items()\n    for name, claz in find_subclasses_of(module,AbstractSpace):\n        print(f\"found class {claz} with name {name}\")\n        # inspect the constructor and syntesize a function that will create an object\n@export_flags(MeTTa=True)",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "add_to_swip",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def add_to_swip(name, dict = oper_dict):\n    hyphens, underscores = name.replace('_', '-'), name.replace('-', '_')\n    add_to_history_if_unique(f\"!({hyphens})\")\n    if hyphens not in dict:\n        src, local_vars = f'op = lambda : [swip_exec(\"{underscores}\")]', {}\n        exec(src, {}, local_vars)\n        if verbose>1: print_cmt(f\"swip: {hyphens}\")\n        dict[hyphens] = OperationAtom(hyphens, local_vars['op'], unwrap=False)\ndef addSpaceName(name, space):\n    global syms_dict, space_refs",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "addSpaceName",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def addSpaceName(name, space):\n    global syms_dict, space_refs\n    prev = getSpaceByName(name)\n    name = str(name)\n    if not name.startswith(\"&\"):\n        name = \"&\" + name\n    syms_dict[name] = lambda _: G(asSpaceRef(space))\n    if prev is None:\n        space_refs[name] = lambda : space\ndef getSpaceByName(name):",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "getSpaceByName",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def getSpaceByName(name):\n    global space_refs\n    if name is ValueAtom:\n        name = name.get_value()\n    if name is GroundingSpace:\n        return name\n    name = str(name)\n    if not name.startswith(\"&\"):\n        name = \"&\" + name\n    found = space_refs.get(name, None)",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "getNameBySpace",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def getNameBySpace(target_space):\n    if target_space is None:\n        return None\n    global space_refs, syms_dict\n    # Search in space_refs\n    for name, space_func in space_refs.items():\n        S = space_func()\n        if S is target_space:\n            return name\n        if S:",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "asSpaceRef",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def asSpaceRef(obj):\n    if isinstance(obj, (VSpaceRef, SpaceRef)):\n        return obj\n    return VSpaceRef(obj)\nclass VSpaceRef(SpaceRef):\n    \"\"\"\n    A reference to a Space, which may be accessed directly, wrapped in a grounded atom,\n    or passed to a MeTTa interpreter.\n    \"\"\"\n    def __init__(self, space_obj):",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "foreign_framed",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def foreign_framed(func):\n    def wrapper(*args, **kwargs):\n        swipl_fid = PL_open_foreign_frame()\n        result = None\n        try:\n            result = func(*args, **kwargs)\n        except Exception as e:\n            if verbose>0: print_cmt(f\"Error: {e}\")\n            if verbose>0: traceback.print_exc()\n        finally:",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "is_iterable",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def is_iterable(obj):\n    try:\n        iter(obj)\n        return True\n    except TypeError:\n        return False\n@export_flags(MeTTa=True)\ndef test_custom_v_space():\n    #test_custom_space(lambda: (lambda vs: vs.incrHome() and vs)(VSpace()))\n    test_custom_v_space1()",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "test_custom_v_space",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def test_custom_v_space():\n    #test_custom_space(lambda: (lambda vs: vs.incrHome() and vs)(VSpace()))\n    test_custom_v_space1()\n    test_custom_v_space2()\n@export_flags(MeTTa=True)\ndef test_custom_v_space1():\n    test_custom_space(lambda: VSpace())\n@export_flags(MeTTa=True)\ndef test_custom_v_space2():\n    test_custom_space(lambda: the_nb_space)",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "test_custom_v_space1",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def test_custom_v_space1():\n    test_custom_space(lambda: VSpace())\n@export_flags(MeTTa=True)\ndef test_custom_v_space2():\n    test_custom_space(lambda: the_nb_space)\n    #test_custom_space(lambda: the_new_runner_space)\ndef test_custom_space(LambdaSpaceFn):\n    def passTest(msg):\n        print(f\"Pass Test:({msg})\")\n    def failTest(msg):",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "test_custom_v_space2",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def test_custom_v_space2():\n    test_custom_space(lambda: the_nb_space)\n    #test_custom_space(lambda: the_new_runner_space)\ndef test_custom_space(LambdaSpaceFn):\n    def passTest(msg):\n        print(f\"Pass Test:({msg})\")\n    def failTest(msg):\n        print(f\"raise AssertionError({msg})\")\n        #raise AssertionError(msg)\n    def self_assertEqualNoOrder(list1, list2, msg=None):",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "test_custom_space",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def test_custom_space(LambdaSpaceFn):\n    def passTest(msg):\n        print(f\"Pass Test:({msg})\")\n    def failTest(msg):\n        print(f\"raise AssertionError({msg})\")\n        #raise AssertionError(msg)\n    def self_assertEqualNoOrder(list1, list2, msg=None):\n        \"\"\"\n        Asserts that two lists are equal, regardless of their order.\n        \"\"\"",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "s2m",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def s2m(circles,swip_obj, depth=0):\n    r = s2m1(circles,swip_obj, depth)\n    if verbose<=1: return r\n    for i in range(depth+1):\n        print(\"   \",end='')\n    print_cmt(f\"r({type(r)})={str(r)}/{repr(r)}\")\n    return r\ndef s2m1(circles,swip_obj, depth=0):\n    if verbose>1:\n        for i in range(depth):",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "s2m1",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def s2m1(circles,swip_obj, depth=0):\n    if verbose>1:\n        for i in range(depth):\n            print(\"   \",end='')\n        print_cmt(f's2m({len(circles)},{type(swip_obj)}): {str(swip_obj)}/{repr(swip_obj)}')\n    # Already converted\n    if isinstance(swip_obj, (VariableAtom, GroundedAtom, Atom, ExpressionAtom)):\n        return swip_obj\n    if isinstance(swip_obj, str):\n        return S(swip_obj)",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "sv2mv",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def sv2mv(s):\n    return s.replace(\"_\", \"$\", 1) if s.startswith(\"_\") else \"$\" + s\n@export_flags(MeTTa=False)\ndef m2s(circles,metta_obj, depth=0):\n    r = m2s1(circles,metta_obj, depth)\n    if depth==0:\n        v = swipRef(r)\n    else:\n        v = r\n    if verbose<=1: return v",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "m2s",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def m2s(circles,metta_obj, depth=0):\n    r = m2s1(circles,metta_obj, depth)\n    if depth==0:\n        v = swipRef(r)\n    else:\n        v = r\n    if verbose<=1: return v\n    for i in range(depth+1):\n        print(\"   \",end='')\n    print(f\"r({type(r)})={r}\")",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "swipAtom",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def swipAtom(m):\n    a = PySwipAtom(str(m))\n    return a\ndef swipRef(a):\n    if isinstance(a, (Term)):\n       return a\n    v = Variable()\n    v.unify(a)\n    return v\ndef unwrap_pyobjs(metta_obj):",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "swipRef",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def swipRef(a):\n    if isinstance(a, (Term)):\n       return a\n    v = Variable()\n    v.unify(a)\n    return v\ndef unwrap_pyobjs(metta_obj):\n    if isinstance(metta_obj, ExpressionAtom):\n       return metta_obj\n    elif isinstance(metta_obj, GroundedAtom):",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "unwrap_pyobjs",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def unwrap_pyobjs(metta_obj):\n    if isinstance(metta_obj, ExpressionAtom):\n       return metta_obj\n    elif isinstance(metta_obj, GroundedAtom):\n       metta_obj = metta_obj.get_object()\n    if isinstance(metta_obj, ValueObject):\n       metta_obj = metta_obj.value\n    return metta_obj\ndef m2s1(circles, metta_obj, depth=0, preferStringToAtom = None, preferListToCompound = False):\n    var = circles.get(metta_obj, None)",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "m2s1",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def m2s1(circles, metta_obj, depth=0, preferStringToAtom = None, preferListToCompound = False):\n    var = circles.get(metta_obj, None)\n    if var is not None:\n        return var\n    metta_obj = unwrap_pyobjs(metta_obj)\n    var = circles.get(metta_obj, None)\n    if var is not None:\n        return var\n    if verbose>1:\n        for i in range(depth):",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "tuple_to_list",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def tuple_to_list(t):\n    return list(map(tuple_to_list, t)) if isinstance(t, (tuple, list)) else t\n# Example usage:\n#nested_tuple = (1, 2, (3, 4, (5, 6)), 7)\n#converted_list = tuple_to_list(nested_tuple)\n#print(converted_list)  # Output will be [1, 2, [3, 4, [5, 6]], 7]\ndef mv2svn(metta_obj):\n    named = metta_obj.get_name().replace('$','_')\n    if len(named)==0: return \"_0\"\n    s=named[0]",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "mv2svn",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def mv2svn(metta_obj):\n    named = metta_obj.get_name().replace('$','_')\n    if len(named)==0: return \"_0\"\n    s=named[0]\n    if(s == '_' or (s.isalpha() and  s.isupper())):\n        return named\n    else:\n        return \"_\" + named\ndef m2s3(circles, metta_obj, depth, preferStringToAtom, preferListToCompound):\n    for name, value in circles:",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "m2s3",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def m2s3(circles, metta_obj, depth, preferStringToAtom, preferListToCompound):\n    for name, value in circles:\n        if  name is metta_obj:\n            return value\n    if isinstance(metta_obj, SpaceRef):\n        return swiplist_to_swip(circles,metta_obj.get_atoms(),depth+1)\n    if isinstance(metta_obj, list):\n        return swiplist_to_swip(circles,metta_obj)\n    if isinstance(metta_obj, ExpressionAtom):\n        ch = metta_obj.get_children()",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "swiplist_to_swip",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def swiplist_to_swip(circles,retargs, depth=0):\n    sv = [m2s1(circles,item,depth) for item in retargs]\n    v = Variable()\n    v.unify(sv)\n    return v\ndef list_to_termv(circles,retargs, depth=0):\n    sv = [m2s1(circles,item,depth) for item in retargs]\n    return sv\nimport numpy as np\nclass VSNumpyValue(MatchableObject):",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "list_to_termv",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def list_to_termv(circles,retargs, depth=0):\n    sv = [m2s1(circles,item,depth) for item in retargs]\n    return sv\nimport numpy as np\nclass VSNumpyValue(MatchableObject):\n    def __eq__(self, metta_obj):\n        return isinstance(metta_obj, VSNumpyValue) and\\\n               (self.content.shape == metta_obj.content.shape) and\\\n               (self.content == metta_obj.content).all()\n    def match_(self, metta_obj):",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "dewrap",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def dewrap(arg):\n    r = unwrap_pyobjs(arg)\n    print(f\"dw({type(arg)})={type(r)}\")\n    return r\ndef wrapnpop(func):\n    def wrapper(*args):\n        a = [dewrap(arg) for arg in args]\n        res = func(*a)\n        typ = _np_atom_type(res)\n        return [G(VSNumpyValue(res), typ)]",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "wrapnpop",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def wrapnpop(func):\n    def wrapper(*args):\n        a = [dewrap(arg) for arg in args]\n        res = func(*a)\n        typ = _np_atom_type(res)\n        return [G(VSNumpyValue(res), typ)]\n    return wrapper\ndef color(t, c):\n    cmap = [90, 91, 31, 93, 92, 32, 36, 96, 94, 34, 35, 95, 38]\n    return f\"\\033[{cmap[c % len(cmap)]}m{t}\\033[0m\"",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "color",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def color(t, c):\n    cmap = [90, 91, 31, 93, 92, 32, 36, 96, 94, 34, 35, 95, 38]\n    return f\"\\033[{cmap[c % len(cmap)]}m{t}\\033[0m\"\ndef oblique(t):\n    return f\"\\033[3m{t}\\033[0m\"\ndef underline(t):\n    return f\"\\033[4m{t}\\033[0m\"\ndef expr_vars(expr):\n    if isinstance(expr, SymbolAtom):\n        return []",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "oblique",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def oblique(t):\n    return f\"\\033[3m{t}\\033[0m\"\ndef underline(t):\n    return f\"\\033[4m{t}\\033[0m\"\ndef expr_vars(expr):\n    if isinstance(expr, SymbolAtom):\n        return []\n    elif isinstance(expr, VariableAtom):\n        return [str(expr)]\n    elif isinstance(expr, ExpressionAtom):",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "underline",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def underline(t):\n    return f\"\\033[4m{t}\\033[0m\"\ndef expr_vars(expr):\n    if isinstance(expr, SymbolAtom):\n        return []\n    elif isinstance(expr, VariableAtom):\n        return [str(expr)]\n    elif isinstance(expr, ExpressionAtom):\n        return [e for c in expr.get_children() for e in expr_vars(c)]\n    elif isinstance(expr, GroundedAtom):",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "expr_vars",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def expr_vars(expr):\n    if isinstance(expr, SymbolAtom):\n        return []\n    elif isinstance(expr, VariableAtom):\n        return [str(expr)]\n    elif isinstance(expr, ExpressionAtom):\n        return [e for c in expr.get_children() for e in expr_vars(c)]\n    elif isinstance(expr, GroundedAtom):\n        return []\n    else:",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "color_expr",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def color_expr(expr, level=0, unif_vars=None):\n    name = str(expr)\n    if level == 0:\n        unif_vars = frozenset(e for e, c in Counter(expr_vars(expr)).items() if c > 1) \\\n            if unif_vars is None else frozenset()\n    if isinstance(expr, SymbolAtom):\n        return name\n    elif isinstance(expr, VariableAtom):\n        return oblique(name) if name in unif_vars else name\n    elif isinstance(expr, ExpressionAtom):",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "print_l_e",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def print_l_e(obj):\n    if obj is None:\n        print(\"None!\")\n        return obj\n    if isinstance(obj, str):\n        print(obj)\n        return obj\n    try:\n        # Attempt to iterate over the object\n        for item in obj:",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "print_cmt",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def print_cmt(*args, prefix=\";; \"):\n   for arg in args:\n       println(arg, prefix=prefix)\n       flush_console()\n@export_flags(MeTTa=True, name=\"print\", unwrap=True)\ndef println(orig, prefix=\"\"):\n    \"\"\"\n    Prints the given object and returns it.\n    Args:\n        orig: The object to be printed.",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "println",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def println(orig, prefix=\"\"):\n    \"\"\"\n    Prints the given object and returns it.\n    Args:\n        orig: The object to be printed.\n    Returns:\n        The same object that was passed in.\n    \"\"\"\n    try:\n      prefix_print(prefix, orig)",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "prefix_print",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def prefix_print(prefix, orig):\n    obj = unwrap_pyobjs(orig)\n    if isinstance(obj, str):\n        objlns = obj.splitlines()\n        for r in objlns:\n            print(prefix, r)\n        return\n    if isinstance(obj, (AbstractSpace, GroundingSpaceRef, SpaceRef)):\n        s = obj\n        f = getattr(s,\"atom_count\", None)",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "pt1",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def pt1(obj):\n    if isinstance(obj, str):\n        print(f\"{repr(obj)}\", end= \" \")\n    elif not isinstance(obj, (Term, Variable)):\n        print(f\" pt: {type(obj)}={str(obj)}={repr(obj)}\", end= \" \")\n        if isinstance(obj, list):\n            obj = obj[0]\n            print(f\" pt(0): {type(obj)}={str(obj)}={repr(obj)}\", end= \" \")\n    else:\n        fn = Functor(\"pp\")",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "pt",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def pt(*objs):\n    r = objs\n    for o in objs:\n        if isinstance(o, str):\n            print(o, end=\"\")\n        else: r= pt1(o)\n    print()\n    return r\n@export_flags(MeTTa=True, op=\"VSpacePatternOperation\")\ndef test_s(metta_obj):",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "test_s",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def test_s(metta_obj):\n    circles = Circles()\n    pt(metta_obj)\n    swip_obj = m2s(circles,metta_obj)\n    pt(swip_obj)\n    new_mo = s2m(circles,swip_obj)\n    pt(new_mo)\n    return new_mo\ndef get_sexpr_input(prmpt):\n    expr, inside_quotes, prev_char = \"\", False, None",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "get_sexpr_input",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def get_sexpr_input(prmpt):\n    expr, inside_quotes, prev_char = \"\", False, None\n    while True:\n        line = input(prmpt)\n        flush_console()\n        for char in line:\n            if char == '\"' and prev_char != '\\\\':\n                inside_quotes = not inside_quotes\n            expr += char\n            prev_char = char",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "sync_space",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def sync_space(named):\n    \"\"\ndef the_running_metta_space():\n    global the_new_runner_space\n    global the_python_runner\n    #if the_python_runner.parent!=the_python_runner:\n    #    return the_python_runner.parent.space()\n    if the_new_runner_space is not None: return the_new_runner_space\n    return the_python_runner.parent.space()\n# Borrowed impl from Adam Vandervorst",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "the_running_metta_space",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def the_running_metta_space():\n    global the_new_runner_space\n    global the_python_runner\n    #if the_python_runner.parent!=the_python_runner:\n    #    return the_python_runner.parent.space()\n    if the_new_runner_space is not None: return the_new_runner_space\n    return the_python_runner.parent.space()\n# Borrowed impl from Adam Vandervorst\nimport os\nfrom importlib import import_module",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "split_or_none",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def split_or_none(s, delimiter):\n    parts = s.split(delimiter, 1)  # split only at the first occurrence\n    return parts[0], (parts[1] if len(parts) > 1 else None)\n# from awakening health\ndef _response2bindings(txt):\n        res = re.findall(r'\\{.*?\\}', txt)\n        new_bindings_set = BindingsSet.empty()\n        if res == []:\n            return new_bindings_set\n        res = res[0][1:-1]",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "self_space_info",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def self_space_info():\n    return \"\"\ndef wrapsqlop(func):\n    def wrapper(*args):\n        if len(args) > 0 and isinstance(args[0], GroundedAtom) and isinstance(args[0].get_object(), SpaceRef):\n            space = args[0].get_object()\n            args = args[1:]\n            a = [repr(arg) if isinstance(arg, SymbolAtom) else arg.get_object().value for arg in args]\n            res = func(space, *a)\n            return [ValueAtom(val) for val in res]",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "wrapsqlop",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def wrapsqlop(func):\n    def wrapper(*args):\n        if len(args) > 0 and isinstance(args[0], GroundedAtom) and isinstance(args[0].get_object(), SpaceRef):\n            space = args[0].get_object()\n            args = args[1:]\n            a = [repr(arg) if isinstance(arg, SymbolAtom) else arg.get_object().value for arg in args]\n            res = func(space, *a)\n            return [ValueAtom(val) for val in res]\n        return []\n    return wrapper",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "results2bindings",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def results2bindings(vars, values):\n    new_bindings_set = BindingsSet.empty()\n    if len(values) == 0 or len(vars) != len(values[0]):\n        return new_bindings_set\n    for value in values:\n        bindings = Bindings()\n        for i in range(len(vars)):\n            bindings.add_var_binding(vars[i], ValueAtom(str(value[i])))\n        new_bindings_set.push(bindings)\n    return new_bindings_set",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "wrapsqlop",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def wrapsqlop(func):\n    def wrapper(*args):\n        if len(args) > 1:\n            if isinstance(args[0], GroundedAtom):\n                space1 = args[0].get_object()\n                if isinstance(space1, SpaceRef):\n                    if isinstance(args[1], GroundedAtom):\n                        space2 = args[1].get_object()\n                        if isinstance(space2, SpaceRef):\n                            args = args[2:]",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "sql_space_atoms",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def sql_space_atoms():\n    helper = SqlHelper()\n    newSQLSpaceAtom = OperationAtom('new-sql-space', lambda database, host, user, password, port: [\n        G(SpaceRef(SqlSpace(database, host, user, password, port)))], unwrap=False)\n    saveQueryResult = G(OperationObject('sql.save-query-result', wrapsqlop(helper.save_query_result), unwrap=False))\n    sqlInsert = G(OperationObject('sql.insert', wrapsqlop(helper.insert), unwrap=False))\n    return {\n        r\"new-sql-space\": newSQLSpaceAtom,\n        r\"sql.save-query-result\": saveQueryResult,\n        r\"sql.insert\": sqlInsert",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "pl_select",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def pl_select(*args):\n    print_cmt(\"pl_select: \",args)\n    flush_console()\ndef pl_insert(*args):\n    print_cmt(\"pl_insert: \",args)\n    flush_console()\ndef np_array(args):\n    print_cmt(\"np_array=\",args)\n    return np.array(args)\ndef np_vector(*args):",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "pl_insert",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def pl_insert(*args):\n    print_cmt(\"pl_insert: \",args)\n    flush_console()\ndef np_array(args):\n    print_cmt(\"np_array=\",args)\n    return np.array(args)\ndef np_vector(*args):\n    print_cmt(\"np_vector=\",args)\n    return np.array(args)\nrealMetta = None",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "np_array",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def np_array(args):\n    print_cmt(\"np_array=\",args)\n    return np.array(args)\ndef np_vector(*args):\n    print_cmt(\"np_vector=\",args)\n    return np.array(args)\nrealMetta = None\ndef metta_register(metta):\n    print(f\";; metta_register={the_python_runner}/{metta}\")\n    global realMetta",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "np_vector",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def np_vector(*args):\n    print_cmt(\"np_vector=\",args)\n    return np.array(args)\nrealMetta = None\ndef metta_register(metta):\n    print(f\";; metta_register={the_python_runner}/{metta}\")\n    global realMetta\n    try:\n        if not metta is None:\n            if not isinstance(metta,ExtendedMeTTa):",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "metta_register",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def metta_register(metta):\n    print(f\";; metta_register={the_python_runner}/{metta}\")\n    global realMetta\n    try:\n        if not metta is None:\n            if not isinstance(metta,ExtendedMeTTa):\n                realMetta = metta\n            register_vspace_atoms_pm(metta)\n    #the_python_runner.set_cmetta(metta)\n    #print(\";;\", metta.pymods)",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "register_vspace_atoms",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def register_vspace_atoms():\n    register_vspace_atoms_pm(None)\n@export_flags(MeTTa=True)\n@register_atoms(pass_metta=True)\ndef register_vspace_atoms_pm(mettaIn):\n    global realMetta\n    if mettaIn is None:\n         mettaIn = realMetta\n    metta = mettaIn\n    global oper_dict",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "register_vspace_atoms_pm",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def register_vspace_atoms_pm(mettaIn):\n    global realMetta\n    if mettaIn is None:\n         mettaIn = realMetta\n    metta = mettaIn\n    global oper_dict\n    if verbose>1: print_cmt(f\"register_vspace_atoms metta={metta} the_python_runner = {the_python_runner} {self_space_info()}\")\n    counter = 0\n    #if not metta is None: the_python_runner.set_cmetta(metta)\n    if not isinstance(metta, VSpace):",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "register_vspace_tokens",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def register_vspace_tokens(metta):\n    if verbose>1: print_cmt(f\"register_vspace_tokens metta={metta} {self_space_info()}\")\n    if hasattr(the_python_runner,\"set_cmetta\"):\n        the_python_runner.set_cmetta(metta.cmetta)\n    if hasattr(the_python_runner,\"cmetta\"):\n        the_python_runner.cmetta = metta.cmetta\n    if not isinstance(metta, VSpace):\n        the_python_runner.parent = metta\n    def run_resolved_symbol_op(the_python_runner, atom, *args):\n        expr = E(atom, *args)",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "res_unify",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def res_unify(s,v):\n  if isinstance(v, str):\n      if isinstance(s, str):\n          return s == v\n      return s.unify(swipAtom(v))\n  return s.unify(v)\n# Define the foreign functions\n@export_flags(Janus=True)\ndef query_from_space(space_name, query_atom, result):\n    space = getSpaceByName(space_name)",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "query_from_space",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def query_from_space(space_name, query_atom, result):\n    space = getSpaceByName(space_name)\n    if space:\n        atoms = space.query(query_atom)\n        return res_unify(result,atoms)\n    return False\n@export_flags(Janus=True)\ndef add_to_space(space_name, atom):\n    space = getSpaceByName(space_name)\n    if space:",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "add_to_space",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def add_to_space(space_name, atom):\n    space = getSpaceByName(space_name)\n    if space:\n        circles = Circles()\n        atom = s2m(circles,atom)\n        if isinstance(space, SpaceRef):\n            return space.add_atom(atom)\n        return space.add(atom)\n    return False\n@export_flags(Janus=True)",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "remove_from_space",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def remove_from_space(space_name, atom):\n    space = getSpaceByName(space_name)\n    if space:\n        circles = Circles()\n        atom = s2m(circles,atom)\n        return space.remove(atom)\n    return False\n@export_flags(Janus=True)\ndef replace_in_space(space_name, from_atom, to_atom):\n    space = getSpaceByName(space_name)",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "replace_in_space",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def replace_in_space(space_name, from_atom, to_atom):\n    space = getSpaceByName(space_name)\n    if space:\n        circles = Circles()\n        to_atom = s2m(circles,to_atom)\n        from_atom = s2m(circles,from_atom)\n        return space.replace(from_atom, to_atom)\n    return False\n@export_flags(Janus=True)\ndef atom_count_from_space(space_name, result):",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "atom_count_from_space",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def atom_count_from_space(space_name, result):\n    space = getSpaceByName(space_name)\n    if space:\n        return res_unify(result,space.atom_count())\n    return False\n@export_flags(Janus=True)\ndef get_atoms_from_space(space_name, result):\n    space = getSpaceByName(space_name)\n    if space:\n        circles = Circles()",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "get_atoms_from_space",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def get_atoms_from_space(space_name, result):\n    space = getSpaceByName(space_name)\n    if space:\n        circles = Circles()\n        atoms = list(space.get_atoms())\n        satoms = [m2s(circles, atom) for atom in atoms]\n        return res_unify(result,satoms)\n    return False\ncontext_atom_iters = {}\ndef MkExpr(py_list):",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "MkExpr",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def MkExpr(py_list):\n    list = py_list\n    return E(*list)\nclass IteratorAndConversionDict:\n    def __init__(self, iterator=None, conversion_dict=None):\n        self.iterator = iterator\n        self.conversion_dict = conversion_dict if conversion_dict is not None else {}\n    def set_iterator(self, iterator):\n        self.iterator = iterator\n    def set_conversion_dict(self, conversion_dict):",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "get_atoms_iter_from_space",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def get_atoms_iter_from_space(space_name):\n    space = getSpaceByName(space_name)\n    if space:\n        get_iterator =  getattr(space,\"atoms_iter\", None) # Create a new iterator\n        if get_iterator is not None:\n            return get_iterator()\n        else:\n            get_iterator =  getattr(space,\"get_atoms\", None) # Create a new iterator\n            if get_iterator is not None:\n                return iter(get_iterator)",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "atoms_iter_from_space",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def atoms_iter_from_space(space_name, result, context):\n    global idKey, context_atom_iters\n    control = PL_foreign_control(context)\n    context = PL_foreign_context(context)\n    id = context\n    if control == PL_FIRST_CALL:\n        id = idKey\n        idKey= idKey+1\n        iterator = get_atoms_iter_from_space(space_name)\n        if iterator is not None:",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "add_to_history_if_unique_pl",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def add_to_history_if_unique_pl(item, position_from_last=1):\n    for i in range(1, readline.get_current_history_length() + 1):\n        if readline.get_history_item(i) == item: return\n    insert_to_history(item, position_from_last)\ndef reg_pyswip_foreign():\n    add_janus_methods(sys.modules[__name__], dict = oper_dict)\n    test_nondeterministic_foreign()\n    def py_eval(e, result):\n        return res_unify(result,eval(str(e)))\n    py_eval.arity = 2",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "reg_pyswip_foreign",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def reg_pyswip_foreign():\n    add_janus_methods(sys.modules[__name__], dict = oper_dict)\n    test_nondeterministic_foreign()\n    def py_eval(e, result):\n        return res_unify(result,eval(str(e)))\n    py_eval.arity = 2\n    registerForeign(py_eval)\n    # Register the foreign functions in PySwip\n    #registerForeign(new_rust_space, arity=1)\n    #registerForeign(query_from_space, arity=3)",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "find_rust_space",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def find_rust_space(space_name, result):\n    space = getSpaceByName(space_name)\n    named = getNameBySpace(space)\n    if space:\n        return res_unify(result,named)\n    return False\nrustspace_ordinal = 0\n@export_flags(Janus=True)\ndef new_rust_space(result):\n    rustspace_ordinal=rustspace_ordinal+1",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "new_rust_space",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def new_rust_space(result):\n    rustspace_ordinal=rustspace_ordinal+1\n    name = f\"&vspace_{rustspace_ordinal}\"\n    space = GroundingSpace()\n    addSpaceName(name,space)\n    return res_unify(result,swipAtom(name))\n@export_flags(MeTTa=True, Janus=True)\ndef test_nondeterministic_foreign1():\n    def nondet(a, context):\n        control = PL_foreign_control(context)",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "test_nondeterministic_foreign1",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def test_nondeterministic_foreign1():\n    def nondet(a, context):\n        control = PL_foreign_control(context)\n        context = PL_foreign_context(context)\n        if control == PL_FIRST_CALL:\n            context = 0\n            a.unify(int(context))\n            context += 1\n            return PL_retry(context)\n        elif control == PL_REDO:",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "test_nondeterministic_foreign2",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def test_nondeterministic_foreign2():\n    def number_generator():\n        for i in range(10):\n            yield i\n    iterator = number_generator()\n    def nondet2(a, context):\n        control = PL_foreign_control(context)\n        context = PL_foreign_context(context)\n        #global iterator  # Use the global iterator object\n        if control == PL_FIRST_CALL:",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "test_nondeterministic_foreign3",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def test_nondeterministic_foreign3():\n    def number_generator(size):\n        for i in range(size):\n            yield i\n    context_iterators = {}  # Dictionary to store iterators by context\n    def nondet3(sz, a, context):\n        global idKey\n        control = PL_foreign_control(context)\n        context = PL_foreign_context(context)\n        id = context",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "test_nondeterministic_foreign",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def test_nondeterministic_foreign():\n    test_nondeterministic_foreign1()\n    test_nondeterministic_foreign2()\n    test_nondeterministic_foreign3()\n    def hello(t):\n        print_cmt(\"Hello,\", t)\n    hello.arity = 1\n    registerForeign(hello, arity=1)\n    def hello1(t):\n        readline.replace_history_item(0, t)",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "swip_to_metta_wrapper",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def swip_to_metta_wrapper(swip_obj, metta_obj):\n    circles = Circles()\n    result1 = m2s(circles,s2m(circles,swip_obj))\n    result2 = m2s(circles,metta_obj)\n    #metta_obj.unify(m2s(circles,result))\n    return result2.unify(result1)\n    #return True\n@export_flags(Janus=True)\ndef metta_to_swip_wrapper(metta_obj, swip_obj):\n    circles = Circles()",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "metta_to_swip_wrapper",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def metta_to_swip_wrapper(metta_obj, swip_obj):\n    circles = Circles()\n    result1 = m2s(circles,metta_obj)\n    result2 = m2s(circles,swip_obj)\n    #swip_obj.unify(result)\n    return result2.unify(result1)\n    #return True\n@export_flags(MeTTa=True)\ndef metta_to_swip_tests1():\n    # Register the methods as foreign predicates",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "metta_to_swip_tests1",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def metta_to_swip_tests1():\n    # Register the methods as foreign predicates\n    registerForeign(swip_to_metta_wrapper, arity=2)\n    registerForeign(metta_to_swip_wrapper, arity=2)\n    circles = Circles()\n    # Usage:\n    swip_functor = Functor(PySwipAtom(\"example\"), 2, [PySwipAtom(\"sub1\"), 3.14])\n    print_cmt(f\"swip_functor={swip_functor}\"),\n    metta_expr = s2m(circles,swip_functor)\n    print_cmt(f\"metta_expr={metta_expr}\"),",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "metta_to_swip_tests2",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def metta_to_swip_tests2():\n    # Register the methods as foreign predicates\n    registerForeign(swip_to_metta_wrapper, arity=2)\n    registerForeign(metta_to_swip_wrapper, arity=2)\n    circles = Circles()\n    # Now you can use the methods in PySwip queries\n    println(list(swip.query(\"swip_to_metta_wrapper('example', X).\")))\n    println(list(swip.query(\"metta_to_swip_wrapper(X, 'example').\")))\n    # Usage:\n    swip_list = [\"a\", \"b\", 3]",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "load_vspace",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def load_vspace():\n   global NeedNameSpaceInSWIP\n   swip_exec(f\"ensure_loaded('{os.path.dirname(__file__)}/pyswip/metta_interp')\")\n   if NeedNameSpaceInSWIP:\n       NeedNameSpaceInSWIP = False\n       swip.retractall(\"was_asserted_space('&self')\")\n       swip.assertz(\"py_named_space('&self')\")\n@export_flags(MeTTa=True, CallsVSpace=True)\ndef mine_overlaps():\n   load_vspace()",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "mine_overlaps",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def mine_overlaps():\n   load_vspace()\n   swip_exec(\"mine_overlaps\")\n   #readline_add_history(\"!(try-overlaps)\")\n@export_flags(MeTTa=True, CallsVSpace=True)\ndef try_overlaps():\n   load_vspace()\n   swip_exec(\"try_overlaps\")\n@export_flags(MeTTa=True, CallsVSpace=True)\ndef learn_vspace():",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "try_overlaps",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def try_overlaps():\n   load_vspace()\n   swip_exec(\"try_overlaps\")\n@export_flags(MeTTa=True, CallsVSpace=True)\ndef learn_vspace():\n   load_vspace()\n   swip_exec(\"learn_vspace(60)\")\n@export_flags(MeTTa=True, CallsVSpace=True)\ndef mettalog():\n   load_vspace()",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "learn_vspace",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def learn_vspace():\n   load_vspace()\n   swip_exec(\"learn_vspace(60)\")\n@export_flags(MeTTa=True, CallsVSpace=True)\ndef mettalog():\n   load_vspace()\n   swip_exec(\"repl\")\n@export_flags(MeTTa=True)\ndef register_mettalog_op_new(fn, n):\n   arg_types = [AtomType.ATOM] * (n) + [AtomType.UNDEFINED]",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "mettalog",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def mettalog():\n   load_vspace()\n   swip_exec(\"repl\")\n@export_flags(MeTTa=True)\ndef register_mettalog_op_new(fn, n):\n   arg_types = [AtomType.ATOM] * (n) + [AtomType.UNDEFINED]\n   op = OperationAtom(fn, lambda *args:\n                  print_cmt(f\"eval_mettalog('{fn}', {args})\") +\n                  eval_mettalog(fn, *args),\n                              type_names=arg_types,",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "register_mettalog_op_new",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def register_mettalog_op_new(fn, n):\n   arg_types = [AtomType.ATOM] * (n) + [AtomType.UNDEFINED]\n   op = OperationAtom(fn, lambda *args:\n                  print_cmt(f\"eval_mettalog('{fn}', {args})\") +\n                  eval_mettalog(fn, *args),\n                              type_names=arg_types,\n                              unwrap=True)\n   the_python_runner.register_atom(fn, op)\n   return op\n@export_flags(MeTTa=True, CallsVSpace=True)",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "use_mettalog",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def use_mettalog():\n   load_vspace()\n   register_mettalog_op(\"pragma!\",2)\n   register_mettalog_op(\"match\",3)\n   return register_mettalog_op(\"import!\",2)\n@export_flags(MeTTa=True)\ndef register_mettalog_op(fn, n):\n    arg_types = [AtomType.ATOM] * (n) + [AtomType.UNDEFINED]\n    n_args = ', '.join(['arg' + str(i) for i in range(n)])\n    local_vars = {}",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "register_mettalog_op",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def register_mettalog_op(fn, n):\n    arg_types = [AtomType.ATOM] * (n) + [AtomType.UNDEFINED]\n    n_args = ', '.join(['arg' + str(i) for i in range(n)])\n    local_vars = {}\n    src = f'lop = lambda {n_args}: eval_mettalog(\"{fn}\", {n_args})'\n    exec(src, globals(), local_vars)\n    lop = local_vars['lop']\n    #print_cmt(src) print_cmt(type(the_python_runner))\n    op = OperationAtom(fn, lop, type_names=arg_types, unwrap=False)\n    oper_dict[fn]=op",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "eval_mettalog",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def eval_mettalog(fn, *args):\n    print_cmt(f\"eval_mettalog('{fn}', {args})\")\n    return list(_eval_mettalog(fn,args))\ndef _eval_mettalog(fn, *args):\n    circles = Circles()\n    expr = [fn] + list(args) # Prepend fn to args list\n    swip_obj = m2s(circles,expr)\n    flush_console()\n    call_sexpr = Functor(\"call_sexpr\", 5)\n    #user = newModule(\"user\")",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "mettalog_pl",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def mettalog_pl():\n   load_vspace()\n   swip_exec(\"break\")\n@export_flags(CallsVSpace=True)\ndef load_flybase(size):\n   load_vspace()\n   swip_exec(f\"load_flybase({size})\")\n   #readline_add_history(\"!(mine-overlaps)\")\n@export_flags(MeTTa=True)\ndef swip_exec(qry):",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "load_flybase",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def load_flybase(size):\n   load_vspace()\n   swip_exec(f\"load_flybase({size})\")\n   #readline_add_history(\"!(mine-overlaps)\")\n@export_flags(MeTTa=True)\ndef swip_exec(qry):\n    swip_exec_ff(qry)\n@foreign_framed\ndef swip_exec_ff(qry):\n    #from metta_vspace import swip",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "swip_exec",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def swip_exec(qry):\n    swip_exec_ff(qry)\n@foreign_framed\ndef swip_exec_ff(qry):\n    #from metta_vspace import swip\n    #if is_init==True:\n    #   print_cmt(\"Not running Query: \",qry)\n    #   return\n    for r in swip.query(qry):\n        print_cmt(r)",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "swip_exec_ff",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def swip_exec_ff(qry):\n    #from metta_vspace import swip\n    #if is_init==True:\n    #   print_cmt(\"Not running Query: \",qry)\n    #   return\n    for r in swip.query(qry):\n        print_cmt(r)\n@export_flags(MeTTa=True)\ndef test_custom_m_space():\n    class TestSpace(AbstractSpace):",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "test_custom_m_space",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def test_custom_m_space():\n    class TestSpace(AbstractSpace):\n        def __init__(self, unwrap=False):\n            super().__init__()\n            self.atoms_list = []\n            self.unwrap = unwrap\n        # NOTE: this is a naive implementation barely good enough to pass the tests\n        # Don't take this as a guide to implementing a space query function\n        def query(self, query_atom):\n            # Extract only the variables from the query atom",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "timeFrom",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def timeFrom(w, t0):\n    elapsed_ns = monotonic_ns() - t0\n    elapsed_s = elapsed_ns / 1e9\n    elapsed_ms = elapsed_ns / 1e6\n    elapsed_us = elapsed_ns / 1e3\n    if elapsed_s >= 1:\n        print_cmt(f\"{w} took {elapsed_s:.5f} seconds\")\n    elif elapsed_ms >= 1:\n        print_cmt(f\"{w} took {elapsed_ms:.5f} milliseconds\")\n    else:",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "call_mettalog",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def call_mettalog(line, parseWithRust = False):\n    if parseWithRust:\n        expr = self.parse_single(sline)\n        if verbose>1: print_cmt(f\"% S-Expr {line}\")\n        if verbose>1: print_cmt(f\"% M-Expr {expr}\")\n        circles = Circles()\n        swip_obj = m2s(circles,expr);\n        if verbose>1: print_cmt(f\"% P-Expr {swip_obj}\")\n    else:\n        swip_obj = line",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "redirect_stdout",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def redirect_stdout(inner_function):\n    old_stdout = sys.stdout # Save the current stdout stream\n    new_stdout = io.StringIO() # Create a new StringIO buffer\n    sys.stdout = new_stdout # Redirect stdout to the new buffer\n    try:\n        inner_function() # Execute the inner function\n    finally:\n        sys.stdout = old_stdout # Restore the original stdout stream\n    output = new_stdout.getvalue() # Retrieve the output from the new buffer\n    new_stdout.close() # Close the new buffer",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "vspace_init",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def vspace_init():\n    if getattr(vspace_init,\"is_init_ran\", False) == True:\n        return\n    vspace_init.is_init_ran = True\n    t0 = monotonic_ns()\n    #os.system('clear')\n    print_cmt(underline(f\"Version-Space Init: {__file__}\\n\"))\n    #import site\n    #print_cmt (\"Site Packages: \",site.getsitepackages())\n    #test_nondeterministic_foreign()",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "flush_console",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def flush_console():\n    try:\n      if sys.__stdout__ is not None: sys.__stdout__.flush()\n    except Exception: \"\"\n    try:\n      if sys.__stderr__ is not None: sys.__stderr__.flush()\n    except Exception: \"\"\n    try:\n      if sys.stderr is not None and not (sys.stderr is sys.__stderr__): sys.sys.stderr.flush()\n    except Exception: \"\"",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "detect_encoding",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def detect_encoding(file_path, sample_size=20000):\n    with open(file_path, 'rb') as f:\n        raw = f.read(sample_size)\n    return chardet.detect(raw)['encoding']\nfrom collections.abc import Iterable\ndef is_lisp_dashed(s):\n    pattern = re.compile('^[A-Za-z0-9-_:]+$')\n    return bool(pattern.match(s))\ndef item_string(lst, functor=\"\"):\n    if isinstance(lst, str):",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "is_lisp_dashed",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def is_lisp_dashed(s):\n    pattern = re.compile('^[A-Za-z0-9-_:]+$')\n    return bool(pattern.match(s))\ndef item_string(lst, functor=\"\"):\n    if isinstance(lst, str):\n        if len(lst) == 0:\n            return '\"\"'\n        if any(char in lst for char in [' ', '\"', \"'\", \"(\", \")\", \".\", \"\\\\\"]):\n            return json.dumps(lst)\n        if isinstance(lst, (int, float)):",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "item_string",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def item_string(lst, functor=\"\"):\n    if isinstance(lst, str):\n        if len(lst) == 0:\n            return '\"\"'\n        if any(char in lst for char in [' ', '\"', \"'\", \"(\", \")\", \".\", \"\\\\\"]):\n            return json.dumps(lst)\n        if isinstance(lst, (int, float)):\n            return repr(lst)\n        if is_float_string(lst):\n            return repr(float(lst))",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "list_string",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def list_string(lst, functor=\"# \"):\n    try:\n        if isinstance(lst, Iterable) and not isinstance(lst, str):\n            if len(lst) == 0:\n                return '()'\n            return '(' + functor + ' '.join([item_string(vv) for vv in lst]) + ')'\n        else:\n            return item_string(lst)\n    except TypeError:\n        return item_string(lst)",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "is_float_string",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def is_float_string(s):\n    return bool(re.fullmatch(r'[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?', s))\nimport pandas as pd\ndef update_dataframe_skipping_first_row(df):\n    \"\"\"\n    Takes a DataFrame, skips the first row, recalculates unique counts and value counts,\n    and infers the most appropriate datatypes for each column.\n    Parameters:\n    df (pandas.DataFrame): The original DataFrame.\n    Returns:",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "update_dataframe_skipping_first_row",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def update_dataframe_skipping_first_row(df):\n    \"\"\"\n    Takes a DataFrame, skips the first row, recalculates unique counts and value counts,\n    and infers the most appropriate datatypes for each column.\n    Parameters:\n    df (pandas.DataFrame): The original DataFrame.\n    Returns:\n    pandas.DataFrame: A DataFrame with the first row removed, updated with recalculated\n    uniqueness and value counts, and with inferred datatypes.\n    \"\"\"",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "analyze_csv_basename",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def analyze_csv_basename(file_path, sep=None):\n    base_name = os.path.basename(file_path)\n    base_name = base_name.replace('.tsv', '')\n    base_name = base_name.replace('.fb', '')\n    # Remove a sequence like _fb_####_## (where # represents a digit)\n    base_name = re.sub(r'_fb_\\d{4}_\\d{2}', '', base_name)\n    # Remove a sequence like ####_## at any place\n    base_name = re.sub(r'\\d{4}_\\d{2}', '', base_name)\n    # Replace periods with underscores, if not part of a file extension\n    base_name = re.sub(r'\\.(?=.*\\.)', '_', base_name)",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "analyze_csv",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def analyze_csv(base_name, file_path, sep=None):\n    print_cmt(\";;------------------------------------------------------------------------------------------------------------------\")\n    print_cmt(f\"Analyzing file: {file_path}\")\n    missing_values_list = [\"\",\"-\",\" \",\"|\",\",\",\"#\",  \"*\",  \"\\\"\\\"\",  \"+\", \"NULL\", \"N/A\", \"--\",\n                         \"NaN\",\"EMPTY\",\"None\",\"n/a\",\"(none)\",\n                         # \"0\",\"Dmel\",\"-1\",\n                          \"MISSING\", \"?\", \"undefined\", \"unknown\", \"none\", \"[]\", \".\"]\n    def read_csv(enc, skip_rows, header_option):\n            false_values_list = [\"F\", \"f\", \"False\", \"false\", \"N\", \"No\", \"no\", \"FALSE\"]\n            true_values_list = [\"T\", \"t\", \"True\", \"true\", \"Y\", \"Yes\", \"yes\", \"TRUE\"]",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "import_metta_file",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def import_metta_file(string):\n    global argmode\n    if argmode==\"mettalog\":\n        load_vspace()\n        swip_exec(f\"load_metta_file('{selected_space_name}','{string}')\")\n    else: the_python_runner.import_file(string)\nimport os\nimport sys\n@export_flags(MeTTa=True)\ndef vspace_main(*args):",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "vspace_main",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def vspace_main(*args):\n    is_init=False\n    #os.system('clear')\n    t0 = monotonic_ns()\n    if verbose>0: print_cmt(underline(\"Version-Space Main\\n\"))\n    flush_console()\n    #if is_init==False: load_vspace()\n    #if is_init==False: load_flybase()\n    #if is_init==False:\n    if isinstance(args, str):",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "vspace_main_from_python",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def vspace_main_from_python(sysargv1toN=sys.argv[1:]):\n    vspace_main(sysargv1toN)\ndef handle_arg(string, skip_filetypes=['.metta', '.md','.pl', '.png', '.jpg', '.obo']):\n        lower = string.lower()\n        if lower in [\"--metta\",\"--mettalog\",\"--python\"]:\n            global argmode\n            argmode = lower.lstrip('-')\n            if verbose>0: print(\"; argmode=\", argmode)\n            return\n        if os.path.isfile(string):",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "handle_arg",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "def handle_arg(string, skip_filetypes=['.metta', '.md','.pl', '.png', '.jpg', '.obo']):\n        lower = string.lower()\n        if lower in [\"--metta\",\"--mettalog\",\"--python\"]:\n            global argmode\n            argmode = lower.lstrip('-')\n            if verbose>0: print(\"; argmode=\", argmode)\n            return\n        if os.path.isfile(string):\n            if lower.endswith('.metta'):\n                if verbose>0: print(\"; import_metta_file=\", string)",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "VSPACE_VERBOSE",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "VSPACE_VERBOSE = os.environ.get(\"VSPACE_VERBOSE\")\n# 0 = for scripts/demos\n# 1 = developer\n# 2 = debugger\nverbose = 1\nif VSPACE_VERBOSE is not None:\n try: verbose = int(VSPACE_VERBOSE) # Convert it to an integer\n except ValueError: \"\"\n# Error Handling for Janus\ntry: import janus_swi as janus",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "verbose",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "verbose = 1\nif VSPACE_VERBOSE is not None:\n try: verbose = int(VSPACE_VERBOSE) # Convert it to an integer\n except ValueError: \"\"\n# Error Handling for Janus\ntry: import janus_swi as janus\nexcept Exception as e:\n if verbose>0: print(f\"; Error: {e}\")\ntry:\n    from janus_swi import *",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "histfile",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "histfile = os.path.join(os.path.expanduser(\"~\"), \".metta_history\")\nis_init = True\noper_dict = {}\njanus_dict = {}\nsyms_dict = {}\nimport ast\nimport sys\ndef print_ast(module_name_or_source_code):\n    try:\n        source_code = get_src(module_name_or_source_code)",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "is_init",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "is_init = True\noper_dict = {}\njanus_dict = {}\nsyms_dict = {}\nimport ast\nimport sys\ndef print_ast(module_name_or_source_code):\n    try:\n        source_code = get_src(module_name_or_source_code)\n        # Parse the source code into an AST",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "oper_dict",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "oper_dict = {}\njanus_dict = {}\nsyms_dict = {}\nimport ast\nimport sys\ndef print_ast(module_name_or_source_code):\n    try:\n        source_code = get_src(module_name_or_source_code)\n        # Parse the source code into an AST\n        parsed_ast = ast.parse(source_code)",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "janus_dict",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "janus_dict = {}\nsyms_dict = {}\nimport ast\nimport sys\ndef print_ast(module_name_or_source_code):\n    try:\n        source_code = get_src(module_name_or_source_code)\n        # Parse the source code into an AST\n        parsed_ast = ast.parse(source_code)\n        # Use ast.dump to get a formatted string of the AST",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "syms_dict",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "syms_dict = {}\nimport ast\nimport sys\ndef print_ast(module_name_or_source_code):\n    try:\n        source_code = get_src(module_name_or_source_code)\n        # Parse the source code into an AST\n        parsed_ast = ast.parse(source_code)\n        # Use ast.dump to get a formatted string of the AST\n        print(ast.dump(parsed_ast, indent=4))",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "space_refs",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "space_refs = {\n    #'&vspace': lambda: the_verspace,\n    '&gptspace': lambda: the_gptspace,\n    #'&flybase': lambda: the_flybase,\n    '&parent': lambda: parent_space(),\n    '&child': lambda: child_space(),\n    '&self': self_space}\ntry:\n    readline.set_history_length(300)\n    readline.read_history_file(histfile)",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "OPTIONS",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "OPTIONS = ['apple', 'banana', 'cherry', 'date', 'elderberry']\n# The completer function\ndef completer(text, state):\n    options = [i for i in OPTIONS if i.startswith(text)]\n    if state < len(options):\n        return options[state]\n    else:\n        return None\n# Register the completer function\nreadline.set_completer(completer)",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "vspace_ordinal",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "vspace_ordinal = 0\n# Mainly a sanity loading test class\nclass MettaLearner:\n    \"\"\nclass Circles:\n    def __init__(self, initial_data=None):\n        self.data = {}\n        if initial_data:\n            for key, value in initial_data.items():\n                self.__setitem__(key, value)",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "access_error",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "access_error = True\n@export_flags(MeTTa=True)\nclass FederatedSpace(VSpace):\n    def __init__(self, space_name, unwrap=False):\n        super().__init__(space_name, unwrap)\n    def _checked_impl(self, method_name, *args):\n        if access_error:\n            raise Exception(f\"Error in FederatedSpace.{method_name}: Implementation for {method_name}({', '.join(map(str, args))}) is not complete.\")\n        return super()\n    def query(self, query_atom):",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "mylist_expr",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "mylist_expr = E()\ndef sv2mv(s):\n    return s.replace(\"_\", \"$\", 1) if s.startswith(\"_\") else \"$\" + s\n@export_flags(MeTTa=False)\ndef m2s(circles,metta_obj, depth=0):\n    r = m2s1(circles,metta_obj, depth)\n    if depth==0:\n        v = swipRef(r)\n    else:\n        v = r",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "#nested_tuple",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "#nested_tuple = (1, 2, (3, 4, (5, 6)), 7)\n#converted_list = tuple_to_list(nested_tuple)\n#print(converted_list)  # Output will be [1, 2, [3, 4, [5, 6]], 7]\ndef mv2svn(metta_obj):\n    named = metta_obj.get_name().replace('$','_')\n    if len(named)==0: return \"_0\"\n    s=named[0]\n    if(s == '_' or (s.isalpha() and  s.isupper())):\n        return named\n    else:",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "#converted_list",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "#converted_list = tuple_to_list(nested_tuple)\n#print(converted_list)  # Output will be [1, 2, [3, 4, [5, 6]], 7]\ndef mv2svn(metta_obj):\n    named = metta_obj.get_name().replace('$','_')\n    if len(named)==0: return \"_0\"\n    s=named[0]\n    if(s == '_' or (s.isalpha() and  s.isupper())):\n        return named\n    else:\n        return \"_\" + named",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "realMetta",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "realMetta = None\ndef metta_register(metta):\n    print(f\";; metta_register={the_python_runner}/{metta}\")\n    global realMetta\n    try:\n        if not metta is None:\n            if not isinstance(metta,ExtendedMeTTa):\n                realMetta = metta\n            register_vspace_atoms_pm(metta)\n    #the_python_runner.set_cmetta(metta)",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "context_atom_iters",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "context_atom_iters = {}\ndef MkExpr(py_list):\n    list = py_list\n    return E(*list)\nclass IteratorAndConversionDict:\n    def __init__(self, iterator=None, conversion_dict=None):\n        self.iterator = iterator\n        self.conversion_dict = conversion_dict if conversion_dict is not None else {}\n    def set_iterator(self, iterator):\n        self.iterator = iterator",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "rustspace_ordinal",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "rustspace_ordinal = 0\n@export_flags(Janus=True)\ndef new_rust_space(result):\n    rustspace_ordinal=rustspace_ordinal+1\n    name = f\"&vspace_{rustspace_ordinal}\"\n    space = GroundingSpace()\n    addSpaceName(name,space)\n    return res_unify(result,swipAtom(name))\n@export_flags(MeTTa=True, Janus=True)\ndef test_nondeterministic_foreign1():",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "idKey",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "idKey = 1\n@export_flags(MeTTa=True, Janus=True)\ndef test_nondeterministic_foreign3():\n    def number_generator(size):\n        for i in range(size):\n            yield i\n    context_iterators = {}  # Dictionary to store iterators by context\n    def nondet3(sz, a, context):\n        global idKey\n        control = PL_foreign_control(context)",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "NeedNameSpaceInSWIP",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "NeedNameSpaceInSWIP = True\n@export_flags(MeTTa=True, unwrap=True)\ndef load_vspace():\n   global NeedNameSpaceInSWIP\n   swip_exec(f\"ensure_loaded('{os.path.dirname(__file__)}/pyswip/metta_interp')\")\n   if NeedNameSpaceInSWIP:\n       NeedNameSpaceInSWIP = False\n       swip.retractall(\"was_asserted_space('&self')\")\n       swip.assertz(\"py_named_space('&self')\")\n@export_flags(MeTTa=True, CallsVSpace=True)",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "needed_Skip",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "needed_Skip = 0\ndef analyze_csv(base_name, file_path, sep=None):\n    print_cmt(\";;------------------------------------------------------------------------------------------------------------------\")\n    print_cmt(f\"Analyzing file: {file_path}\")\n    missing_values_list = [\"\",\"-\",\" \",\"|\",\",\",\"#\",  \"*\",  \"\\\"\\\"\",  \"+\", \"NULL\", \"N/A\", \"--\",\n                         \"NaN\",\"EMPTY\",\"None\",\"n/a\",\"(none)\",\n                         # \"0\",\"Dmel\",\"-1\",\n                          \"MISSING\", \"?\", \"undefined\", \"unknown\", \"none\", \"[]\", \".\"]\n    def read_csv(enc, skip_rows, header_option):\n            false_values_list = [\"F\", \"f\", \"False\", \"false\", \"N\", \"No\", \"no\", \"FALSE\"]",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "swip",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "swip = globals().get('swip') or PySwip()\nthe_verspace = globals().get('the_verspace') or VSpace(\"&verspace\")\nthe_flybase = globals().get('the_flybase') or VSpace(\"&flybase\")\nthe_nb_space = globals().get('the_nb_space') or VSpace(\"&nb\")\nthe_gptspace = globals().get('the_gptspace') or GptSpace()\nthe_python_runner = globals().get('the_python_runner') or None\nselected_space_name = globals().get('selected_space_name') or \"&self\"\nargmode = None\nsys_argv_length = len(sys.argv)\nif the_python_runner is None:  #MakeInteractiveMeTTa() #def MakeInteractiveMeTTa(): #global the_python_runner,the_old_runner_space,the_new_runner_space,sys_argv_length",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "the_verspace",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "the_verspace = globals().get('the_verspace') or VSpace(\"&verspace\")\nthe_flybase = globals().get('the_flybase') or VSpace(\"&flybase\")\nthe_nb_space = globals().get('the_nb_space') or VSpace(\"&nb\")\nthe_gptspace = globals().get('the_gptspace') or GptSpace()\nthe_python_runner = globals().get('the_python_runner') or None\nselected_space_name = globals().get('selected_space_name') or \"&self\"\nargmode = None\nsys_argv_length = len(sys.argv)\nif the_python_runner is None:  #MakeInteractiveMeTTa() #def MakeInteractiveMeTTa(): #global the_python_runner,the_old_runner_space,the_new_runner_space,sys_argv_length\n    the_python_runner = InteractiveMeTTa()",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "the_flybase",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "the_flybase = globals().get('the_flybase') or VSpace(\"&flybase\")\nthe_nb_space = globals().get('the_nb_space') or VSpace(\"&nb\")\nthe_gptspace = globals().get('the_gptspace') or GptSpace()\nthe_python_runner = globals().get('the_python_runner') or None\nselected_space_name = globals().get('selected_space_name') or \"&self\"\nargmode = None\nsys_argv_length = len(sys.argv)\nif the_python_runner is None:  #MakeInteractiveMeTTa() #def MakeInteractiveMeTTa(): #global the_python_runner,the_old_runner_space,the_new_runner_space,sys_argv_length\n    the_python_runner = InteractiveMeTTa()\n    #the_python_runner = MeTTa()",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "the_nb_space",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "the_nb_space = globals().get('the_nb_space') or VSpace(\"&nb\")\nthe_gptspace = globals().get('the_gptspace') or GptSpace()\nthe_python_runner = globals().get('the_python_runner') or None\nselected_space_name = globals().get('selected_space_name') or \"&self\"\nargmode = None\nsys_argv_length = len(sys.argv)\nif the_python_runner is None:  #MakeInteractiveMeTTa() #def MakeInteractiveMeTTa(): #global the_python_runner,the_old_runner_space,the_new_runner_space,sys_argv_length\n    the_python_runner = InteractiveMeTTa()\n    #the_python_runner = MeTTa()\n    the_python_runner.cwd = [os.path.dirname(os.path.dirname(__file__))]",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "the_gptspace",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "the_gptspace = globals().get('the_gptspace') or GptSpace()\nthe_python_runner = globals().get('the_python_runner') or None\nselected_space_name = globals().get('selected_space_name') or \"&self\"\nargmode = None\nsys_argv_length = len(sys.argv)\nif the_python_runner is None:  #MakeInteractiveMeTTa() #def MakeInteractiveMeTTa(): #global the_python_runner,the_old_runner_space,the_new_runner_space,sys_argv_length\n    the_python_runner = InteractiveMeTTa()\n    #the_python_runner = MeTTa()\n    the_python_runner.cwd = [os.path.dirname(os.path.dirname(__file__))]\n    the_old_runner_space = the_python_runner.space()",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "the_python_runner",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "the_python_runner = globals().get('the_python_runner') or None\nselected_space_name = globals().get('selected_space_name') or \"&self\"\nargmode = None\nsys_argv_length = len(sys.argv)\nif the_python_runner is None:  #MakeInteractiveMeTTa() #def MakeInteractiveMeTTa(): #global the_python_runner,the_old_runner_space,the_new_runner_space,sys_argv_length\n    the_python_runner = InteractiveMeTTa()\n    #the_python_runner = MeTTa()\n    the_python_runner.cwd = [os.path.dirname(os.path.dirname(__file__))]\n    the_old_runner_space = the_python_runner.space()\n    the_new_runner_space = the_python_runner.space()",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "selected_space_name",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "selected_space_name = globals().get('selected_space_name') or \"&self\"\nargmode = None\nsys_argv_length = len(sys.argv)\nif the_python_runner is None:  #MakeInteractiveMeTTa() #def MakeInteractiveMeTTa(): #global the_python_runner,the_old_runner_space,the_new_runner_space,sys_argv_length\n    the_python_runner = InteractiveMeTTa()\n    #the_python_runner = MeTTa()\n    the_python_runner.cwd = [os.path.dirname(os.path.dirname(__file__))]\n    the_old_runner_space = the_python_runner.space()\n    the_new_runner_space = the_python_runner.space()\n    print_cmt(\"The sys.argv list is:\", sys.argv)",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "argmode",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "argmode = None\nsys_argv_length = len(sys.argv)\nif the_python_runner is None:  #MakeInteractiveMeTTa() #def MakeInteractiveMeTTa(): #global the_python_runner,the_old_runner_space,the_new_runner_space,sys_argv_length\n    the_python_runner = InteractiveMeTTa()\n    #the_python_runner = MeTTa()\n    the_python_runner.cwd = [os.path.dirname(os.path.dirname(__file__))]\n    the_old_runner_space = the_python_runner.space()\n    the_new_runner_space = the_python_runner.space()\n    print_cmt(\"The sys.argv list is:\", sys.argv)\n    vspace_init()",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "sys_argv_length",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner",
        "description": "metta_vspace.metta_learner",
        "peekOfCode": "sys_argv_length = len(sys.argv)\nif the_python_runner is None:  #MakeInteractiveMeTTa() #def MakeInteractiveMeTTa(): #global the_python_runner,the_old_runner_space,the_new_runner_space,sys_argv_length\n    the_python_runner = InteractiveMeTTa()\n    #the_python_runner = MeTTa()\n    the_python_runner.cwd = [os.path.dirname(os.path.dirname(__file__))]\n    the_old_runner_space = the_python_runner.space()\n    the_new_runner_space = the_python_runner.space()\n    print_cmt(\"The sys.argv list is:\", sys.argv)\n    vspace_init()\n    the_python_runner.run(\"!(extend-py! metta_space/metta_learner)\")",
        "detail": "metta_vspace.metta_learner",
        "documentation": {}
    },
    {
        "label": "MettaLearner",
        "kind": 6,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "class MettaLearner:\n    \"\"\nclass Circles:\n    def __init__(self, initial_data=None):\n        self.data = {}\n        if initial_data:\n            for key, value in initial_data.items():\n                self.__setitem__(key, value)\n    def _get_key(self, key):\n        try:",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "Circles",
        "kind": 6,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "class Circles:\n    def __init__(self, initial_data=None):\n        self.data = {}\n        if initial_data:\n            for key, value in initial_data.items():\n                self.__setitem__(key, value)\n    def _get_key(self, key):\n        try:\n            hash_key = hash(key)\n            return ('hash', hash_key)",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "PySwipQ",
        "kind": 6,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "class PySwipQ(Query):\n    def __init__(self, *terms, **kwargs):\n        if verbose > 1:\n            for obj in terms:\n                println(obj)\n        super().__init__(*terms, **kwargs)\n    def nextSolution(self):\n        return Query.nextSolution()\n        #return PL_next_solution(Query.qid)\n    #nextSolution = staticmethod(nextSolution)",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "SqlHelper",
        "kind": 6,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "class SqlHelper:\n    colums_word = \"ColumnNames\"\n    insert_command_sql = \"INSERT INTO\"\n    @staticmethod\n    def get_query_atoms(query_atom):\n        children = query_atom.get_children()\n        new_query_atoms = []\n        for ch in children:\n            if 'limit' not in repr(ch).lower():\n                new_query_atoms.append(ch)",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "IteratorAndConversionDict",
        "kind": 6,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "class IteratorAndConversionDict:\n    def __init__(self, iterator=None, conversion_dict=None):\n        self.iterator = iterator\n        self.conversion_dict = conversion_dict if conversion_dict is not None else {}\n    def set_iterator(self, iterator):\n        self.iterator = iterator\n    def set_conversion_dict(self, conversion_dict):\n        self.conversion_dict = conversion_dict\n    def get_iterator(self):\n        return self.iterator",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "parent_space",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def parent_space():\n    return the_python_runner.parent.space()\ndef  child_space():\n    return the_python_runner.space()\ndef   self_space():\n    return the_new_runner_space\nspace_refs = {\n    #'&vspace': lambda: the_verspace,\n    '&gptspace': lambda: the_gptspace,\n    #'&flybase': lambda: the_flybase,",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": {
            "name": "",
            "kind": 2,
            "peekOfCode": "def  child_space():\n    return the_python_runner.space()\ndef   self_space():\n    return the_new_runner_space\nspace_refs = {\n    #'&vspace': lambda: the_verspace,\n    '&gptspace': lambda: the_gptspace,\n    #'&flybase': lambda: the_flybase,\n    '&parent': lambda: parent_space(),\n    '&child': lambda: child_space(),"
        },
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def  child_space():\n    return the_python_runner.space()\ndef   self_space():\n    return the_new_runner_space\nspace_refs = {\n    #'&vspace': lambda: the_verspace,\n    '&gptspace': lambda: the_gptspace,\n    #'&flybase': lambda: the_flybase,\n    '&parent': lambda: parent_space(),\n    '&child': lambda: child_space(),",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": {
            "name": "",
            "kind": 2,
            "peekOfCode": "def   self_space():\n    return the_new_runner_space\nspace_refs = {\n    #'&vspace': lambda: the_verspace,\n    '&gptspace': lambda: the_gptspace,\n    #'&flybase': lambda: the_flybase,\n    '&parent': lambda: parent_space(),\n    '&child': lambda: child_space(),\n    '&self': self_space}\ntry:"
        },
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def   self_space():\n    return the_new_runner_space\nspace_refs = {\n    #'&vspace': lambda: the_verspace,\n    '&gptspace': lambda: the_gptspace,\n    #'&flybase': lambda: the_flybase,\n    '&parent': lambda: parent_space(),\n    '&child': lambda: child_space(),\n    '&self': self_space}\ntry:",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "add_to_history_if_unique",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def add_to_history_if_unique(item, position_from_last=1):\n    for i in range(1, readline.get_current_history_length() + 1):\n        if readline.get_history_item(i) == item: return\n    insert_to_history(item, position_from_last)\ndef insert_to_history(item, position_from_last=5):\n    hist = [readline.get_history_item(i) for i in range(1, readline.get_current_history_length() + 1)]\n    # Remove the item from the list if it already exists before the insertion position\n    insertion_position = max(0, len(hist) - position_from_last)\n    if item in hist[:insertion_position]:\n        hist.remove(item)",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "insert_to_history",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def insert_to_history(item, position_from_last=5):\n    hist = [readline.get_history_item(i) for i in range(1, readline.get_current_history_length() + 1)]\n    # Remove the item from the list if it already exists before the insertion position\n    insertion_position = max(0, len(hist) - position_from_last)\n    if item in hist[:insertion_position]:\n        hist.remove(item)\n    # Insert the item at the desired position\n    hist.insert(insertion_position, item)\n    # Clear and repopulate the history\n    readline.clear_history()",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "readline_add_history",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def readline_add_history(t):\n    readline.add_history(t)\ninsert_to_history('!(get-by-key &my-dict \"A\")')\ninsert_to_history(\"@metta !\")\ninsert_to_history(\"!(mine-overlaps)\")\ninsert_to_history(\"!(try-overlaps)\")\ninsert_to_history(\"!(load-flybase-full)\")\ninsert_to_history(\"!(load-flybase-tiny)\")\n#insert_to_history(\"!(load-vspace)\")\ninsert_to_history(\"!(learn-vspace)\")",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "completer",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def completer(text, state):\n    options = [i for i in OPTIONS if i.startswith(text)]\n    if state < len(options):\n        return options[state]\n    else:\n        return None\n# Register the completer function\nreadline.set_completer(completer)\n# Use the tab key for completion\nreadline.parse_and_bind('tab: complete')",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "save",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def save(prev_h_len, histfile):\n    new_h_len = readline.get_current_history_length()\n    readline.set_history_length(400)\n    readline.append_history_file(new_h_len - prev_h_len, histfile)\natexit.register(save, h_len, histfile)\ndef export_to_metta(func):\n    setattr(func, 'metta', True)\n    if verbose>3: print_cmt(f\"{func}={getattr(func, 'export_to_metta', False)}\")\n    return func\ndef export_flags(**kwargs):",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "export_to_metta",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def export_to_metta(func):\n    setattr(func, 'metta', True)\n    if verbose>3: print_cmt(f\"{func}={getattr(func, 'export_to_metta', False)}\")\n    return func\ndef export_flags(**kwargs):\n    def decorator(func):\n        if verbose > 1: print(f\";   export_flags({repr(func)})\", end=\" \")\n        for n in kwargs:\n            setattr(func, n, kwargs[n])\n        if verbose > 1:",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "export_flags",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def export_flags(**kwargs):\n    def decorator(func):\n        if verbose > 1: print(f\";   export_flags({repr(func)})\", end=\" \")\n        for n in kwargs:\n            setattr(func, n, kwargs[n])\n        if verbose > 1:\n            for n in kwargs:\n                print(f\"{repr(n)}={repr(getattr(func, n, None))}\", end=\" \")\n            print()\n        return func",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "get_call_parts",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def get_call_parts(func):\n    sig = inspect.signature(func)\n    params = sig.parameters\n    # Constructing full parameter strings\n    param_parts = []\n    params_call_parts = []\n    var_args = var_kwargs = None\n    for param_name, param in params.items():\n        part = param_name\n        call_part = param_name",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "add_janus_methods",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def add_janus_methods(module, dict = janus_dict):\n    for name, func in inspect.getmembers(module):\n        if inspect.isfunction(func):\n            if getattr(func, \"Janus\", False) or getattr(func, \"MeTTa\", False):\n                use_name = getattr(func, 'name', name)\n                non_underscore_attrs = {attr: getattr(func, attr) for attr in dir(func) if not attr.startswith('_')}\n                if len(non_underscore_attrs)==0: continue\n                param_parts, params_call_parts = get_call_parts(func)\n                add_to_janus(use_name, param_parts, params_call_parts, func,non_underscore_attrs, janus_dict)\n@export_flags(MeTTa=True)",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "add_python_module",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def add_python_module(module, dict=oper_dict):\n    for name, func in inspect.getmembers(module):\n        if inspect.isfunction(func):\n           add_python_function(name, func, dict)\ndef add_python_function(name, func, dict):\n    use_name = getattr(func, 'name', name)\n    non_underscore_attrs = {attr: getattr(func, attr) for attr in dir(func) if not attr.startswith('_')}\n    if len(non_underscore_attrs)==0: return False\n    param_parts, params_call_parts = get_call_parts(func)\n    added = False",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "add_python_function",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def add_python_function(name, func, dict):\n    use_name = getattr(func, 'name', name)\n    non_underscore_attrs = {attr: getattr(func, attr) for attr in dir(func) if not attr.startswith('_')}\n    if len(non_underscore_attrs)==0: return False\n    param_parts, params_call_parts = get_call_parts(func)\n    added = False\n    if getattr(func, \"Janus\", False):\n        added = add_to_janus(use_name, param_parts, params_call_parts,\n            func, non_underscore_attrs, janus_dict) or added\n    if getattr(func, 'MeTTa', False):",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "add_to_metta",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def add_to_metta(name, param_parts, params_call_parts, op_kind, unwrap, func, non_underscore_attrs, dict=oper_dict):\n    hyphens, underscores = name.replace('_', '-'), name.replace('-', '_')\n    # Construct the param_str from param_parts\n    metta_params_str = ' '.join(param_parts)\n    s = f\"!({hyphens})\" if metta_params_str == \"\" else f\"!({hyphens} {metta_params_str})\"\n    add_to_history_if_unique(s)\n    if hyphens in dict:\n        return True\n    # Construct the param_str from param_parts\n    param_str = ', '.join(param_parts)",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "add_to_janus",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def add_to_janus(name, param_parts, params_call_parts, func, non_underscore_attrs, dict = janus_dict):\n    if getattr(func, 'CallsVSpace', False): return False\n    #if not getattr(func, \"Janus\", False): return False\n    suggestedName = getattr(func, 'name', name)\n    if suggestedName is not None:\n        use_name = suggestedName\n    else: use_name = name\n    for key, item in dict.items():\n        if key==use_name:\n            return True",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "find_subclasses_of",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def find_subclasses_of(module, clazz):\n    subclasses = {}\n    for name, obj in inspect.getmembers(module):\n        if inspect.isclass(obj) and issubclass(obj, clazz) and obj is not clazz:\n            subclasses[name]=obj\n    return subclasses.items()\n    for name, claz in find_subclasses_of(module,AbstractSpace):\n        print(f\"found class {claz} with name {name}\")\n        # inspect the constructor and syntesize a function that will create an object\n@export_flags(MeTTa=True)",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "add_to_swip",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def add_to_swip(name, dict = oper_dict):\n    hyphens, underscores = name.replace('_', '-'), name.replace('-', '_')\n    add_to_history_if_unique(f\"!({hyphens})\")\n    if hyphens not in dict:\n        src, local_vars = f'op = lambda : [swip_exec(\"{underscores}\")]', {}\n        exec(src, {}, local_vars)\n        if verbose>1: print_cmt(f\"swip: {hyphens}\")\n        dict[hyphens] = OperationAtom(hyphens, local_vars['op'], unwrap=False)\ndef addSpaceName(name, space):\n    global syms_dict, space_refs",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "addSpaceName",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def addSpaceName(name, space):\n    global syms_dict, space_refs\n    prev = getSpaceByName(name)\n    name = str(name)\n    if not name.startswith(\"&\"):\n        name = \"&\" + name\n    syms_dict[name] = lambda _: G(asSpaceRef(space))\n    if prev is None:\n        space_refs[name] = lambda : space\ndef getSpaceByName(name):",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "getSpaceByName",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def getSpaceByName(name):\n    global space_refs\n    if name is ValueAtom:\n        name = name.get_value()\n    if name is GroundingSpace:\n        return name\n    name = str(name)\n    if not name.startswith(\"&\"):\n        name = \"&\" + name\n    found = space_refs.get(name, None)",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "getNameBySpace",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def getNameBySpace(target_space):\n    if target_space is None:\n        return None\n    global space_refs, syms_dict\n    # Search in space_refs\n    for name, space_func in space_refs.items():\n        S = space_func()\n        if S is target_space:\n            return name\n        if S:",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "asSpaceRef",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def asSpaceRef(obj):\n    if isinstance(obj, (VSpaceRef, SpaceRef)):\n        return obj\n    return VSpaceRef(obj)\ntry:\n    class VSpaceRef(SpaceRef):\n        \"\"\"\n        A reference to a Space, which may be accessed directly, wrapped in a grounded atom,\n        or passed to a MeTTa interpreter.\n        \"\"\"",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "foreign_framed",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def foreign_framed(func):\n    def wrapper(*args, **kwargs):\n        swipl_fid = PL_open_foreign_frame()\n        result = None\n        try:\n            result = func(*args, **kwargs)\n        except Exception as e:\n            if verbose>0: print_cmt(f\"Error: {e}\")\n            if verbose>0: traceback.print_exc()\n        finally:",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "is_iterable",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def is_iterable(obj):\n    try:\n        iter(obj)\n        return True\n    except TypeError:\n        return False\n@export_flags(MeTTa=True)\ndef test_custom_v_space():\n    #test_custom_space(lambda: (lambda vs: vs.incrHome() and vs)(VSpace()))\n    test_custom_v_space1()",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "test_custom_v_space",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def test_custom_v_space():\n    #test_custom_space(lambda: (lambda vs: vs.incrHome() and vs)(VSpace()))\n    test_custom_v_space1()\n    test_custom_v_space2()\n@export_flags(MeTTa=True)\ndef test_custom_v_space1():\n    test_custom_space(lambda: VSpace())\n@export_flags(MeTTa=True)\ndef test_custom_v_space2():\n    test_custom_space(lambda: the_nb_space)",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "test_custom_v_space1",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def test_custom_v_space1():\n    test_custom_space(lambda: VSpace())\n@export_flags(MeTTa=True)\ndef test_custom_v_space2():\n    test_custom_space(lambda: the_nb_space)\n    #test_custom_space(lambda: the_new_runner_space)\ndef test_custom_space(LambdaSpaceFn):\n    def passTest(msg):\n        print(f\"Pass Test:({msg})\")\n    def failTest(msg):",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "test_custom_v_space2",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def test_custom_v_space2():\n    test_custom_space(lambda: the_nb_space)\n    #test_custom_space(lambda: the_new_runner_space)\ndef test_custom_space(LambdaSpaceFn):\n    def passTest(msg):\n        print(f\"Pass Test:({msg})\")\n    def failTest(msg):\n        print(f\"raise AssertionError({msg})\")\n        #raise AssertionError(msg)\n    def self_assertEqualNoOrder(list1, list2, msg=None):",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "test_custom_space",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def test_custom_space(LambdaSpaceFn):\n    def passTest(msg):\n        print(f\"Pass Test:({msg})\")\n    def failTest(msg):\n        print(f\"raise AssertionError({msg})\")\n        #raise AssertionError(msg)\n    def self_assertEqualNoOrder(list1, list2, msg=None):\n        \"\"\"\n        Asserts that two lists are equal, regardless of their order.\n        \"\"\"",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "s2m",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def s2m(circles,swip_obj, depth=0):\n    r = s2m1(circles,swip_obj, depth)\n    if verbose<=1: return r\n    for i in range(depth+1):\n        print(\"   \",end='')\n    print_cmt(f\"r({type(r)})={str(r)}/{repr(r)}\")\n    return r\ndef s2m1(circles,swip_obj, depth=0):\n    if verbose>1:\n        for i in range(depth):",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "s2m1",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def s2m1(circles,swip_obj, depth=0):\n    if verbose>1:\n        for i in range(depth):\n            print(\"   \",end='')\n        print_cmt(f's2m({len(circles)},{type(swip_obj)}): {str(swip_obj)}/{repr(swip_obj)}')\n    # Already converted\n    if isinstance(swip_obj, (VariableAtom, GroundedAtom, Atom, ExpressionAtom)):\n        return swip_obj\n    if isinstance(swip_obj, str):\n        return S(swip_obj)",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "sv2mv",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def sv2mv(s):\n    return s.replace(\"_\", \"$\", 1) if s.startswith(\"_\") else \"$\" + s\n@export_flags(MeTTa=False)\ndef m2s(circles,metta_obj, depth=0):\n    r = m2s1(circles,metta_obj, depth)\n    if depth==0:\n        v = swipRef(r)\n    else:\n        v = r\n    if verbose<=1: return v",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "m2s",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def m2s(circles,metta_obj, depth=0):\n    r = m2s1(circles,metta_obj, depth)\n    if depth==0:\n        v = swipRef(r)\n    else:\n        v = r\n    if verbose<=1: return v\n    for i in range(depth+1):\n        print(\"   \",end='')\n    print(f\"r({type(r)})={r}\")",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "swipAtom",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def swipAtom(m):\n    a = PySwipAtom(str(m))\n    return a\ndef swipRef(a):\n    if isinstance(a, (Term)):\n       return a\n    v = Variable()\n    v.unify(a)\n    return v\ndef unwrap_pyobjs(metta_obj):",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "swipRef",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def swipRef(a):\n    if isinstance(a, (Term)):\n       return a\n    v = Variable()\n    v.unify(a)\n    return v\ndef unwrap_pyobjs(metta_obj):\n    if isinstance(metta_obj, ExpressionAtom):\n       return metta_obj\n    elif isinstance(metta_obj, GroundedAtom):",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "unwrap_pyobjs",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def unwrap_pyobjs(metta_obj):\n    if isinstance(metta_obj, ExpressionAtom):\n       return metta_obj\n    elif isinstance(metta_obj, GroundedAtom):\n       metta_obj = metta_obj.get_object()\n    if isinstance(metta_obj, ValueObject):\n       metta_obj = metta_obj.value\n    return metta_obj\ndef m2s1(circles, metta_obj, depth=0, preferStringToAtom = None, preferListToCompound = False):\n    var = circles.get(metta_obj, None)",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "m2s1",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def m2s1(circles, metta_obj, depth=0, preferStringToAtom = None, preferListToCompound = False):\n    var = circles.get(metta_obj, None)\n    if var is not None:\n        return var\n    metta_obj = unwrap_pyobjs(metta_obj)\n    var = circles.get(metta_obj, None)\n    if var is not None:\n        return var\n    if verbose>1:\n        for i in range(depth):",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "tuple_to_list",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def tuple_to_list(t):\n    return list(map(tuple_to_list, t)) if isinstance(t, (tuple, list)) else t\n# Example usage:\n#nested_tuple = (1, 2, (3, 4, (5, 6)), 7)\n#converted_list = tuple_to_list(nested_tuple)\n#print(converted_list)  # Output will be [1, 2, [3, 4, [5, 6]], 7]\ndef mv2svn(metta_obj):\n    named = metta_obj.get_name().replace('$','_')\n    if len(named)==0: return \"_0\"\n    s=named[0]",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "mv2svn",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def mv2svn(metta_obj):\n    named = metta_obj.get_name().replace('$','_')\n    if len(named)==0: return \"_0\"\n    s=named[0]\n    if(s == '_' or (s.isalpha() and  s.isupper())):\n        return named\n    else:\n        return \"_\" + named\ndef m2s3(circles, metta_obj, depth, preferStringToAtom, preferListToCompound):\n    for name, value in circles:",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "m2s3",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def m2s3(circles, metta_obj, depth, preferStringToAtom, preferListToCompound):\n    for name, value in circles:\n        if  name is metta_obj:\n            return value\n    if isinstance(metta_obj, SpaceRef):\n        return swiplist_to_swip(circles,metta_obj.get_atoms(),depth+1)\n    if isinstance(metta_obj, list):\n        return swiplist_to_swip(circles,metta_obj)\n    if isinstance(metta_obj, ExpressionAtom):\n        ch = metta_obj.get_children()",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "swiplist_to_swip",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def swiplist_to_swip(circles,retargs, depth=0):\n    sv = [m2s1(circles,item,depth) for item in retargs]\n    v = Variable()\n    v.unify(sv)\n    return v\ndef list_to_termv(circles,retargs, depth=0):\n    sv = [m2s1(circles,item,depth) for item in retargs]\n    return sv\ndef _np_atom_type(npobj):\n    pt(\"npobj=\",npobj)",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "list_to_termv",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def list_to_termv(circles,retargs, depth=0):\n    sv = [m2s1(circles,item,depth) for item in retargs]\n    return sv\ndef _np_atom_type(npobj):\n    pt(\"npobj=\",npobj)\n    return E(S('NPArray'), E(*[ValueAtom(s, 'Number') for s in npobj.shape]))\ndef dewrap(arg):\n    r = unwrap_pyobjs(arg)\n    print(f\"dw({type(arg)})={type(r)}\")\n    return r",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "dewrap",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def dewrap(arg):\n    r = unwrap_pyobjs(arg)\n    print(f\"dw({type(arg)})={type(r)}\")\n    return r\ndef wrapnpop(func):\n    def wrapper(*args):\n        a = [dewrap(arg) for arg in args]\n        res = func(*a)\n        typ = _np_atom_type(res)\n        return [G(VSNumpyValue(res), typ)]",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "wrapnpop",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def wrapnpop(func):\n    def wrapper(*args):\n        a = [dewrap(arg) for arg in args]\n        res = func(*a)\n        typ = _np_atom_type(res)\n        return [G(VSNumpyValue(res), typ)]\n    return wrapper\ndef color(t, c):\n    cmap = [90, 91, 31, 93, 92, 32, 36, 96, 94, 34, 35, 95, 38]\n    return f\"\\033[{cmap[c % len(cmap)]}m{t}\\033[0m\"",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "color",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def color(t, c):\n    cmap = [90, 91, 31, 93, 92, 32, 36, 96, 94, 34, 35, 95, 38]\n    return f\"\\033[{cmap[c % len(cmap)]}m{t}\\033[0m\"\ndef oblique(t):\n    return f\"\\033[3m{t}\\033[0m\"\ndef underline(t):\n    return f\"\\033[4m{t}\\033[0m\"\ndef expr_vars(expr):\n    if isinstance(expr, SymbolAtom):\n        return []",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "oblique",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def oblique(t):\n    return f\"\\033[3m{t}\\033[0m\"\ndef underline(t):\n    return f\"\\033[4m{t}\\033[0m\"\ndef expr_vars(expr):\n    if isinstance(expr, SymbolAtom):\n        return []\n    elif isinstance(expr, VariableAtom):\n        return [str(expr)]\n    elif isinstance(expr, ExpressionAtom):",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "underline",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def underline(t):\n    return f\"\\033[4m{t}\\033[0m\"\ndef expr_vars(expr):\n    if isinstance(expr, SymbolAtom):\n        return []\n    elif isinstance(expr, VariableAtom):\n        return [str(expr)]\n    elif isinstance(expr, ExpressionAtom):\n        return [e for c in expr.get_children() for e in expr_vars(c)]\n    elif isinstance(expr, GroundedAtom):",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "expr_vars",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def expr_vars(expr):\n    if isinstance(expr, SymbolAtom):\n        return []\n    elif isinstance(expr, VariableAtom):\n        return [str(expr)]\n    elif isinstance(expr, ExpressionAtom):\n        return [e for c in expr.get_children() for e in expr_vars(c)]\n    elif isinstance(expr, GroundedAtom):\n        return []\n    else:",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "color_expr",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def color_expr(expr, level=0, unif_vars=None):\n    name = str(expr)\n    if level == 0:\n        unif_vars = frozenset(e for e, c in Counter(expr_vars(expr)).items() if c > 1) \\\n            if unif_vars is None else frozenset()\n    if isinstance(expr, SymbolAtom):\n        return name\n    elif isinstance(expr, VariableAtom):\n        return oblique(name) if name in unif_vars else name\n    elif isinstance(expr, ExpressionAtom):",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "print_l_e",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def print_l_e(obj):\n    if obj is None:\n        print(\"None!\")\n        return obj\n    if isinstance(obj, str):\n        print(obj)\n        return obj\n    try:\n        # Attempt to iterate over the object\n        for item in obj:",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "print_cmt",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def print_cmt(*args, prefix=\";; \"):\n   for arg in args:\n       println(arg, prefix=prefix)\n       flush_console()\n@export_flags(MeTTa=True, name=\"print\", unwrap=True)\ndef println(orig, prefix=\"\"):\n    \"\"\"\n    Prints the given object and returns it.\n    Args:\n        orig: The object to be printed.",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "println",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def println(orig, prefix=\"\"):\n    \"\"\"\n    Prints the given object and returns it.\n    Args:\n        orig: The object to be printed.\n    Returns:\n        The same object that was passed in.\n    \"\"\"\n    try:\n      prefix_print(prefix, orig)",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "prefix_print",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def prefix_print(prefix, orig):\n    obj = unwrap_pyobjs(orig)\n    if isinstance(obj, str):\n        objlns = obj.splitlines()\n        for r in objlns:\n            print(prefix, r)\n        return\n    if isinstance(obj, (AbstractSpace, GroundingSpaceRef, SpaceRef)):\n        s = obj\n        f = getattr(s,\"atom_count\", None)",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "pt1",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def pt1(obj):\n    if isinstance(obj, str):\n        print(f\"{repr(obj)}\", end= \" \")\n    elif not isinstance(obj, (Term, Variable)):\n        print(f\" pt: {type(obj)}={str(obj)}={repr(obj)}\", end= \" \")\n        if isinstance(obj, list):\n            obj = obj[0]\n            print(f\" pt(0): {type(obj)}={str(obj)}={repr(obj)}\", end= \" \")\n    else:\n        fn = Functor(\"pp\")",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "pt",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def pt(*objs):\n    r = objs\n    for o in objs:\n        if isinstance(o, str):\n            print(o, end=\"\")\n        else: r= pt1(o)\n    print()\n    return r\n@export_flags(MeTTa=True, op=\"VSpacePatternOperation\")\ndef test_s(metta_obj):",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "test_s",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def test_s(metta_obj):\n    circles = Circles()\n    pt(metta_obj)\n    swip_obj = m2s(circles,metta_obj)\n    pt(swip_obj)\n    new_mo = s2m(circles,swip_obj)\n    pt(new_mo)\n    return new_mo\ndef get_sexpr_input(prmpt):\n    expr, inside_quotes, prev_char = \"\", False, None",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "get_sexpr_input",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def get_sexpr_input(prmpt):\n    expr, inside_quotes, prev_char = \"\", False, None\n    while True:\n        line = input(prmpt)\n        flush_console()\n        for char in line:\n            if char == '\"' and prev_char != '\\\\':\n                inside_quotes = not inside_quotes\n            expr += char\n            prev_char = char",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "sync_space",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def sync_space(named):\n    \"\"\ndef the_running_metta_space():\n    global the_new_runner_space\n    global the_python_runner\n    #if the_python_runner.parent!=the_python_runner:\n    #    return the_python_runner.parent.space()\n    if the_new_runner_space is not None: return the_new_runner_space\n    return the_python_runner.parent.space()\nimport re",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "the_running_metta_space",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def the_running_metta_space():\n    global the_new_runner_space\n    global the_python_runner\n    #if the_python_runner.parent!=the_python_runner:\n    #    return the_python_runner.parent.space()\n    if the_new_runner_space is not None: return the_new_runner_space\n    return the_python_runner.parent.space()\nimport re\ndef results2bindings(vars, values):\n    new_bindings_set = BindingsSet.empty()",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "results2bindings",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def results2bindings(vars, values):\n    new_bindings_set = BindingsSet.empty()\n    if len(values) == 0 or len(vars) != len(values[0]):\n        return new_bindings_set\n    for value in values:\n        bindings = Bindings()\n        for i in range(len(vars)):\n            bindings.add_var_binding(vars[i], ValueAtom(str(value[i])))\n        new_bindings_set.push(bindings)\n    return new_bindings_set",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "wrapsqlop",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def wrapsqlop(func):\n    def wrapper(*args):\n        if len(args) > 1:\n            if isinstance(args[0], GroundedAtom):\n                space1 = args[0].get_object()\n                if isinstance(space1, SpaceRef):\n                    if isinstance(args[1], GroundedAtom):\n                        space2 = args[1].get_object()\n                        if isinstance(space2, SpaceRef):\n                            args = args[2:]",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "pl_select",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def pl_select(*args):\n    print_cmt(\"pl_select: \",args)\n    flush_console()\ndef pl_insert(*args):\n    print_cmt(\"pl_insert: \",args)\n    flush_console()\ndef np_array(args):\n    print_cmt(\"np_array=\",args)\n    return np.array(args)\ndef np_vector(*args):",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "pl_insert",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def pl_insert(*args):\n    print_cmt(\"pl_insert: \",args)\n    flush_console()\ndef np_array(args):\n    print_cmt(\"np_array=\",args)\n    return np.array(args)\ndef np_vector(*args):\n    print_cmt(\"np_vector=\",args)\n    return np.array(args)\nrealMetta = None",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "np_array",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def np_array(args):\n    print_cmt(\"np_array=\",args)\n    return np.array(args)\ndef np_vector(*args):\n    print_cmt(\"np_vector=\",args)\n    return np.array(args)\nrealMetta = None\ndef metta_register(metta):\n    print(f\";; metta_register={the_python_runner}/{metta}\")\n    global realMetta",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "np_vector",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def np_vector(*args):\n    print_cmt(\"np_vector=\",args)\n    return np.array(args)\nrealMetta = None\ndef metta_register(metta):\n    print(f\";; metta_register={the_python_runner}/{metta}\")\n    global realMetta\n    try:\n        if not metta is None:\n            if not isinstance(metta,ExtendedMeTTa):",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "metta_register",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def metta_register(metta):\n    print(f\";; metta_register={the_python_runner}/{metta}\")\n    global realMetta\n    try:\n        if not metta is None:\n            if not isinstance(metta,ExtendedMeTTa):\n                realMetta = metta\n            register_vspace_atoms_pm(metta)\n    #the_python_runner.set_cmetta(metta)\n    #print(\";;\", metta.pymods)",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "res_unify",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def res_unify(s,v):\n  if isinstance(v, str):\n      if isinstance(s, str):\n          return s == v\n      return s.unify(swipAtom(v))\n  return s.unify(v)\n# Define the foreign functions\n@export_flags(Janus=True)\ndef query_from_space(space_name, query_atom, result):\n    space = getSpaceByName(space_name)",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "query_from_space",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def query_from_space(space_name, query_atom, result):\n    space = getSpaceByName(space_name)\n    if space:\n        atoms = space.query(query_atom)\n        return res_unify(result,atoms)\n    return False\n@export_flags(Janus=True)\ndef add_to_space(space_name, atom):\n    space = getSpaceByName(space_name)\n    if space:",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "add_to_space",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def add_to_space(space_name, atom):\n    space = getSpaceByName(space_name)\n    if space:\n        circles = Circles()\n        atom = s2m(circles,atom)\n        if isinstance(space, SpaceRef):\n            return space.add_atom(atom)\n        return space.add(atom)\n    return False\n@export_flags(Janus=True)",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "remove_from_space",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def remove_from_space(space_name, atom):\n    space = getSpaceByName(space_name)\n    if space:\n        circles = Circles()\n        atom = s2m(circles,atom)\n        return space.remove(atom)\n    return False\n@export_flags(Janus=True)\ndef replace_in_space(space_name, from_atom, to_atom):\n    space = getSpaceByName(space_name)",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "replace_in_space",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def replace_in_space(space_name, from_atom, to_atom):\n    space = getSpaceByName(space_name)\n    if space:\n        circles = Circles()\n        to_atom = s2m(circles,to_atom)\n        from_atom = s2m(circles,from_atom)\n        return space.replace(from_atom, to_atom)\n    return False\n@export_flags(Janus=True)\ndef atom_count_from_space(space_name, result):",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "atom_count_from_space",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def atom_count_from_space(space_name, result):\n    space = getSpaceByName(space_name)\n    if space:\n        return res_unify(result,space.atom_count())\n    return False\n@export_flags(Janus=True)\ndef get_atoms_from_space(space_name, result):\n    space = getSpaceByName(space_name)\n    if space:\n        circles = Circles()",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "get_atoms_from_space",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def get_atoms_from_space(space_name, result):\n    space = getSpaceByName(space_name)\n    if space:\n        circles = Circles()\n        atoms = list(space.get_atoms())\n        satoms = [m2s(circles, atom) for atom in atoms]\n        return res_unify(result,satoms)\n    return False\ncontext_atom_iters = {}\ndef MkExpr(py_list):",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "MkExpr",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def MkExpr(py_list):\n    list = py_list\n    return E(*list)\nclass IteratorAndConversionDict:\n    def __init__(self, iterator=None, conversion_dict=None):\n        self.iterator = iterator\n        self.conversion_dict = conversion_dict if conversion_dict is not None else {}\n    def set_iterator(self, iterator):\n        self.iterator = iterator\n    def set_conversion_dict(self, conversion_dict):",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "get_atoms_iter_from_space",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def get_atoms_iter_from_space(space_name):\n    space = getSpaceByName(space_name)\n    if space:\n        get_iterator =  getattr(space,\"atoms_iter\", None) # Create a new iterator\n        if get_iterator is not None:\n            return get_iterator()\n        else:\n            get_iterator =  getattr(space,\"get_atoms\", None) # Create a new iterator\n            if get_iterator is not None:\n                return iter(get_iterator)",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "atoms_iter_from_space",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def atoms_iter_from_space(space_name, result, context):\n    global idKey, context_atom_iters\n    control = PL_foreign_control(context)\n    context = PL_foreign_context(context)\n    id = context\n    if control == PL_FIRST_CALL:\n        id = idKey\n        idKey= idKey+1\n        iterator = get_atoms_iter_from_space(space_name)\n        if iterator is not None:",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "add_to_history_if_unique_pl",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def add_to_history_if_unique_pl(item, position_from_last=1):\n    for i in range(1, readline.get_current_history_length() + 1):\n        if readline.get_history_item(i) == item: return\n    insert_to_history(item, position_from_last)\ndef reg_pyswip_foreign():\n    add_janus_methods(sys.modules[__name__], dict = oper_dict)\n    test_nondeterministic_foreign()\n    def py_eval(e, result):\n        return res_unify(result,eval(str(e)))\n    py_eval.arity = 2",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "reg_pyswip_foreign",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def reg_pyswip_foreign():\n    add_janus_methods(sys.modules[__name__], dict = oper_dict)\n    test_nondeterministic_foreign()\n    def py_eval(e, result):\n        return res_unify(result,eval(str(e)))\n    py_eval.arity = 2\n    registerForeign(py_eval)\n    # Register the foreign functions in PySwip\n    #registerForeign(new_rust_space, arity=1)\n    #registerForeign(query_from_space, arity=3)",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "find_rust_space",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def find_rust_space(space_name, result):\n    space = getSpaceByName(space_name)\n    named = getNameBySpace(space)\n    if space:\n        return res_unify(result,named)\n    return False\nrustspace_ordinal = 0\n@export_flags(Janus=True)\ndef new_rust_space(result):\n    rustspace_ordinal=rustspace_ordinal+1",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "new_rust_space",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def new_rust_space(result):\n    rustspace_ordinal=rustspace_ordinal+1\n    name = f\"&vspace_{rustspace_ordinal}\"\n    space = GroundingSpace()\n    addSpaceName(name,space)\n    return res_unify(result,swipAtom(name))\n@export_flags(MeTTa=True, Janus=True)\ndef test_nondeterministic_foreign1():\n    def nondet(a, context):\n        control = PL_foreign_control(context)",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "test_nondeterministic_foreign1",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def test_nondeterministic_foreign1():\n    def nondet(a, context):\n        control = PL_foreign_control(context)\n        context = PL_foreign_context(context)\n        if control == PL_FIRST_CALL:\n            context = 0\n            a.unify(int(context))\n            context += 1\n            return PL_retry(context)\n        elif control == PL_REDO:",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "test_nondeterministic_foreign2",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def test_nondeterministic_foreign2():\n    def number_generator():\n        for i in range(10):\n            yield i\n    iterator = number_generator()\n    def nondet2(a, context):\n        control = PL_foreign_control(context)\n        context = PL_foreign_context(context)\n        #global iterator  # Use the global iterator object\n        if control == PL_FIRST_CALL:",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "test_nondeterministic_foreign3",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def test_nondeterministic_foreign3():\n    def number_generator(size):\n        for i in range(size):\n            yield i\n    context_iterators = {}  # Dictionary to store iterators by context\n    def nondet3(sz, a, context):\n        global idKey\n        control = PL_foreign_control(context)\n        context = PL_foreign_context(context)\n        id = context",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "test_nondeterministic_foreign",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def test_nondeterministic_foreign():\n    test_nondeterministic_foreign1()\n    test_nondeterministic_foreign2()\n    test_nondeterministic_foreign3()\n    def hello(t):\n        print_cmt(\"Hello,\", t)\n    hello.arity = 1\n    registerForeign(hello, arity=1)\n    def hello1(t):\n        readline.replace_history_item(0, t)",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "swip_to_metta_wrapper",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def swip_to_metta_wrapper(swip_obj, metta_obj):\n    circles = Circles()\n    result1 = m2s(circles,s2m(circles,swip_obj))\n    result2 = m2s(circles,metta_obj)\n    #metta_obj.unify(m2s(circles,result))\n    return result2.unify(result1)\n    #return True\n@export_flags(Janus=True)\ndef metta_to_swip_wrapper(metta_obj, swip_obj):\n    circles = Circles()",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "metta_to_swip_wrapper",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def metta_to_swip_wrapper(metta_obj, swip_obj):\n    circles = Circles()\n    result1 = m2s(circles,metta_obj)\n    result2 = m2s(circles,swip_obj)\n    #swip_obj.unify(result)\n    return result2.unify(result1)\n    #return True\n@export_flags(MeTTa=True)\ndef metta_to_swip_tests1():\n    # Register the methods as foreign predicates",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "metta_to_swip_tests1",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def metta_to_swip_tests1():\n    # Register the methods as foreign predicates\n    registerForeign(swip_to_metta_wrapper, arity=2)\n    registerForeign(metta_to_swip_wrapper, arity=2)\n    circles = Circles()\n    # Usage:\n    swip_functor = Functor(PySwipAtom(\"example\"), 2, [PySwipAtom(\"sub1\"), 3.14])\n    print_cmt(f\"swip_functor={swip_functor}\"),\n    metta_expr = s2m(circles,swip_functor)\n    print_cmt(f\"metta_expr={metta_expr}\"),",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "metta_to_swip_tests2",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def metta_to_swip_tests2():\n    # Register the methods as foreign predicates\n    registerForeign(swip_to_metta_wrapper, arity=2)\n    registerForeign(metta_to_swip_wrapper, arity=2)\n    circles = Circles()\n    # Now you can use the methods in PySwip queries\n    println(list(swip.query(\"swip_to_metta_wrapper('example', X).\")))\n    println(list(swip.query(\"metta_to_swip_wrapper(X, 'example').\")))\n    # Usage:\n    swip_list = [\"a\", \"b\", 3]",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "load_vspace",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def load_vspace():\n   global NeedNameSpaceInSWIP\n   swip_exec(f\"ensure_loaded('{os.path.dirname(__file__)}/pyswip/flybase_main')\")\n   if NeedNameSpaceInSWIP:\n       NeedNameSpaceInSWIP = False\n       swip.retractall(\"was_asserted_space('&self')\")\n       swip.assertz(\"py_named_space('&self')\")\n@export_flags(MeTTa=True, CallsVSpace=True)\ndef mine_overlaps():\n   load_vspace()",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "mine_overlaps",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def mine_overlaps():\n   load_vspace()\n   swip_exec(\"mine_overlaps\")\n   #readline_add_history(\"!(try-overlaps)\")\n@export_flags(MeTTa=True, CallsVSpace=True)\ndef try_overlaps():\n   load_vspace()\n   swip_exec(\"try_overlaps\")\n@export_flags(MeTTa=True, CallsVSpace=True)\ndef learn_vspace():",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "try_overlaps",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def try_overlaps():\n   load_vspace()\n   swip_exec(\"try_overlaps\")\n@export_flags(MeTTa=True, CallsVSpace=True)\ndef learn_vspace():\n   load_vspace()\n   swip_exec(\"learn_vspace(60)\")\n@export_flags(MeTTa=True, CallsVSpace=True)\ndef mettalog():\n   load_vspace()",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "learn_vspace",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def learn_vspace():\n   load_vspace()\n   swip_exec(\"learn_vspace(60)\")\n@export_flags(MeTTa=True, CallsVSpace=True)\ndef mettalog():\n   load_vspace()\n   swip_exec(\"repl\")\n@export_flags(MeTTa=True)\ndef register_mettalog_op_new(fn, n):\n   arg_types = [AtomType.ATOM] * (n) + [AtomType.UNDEFINED]",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "mettalog",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def mettalog():\n   load_vspace()\n   swip_exec(\"repl\")\n@export_flags(MeTTa=True)\ndef register_mettalog_op_new(fn, n):\n   arg_types = [AtomType.ATOM] * (n) + [AtomType.UNDEFINED]\n   op = OperationAtom(fn, lambda *args:\n                  print_cmt(f\"eval_mettalog('{fn}', {args})\") +\n                  eval_mettalog(fn, *args),\n                              type_names=arg_types,",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "register_mettalog_op_new",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def register_mettalog_op_new(fn, n):\n   arg_types = [AtomType.ATOM] * (n) + [AtomType.UNDEFINED]\n   op = OperationAtom(fn, lambda *args:\n                  print_cmt(f\"eval_mettalog('{fn}', {args})\") +\n                  eval_mettalog(fn, *args),\n                              type_names=arg_types,\n                              unwrap=True)\n   the_python_runner.register_atom(fn, op)\n   return op\n@export_flags(MeTTa=True, CallsVSpace=True)",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "use_mettalog",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def use_mettalog():\n   load_vspace()\n   register_mettalog_op(\"pragma!\",2)\n   register_mettalog_op(\"match\",3)\n   return register_mettalog_op(\"import!\",2)\n@export_flags(MeTTa=True)\ndef register_mettalog_op(fn, n):\n    arg_types = [AtomType.ATOM] * (n) + [AtomType.UNDEFINED]\n    n_args = ', '.join(['arg' + str(i) for i in range(n)])\n    local_vars = {}",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "register_mettalog_op",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def register_mettalog_op(fn, n):\n    arg_types = [AtomType.ATOM] * (n) + [AtomType.UNDEFINED]\n    n_args = ', '.join(['arg' + str(i) for i in range(n)])\n    local_vars = {}\n    src = f'lop = lambda {n_args}: eval_mettalog(\"{fn}\", {n_args})'\n    exec(src, globals(), local_vars)\n    lop = local_vars['lop']\n    #print_cmt(src) print_cmt(type(the_python_runner))\n    op = OperationAtom(fn, lop, type_names=arg_types, unwrap=False)\n    oper_dict[fn]=op",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "eval_mettalog",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def eval_mettalog(fn, *args):\n    print_cmt(f\"eval_mettalog('{fn}', {args})\")\n    return list(_eval_mettalog(fn,args))\ndef _eval_mettalog(fn, *args):\n    circles = Circles()\n    expr = [fn] + list(args) # Prepend fn to args list\n    swip_obj = m2s(circles,expr)\n    flush_console()\n    call_sexpr = Functor(\"call_sexpr\", 5)\n    #user = newModule(\"user\")",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "mettalog_pl",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def mettalog_pl():\n   load_vspace()\n   swip_exec(\"break\")\n@export_flags(CallsVSpace=True)\ndef load_flybase(size):\n   load_vspace()\n   swip_exec(f\"load_flybase({size})\")\n   #readline_add_history(\"!(mine-overlaps)\")\n@export_flags(MeTTa=True)\ndef swip_exec(qry):",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "load_flybase",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def load_flybase(size):\n   load_vspace()\n   swip_exec(f\"load_flybase({size})\")\n   #readline_add_history(\"!(mine-overlaps)\")\n@export_flags(MeTTa=True)\ndef swip_exec(qry):\n    swip_exec_ff(qry)\n@foreign_framed\ndef swip_exec_ff(qry):\n    #from metta_vspace import swip",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "swip_exec",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def swip_exec(qry):\n    swip_exec_ff(qry)\n@foreign_framed\ndef swip_exec_ff(qry):\n    #from metta_vspace import swip\n    #if is_init==True:\n    #   print_cmt(\"Not running Query: \",qry)\n    #   return\n    for r in swip.query(qry):\n        print_cmt(r)",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "swip_exec_ff",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def swip_exec_ff(qry):\n    #from metta_vspace import swip\n    #if is_init==True:\n    #   print_cmt(\"Not running Query: \",qry)\n    #   return\n    for r in swip.query(qry):\n        print_cmt(r)\n@export_flags(MeTTa=True)\ndef test_custom_m_space():\n    class TestSpace(AbstractSpace):",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "test_custom_m_space",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def test_custom_m_space():\n    class TestSpace(AbstractSpace):\n        def __init__(self, unwrap=False):\n            super().__init__()\n            self.atoms_list = []\n            self.unwrap = unwrap\n        # NOTE: this is a naive implementation barely good enough to pass the tests\n        # Don't take this as a guide to implementing a space query function\n        def query(self, query_atom):\n            # Extract only the variables from the query atom",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "timeFrom",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def timeFrom(w, t0):\n    elapsed_ns = monotonic_ns() - t0\n    elapsed_s = elapsed_ns / 1e9\n    elapsed_ms = elapsed_ns / 1e6\n    elapsed_us = elapsed_ns / 1e3\n    if elapsed_s >= 1:\n        print_cmt(f\"{w} took {elapsed_s:.5f} seconds\")\n    elif elapsed_ms >= 1:\n        print_cmt(f\"{w} took {elapsed_ms:.5f} milliseconds\")\n    else:",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "call_mettalog",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def call_mettalog(line, parseWithRust = False):\n    if parseWithRust:\n        expr = self.parse_single(sline)\n        if verbose>1: print_cmt(f\"% S-Expr {line}\")\n        if verbose>1: print_cmt(f\"% M-Expr {expr}\")\n        circles = Circles()\n        swip_obj = m2s(circles,expr);\n        if verbose>1: print_cmt(f\"% P-Expr {swip_obj}\")\n    else:\n        swip_obj = line",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "redirect_stdout",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def redirect_stdout(inner_function):\n    old_stdout = sys.stdout # Save the current stdout stream\n    new_stdout = io.StringIO() # Create a new StringIO buffer\n    sys.stdout = new_stdout # Redirect stdout to the new buffer\n    try:\n        inner_function() # Execute the inner function\n    finally:\n        sys.stdout = old_stdout # Restore the original stdout stream\n    output = new_stdout.getvalue() # Retrieve the output from the new buffer\n    new_stdout.close() # Close the new buffer",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "vspace_init",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def vspace_init():\n    if getattr(vspace_init,\"is_init_ran\", False) == True:\n        return\n    vspace_init.is_init_ran = True\n    t0 = monotonic_ns()\n    #os.system('clear')\n    print_cmt(underline(f\"Version-Space Init: {__file__}\\n\"))\n    #import site\n    #print_cmt (\"Site Packages: \",site.getsitepackages())\n    #test_nondeterministic_foreign()",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "flush_console",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def flush_console():\n    try:\n      if sys.__stdout__ is not None: sys.__stdout__.flush()\n    except Exception: \"\"\n    try:\n      if sys.__stderr__ is not None: sys.__stderr__.flush()\n    except Exception: \"\"\n    try:\n      if sys.stderr is not None and not (sys.stderr is sys.__stderr__): sys.sys.stderr.flush()\n    except Exception: \"\"",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "detect_encoding",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def detect_encoding(file_path, sample_size=20000):\n    with open(file_path, 'rb') as f:\n        raw = f.read(sample_size)\n    return chardet.detect(raw)['encoding']\nfrom collections.abc import Iterable\ndef is_lisp_dashed(s):\n    pattern = re.compile('^[A-Za-z0-9-_:]+$')\n    return bool(pattern.match(s))\ndef item_string(lst, functor=\"\"):\n    if isinstance(lst, str):",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "is_lisp_dashed",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def is_lisp_dashed(s):\n    pattern = re.compile('^[A-Za-z0-9-_:]+$')\n    return bool(pattern.match(s))\ndef item_string(lst, functor=\"\"):\n    if isinstance(lst, str):\n        if len(lst) == 0:\n            return '\"\"'\n        if any(char in lst for char in [' ', '\"', \"'\", \"(\", \")\", \".\", \"\\\\\"]):\n            return json.dumps(lst)\n        if isinstance(lst, (int, float)):",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "item_string",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def item_string(lst, functor=\"\"):\n    if isinstance(lst, str):\n        if len(lst) == 0:\n            return '\"\"'\n        if any(char in lst for char in [' ', '\"', \"'\", \"(\", \")\", \".\", \"\\\\\"]):\n            return json.dumps(lst)\n        if isinstance(lst, (int, float)):\n            return repr(lst)\n        if is_float_string(lst):\n            return repr(float(lst))",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "list_string",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def list_string(lst, functor=\"# \"):\n    try:\n        if isinstance(lst, Iterable) and not isinstance(lst, str):\n            if len(lst) == 0:\n                return '()'\n            return '(' + functor + ' '.join([item_string(vv) for vv in lst]) + ')'\n        else:\n            return item_string(lst)\n    except TypeError:\n        return item_string(lst)",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "is_float_string",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def is_float_string(s):\n    return bool(re.fullmatch(r'[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?', s))\nimport pandas as pd\ndef update_dataframe_skipping_first_row(df):\n    \"\"\"\n    Takes a DataFrame, skips the first row, recalculates unique counts and value counts,\n    and infers the most appropriate datatypes for each column.\n    Parameters:\n    df (pandas.DataFrame): The original DataFrame.\n    Returns:",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "update_dataframe_skipping_first_row",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def update_dataframe_skipping_first_row(df):\n    \"\"\"\n    Takes a DataFrame, skips the first row, recalculates unique counts and value counts,\n    and infers the most appropriate datatypes for each column.\n    Parameters:\n    df (pandas.DataFrame): The original DataFrame.\n    Returns:\n    pandas.DataFrame: A DataFrame with the first row removed, updated with recalculated\n    uniqueness and value counts, and with inferred datatypes.\n    \"\"\"",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "analyze_csv_basename",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def analyze_csv_basename(file_path, sep=None):\n    base_name = os.path.basename(file_path)\n    base_name = base_name.replace('.tsv', '')\n    base_name = base_name.replace('.fb', '')\n    # Remove a sequence like _fb_####_## (where # represents a digit)\n    base_name = re.sub(r'_fb_\\d{4}_\\d{2}', '', base_name)\n    # Remove a sequence like ####_## at any place\n    base_name = re.sub(r'\\d{4}_\\d{2}', '', base_name)\n    # Replace periods with underscores, if not part of a file extension\n    base_name = re.sub(r'\\.(?=.*\\.)', '_', base_name)",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "analyze_csv",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def analyze_csv(base_name, file_path, sep=None):\n    print_cmt(\";;------------------------------------------------------------------------------------------------------------------\")\n    print_cmt(f\"Analyzing file: {file_path}\")\n    missing_values_list = [\"\",\"-\",\" \",\"|\",\",\",\"#\",  \"*\",  \"\\\"\\\"\",  \"+\", \"NULL\", \"N/A\", \"--\",\n                         \"NaN\",\"EMPTY\",\"None\",\"n/a\",\"(none)\",\n                         # \"0\",\"Dmel\",\"-1\",\n                          \"MISSING\", \"?\", \"undefined\", \"unknown\", \"none\", \"[]\", \".\"]\n    def read_csv(enc, skip_rows, header_option):\n            false_values_list = [\"F\", \"f\", \"False\", \"false\", \"N\", \"No\", \"no\", \"FALSE\"]\n            true_values_list = [\"T\", \"t\", \"True\", \"true\", \"Y\", \"Yes\", \"yes\", \"TRUE\"]",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "import_metta_file",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def import_metta_file(string):\n    global argmode\n    if argmode==\"mettalog\":\n        load_vspace()\n        swip_exec(f\"load_metta_file('{selected_space_name}','{string}')\")\n    else: the_python_runner.import_file(string)\nimport os\nimport sys\n@export_flags(MeTTa=True)\ndef vspace_main(*args):",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "vspace_main",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def vspace_main(*args):\n    is_init=False\n    #os.system('clear')\n    t0 = monotonic_ns()\n    if verbose>0: print_cmt(underline(\"Version-Space Main\\n\"))\n    flush_console()\n    #if is_init==False: load_vspace()\n    #if is_init==False: load_flybase()\n    #if is_init==False:\n    if isinstance(args, str):",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "vspace_main_from_python",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def vspace_main_from_python(sysargv1toN):\n    vspace_main(sysargv1toN)\ndef handle_arg(string, skip_filetypes=['.metta', '.md','.pl', '.png', '.jpg', '.obo']):\n        lower = string.lower()\n        if lower in [\"--metta\",\"--mettalog\",\"--python\"]:\n            global argmode\n            argmode = lower.lstrip('-')\n            if verbose>0: print(\"; argmode=\", argmode)\n            return\n        if os.path.isfile(string):",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "handle_arg",
        "kind": 2,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "def handle_arg(string, skip_filetypes=['.metta', '.md','.pl', '.png', '.jpg', '.obo']):\n        lower = string.lower()\n        if lower in [\"--metta\",\"--mettalog\",\"--python\"]:\n            global argmode\n            argmode = lower.lstrip('-')\n            if verbose>0: print(\"; argmode=\", argmode)\n            return\n        if os.path.isfile(string):\n            if lower.endswith('.metta'):\n                if verbose>0: print(\"; import_metta_file=\", string)",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "VSPACE_VERBOSE",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "VSPACE_VERBOSE = os.environ.get(\"VSPACE_VERBOSE\")\n# 0 = for scripts/demos\n# 1 = developer\n# 2 = debugger\nverbose = 1\nif VSPACE_VERBOSE is not None:\n try: verbose = int(VSPACE_VERBOSE) # Convert it to an integer\n except ValueError: \"\"\n# Third-Party Imports\ntry: from pyswip import (Atom as PySwipAtom, Term, call, Functor, PL_discard_foreign_frame, PL_new_term_ref, PL_open_foreign_frame,",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "verbose",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "verbose = 1\nif VSPACE_VERBOSE is not None:\n try: verbose = int(VSPACE_VERBOSE) # Convert it to an integer\n except ValueError: \"\"\n# Third-Party Imports\ntry: from pyswip import (Atom as PySwipAtom, Term, call, Functor, PL_discard_foreign_frame, PL_new_term_ref, PL_open_foreign_frame,\n                    registerForeign, PL_PRUNED, PL_retry, PL_FA_NONDETERMINISTIC, PL_foreign_control, PL_foreign_context, PL_FIRST_CALL, PL_REDO, Variable, Prolog as PySwip)\nexcept ImportError as e:\n if verbose>0: print(f\"; Error: {e}\")\ntry: from pyswip.easy import newModule, Query",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "histfile",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "histfile = os.path.join(os.path.expanduser(\"~\"), \".metta_history\")\nis_init = True\noper_dict = {}\njanus_dict = {}\nsyms_dict = {}\ndef parent_space():\n    return the_python_runner.parent.space()\ndef  child_space():\n    return the_python_runner.space()\ndef   self_space():",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "is_init",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "is_init = True\noper_dict = {}\njanus_dict = {}\nsyms_dict = {}\ndef parent_space():\n    return the_python_runner.parent.space()\ndef  child_space():\n    return the_python_runner.space()\ndef   self_space():\n    return the_new_runner_space",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "oper_dict",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "oper_dict = {}\njanus_dict = {}\nsyms_dict = {}\ndef parent_space():\n    return the_python_runner.parent.space()\ndef  child_space():\n    return the_python_runner.space()\ndef   self_space():\n    return the_new_runner_space\nspace_refs = {",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "janus_dict",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "janus_dict = {}\nsyms_dict = {}\ndef parent_space():\n    return the_python_runner.parent.space()\ndef  child_space():\n    return the_python_runner.space()\ndef   self_space():\n    return the_new_runner_space\nspace_refs = {\n    #'&vspace': lambda: the_verspace,",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "syms_dict",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "syms_dict = {}\ndef parent_space():\n    return the_python_runner.parent.space()\ndef  child_space():\n    return the_python_runner.space()\ndef   self_space():\n    return the_new_runner_space\nspace_refs = {\n    #'&vspace': lambda: the_verspace,\n    '&gptspace': lambda: the_gptspace,",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "space_refs",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "space_refs = {\n    #'&vspace': lambda: the_verspace,\n    '&gptspace': lambda: the_gptspace,\n    #'&flybase': lambda: the_flybase,\n    '&parent': lambda: parent_space(),\n    '&child': lambda: child_space(),\n    '&self': self_space}\ntry:\n    readline.set_history_length(300)\n    readline.read_history_file(histfile)",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "OPTIONS",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "OPTIONS = ['apple', 'banana', 'cherry', 'date', 'elderberry']\n# The completer function\ndef completer(text, state):\n    options = [i for i in OPTIONS if i.startswith(text)]\n    if state < len(options):\n        return options[state]\n    else:\n        return None\n# Register the completer function\nreadline.set_completer(completer)",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "vspace_ordinal",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "vspace_ordinal = 0\n# Mainly a sanity loading test class\nclass MettaLearner:\n    \"\"\nclass Circles:\n    def __init__(self, initial_data=None):\n        self.data = {}\n        if initial_data:\n            for key, value in initial_data.items():\n                self.__setitem__(key, value)",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "access_error",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "access_error = True\ndef is_iterable(obj):\n    try:\n        iter(obj)\n        return True\n    except TypeError:\n        return False\n@export_flags(MeTTa=True)\ndef test_custom_v_space():\n    #test_custom_space(lambda: (lambda vs: vs.incrHome() and vs)(VSpace()))",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "#nested_tuple",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "#nested_tuple = (1, 2, (3, 4, (5, 6)), 7)\n#converted_list = tuple_to_list(nested_tuple)\n#print(converted_list)  # Output will be [1, 2, [3, 4, [5, 6]], 7]\ndef mv2svn(metta_obj):\n    named = metta_obj.get_name().replace('$','_')\n    if len(named)==0: return \"_0\"\n    s=named[0]\n    if(s == '_' or (s.isalpha() and  s.isupper())):\n        return named\n    else:",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "#converted_list",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "#converted_list = tuple_to_list(nested_tuple)\n#print(converted_list)  # Output will be [1, 2, [3, 4, [5, 6]], 7]\ndef mv2svn(metta_obj):\n    named = metta_obj.get_name().replace('$','_')\n    if len(named)==0: return \"_0\"\n    s=named[0]\n    if(s == '_' or (s.isalpha() and  s.isupper())):\n        return named\n    else:\n        return \"_\" + named",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "realMetta",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "realMetta = None\ndef metta_register(metta):\n    print(f\";; metta_register={the_python_runner}/{metta}\")\n    global realMetta\n    try:\n        if not metta is None:\n            if not isinstance(metta,ExtendedMeTTa):\n                realMetta = metta\n            register_vspace_atoms_pm(metta)\n    #the_python_runner.set_cmetta(metta)",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "context_atom_iters",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "context_atom_iters = {}\ndef MkExpr(py_list):\n    list = py_list\n    return E(*list)\nclass IteratorAndConversionDict:\n    def __init__(self, iterator=None, conversion_dict=None):\n        self.iterator = iterator\n        self.conversion_dict = conversion_dict if conversion_dict is not None else {}\n    def set_iterator(self, iterator):\n        self.iterator = iterator",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "rustspace_ordinal",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "rustspace_ordinal = 0\n@export_flags(Janus=True)\ndef new_rust_space(result):\n    rustspace_ordinal=rustspace_ordinal+1\n    name = f\"&vspace_{rustspace_ordinal}\"\n    space = GroundingSpace()\n    addSpaceName(name,space)\n    return res_unify(result,swipAtom(name))\n@export_flags(MeTTa=True, Janus=True)\ndef test_nondeterministic_foreign1():",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "idKey",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "idKey = 1\n@export_flags(MeTTa=True, Janus=True)\ndef test_nondeterministic_foreign3():\n    def number_generator(size):\n        for i in range(size):\n            yield i\n    context_iterators = {}  # Dictionary to store iterators by context\n    def nondet3(sz, a, context):\n        global idKey\n        control = PL_foreign_control(context)",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "NeedNameSpaceInSWIP",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "NeedNameSpaceInSWIP = True\n@export_flags(MeTTa=True, unwrap=True)\ndef load_vspace():\n   global NeedNameSpaceInSWIP\n   swip_exec(f\"ensure_loaded('{os.path.dirname(__file__)}/pyswip/flybase_main')\")\n   if NeedNameSpaceInSWIP:\n       NeedNameSpaceInSWIP = False\n       swip.retractall(\"was_asserted_space('&self')\")\n       swip.assertz(\"py_named_space('&self')\")\n@export_flags(MeTTa=True, CallsVSpace=True)",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "needed_Skip",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "needed_Skip = 0\ndef analyze_csv(base_name, file_path, sep=None):\n    print_cmt(\";;------------------------------------------------------------------------------------------------------------------\")\n    print_cmt(f\"Analyzing file: {file_path}\")\n    missing_values_list = [\"\",\"-\",\" \",\"|\",\",\",\"#\",  \"*\",  \"\\\"\\\"\",  \"+\", \"NULL\", \"N/A\", \"--\",\n                         \"NaN\",\"EMPTY\",\"None\",\"n/a\",\"(none)\",\n                         # \"0\",\"Dmel\",\"-1\",\n                          \"MISSING\", \"?\", \"undefined\", \"unknown\", \"none\", \"[]\", \".\"]\n    def read_csv(enc, skip_rows, header_option):\n            false_values_list = [\"F\", \"f\", \"False\", \"false\", \"N\", \"No\", \"no\", \"FALSE\"]",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "swip",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "swip = globals().get('swip') or PySwip()\ntry:\n    the_verspace = globals().get('the_verspace') or VSpace(\"&verspace\")\n    the_flybase = globals().get('the_flybase') or VSpace(\"&flybase\")\n    the_nb_space = globals().get('the_nb_space') or VSpace(\"&nb\")\n    the_gptspace = globals().get('the_gptspace') or GptSpace()\nexcept Exception as e:\n    if verbose>0: print(f\"; Error: {e}\")\nthe_python_runner = globals().get('the_python_runner') or None\nselected_space_name = globals().get('selected_space_name') or \"&self\"",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "the_python_runner",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "the_python_runner = globals().get('the_python_runner') or None\nselected_space_name = globals().get('selected_space_name') or \"&self\"\nargmode = None\nsys_argv_length = len(sys.argv)\nif the_python_runner is None:  #MakeInteractiveMeTTa() #def MakeInteractiveMeTTa(): #global the_python_runner,the_old_runner_space,the_new_runner_space,sys_argv_length\n    try:\n        the_python_runner = InteractiveMeTTa()\n        #the_python_runner = MeTTa()\n        the_python_runner.cwd = [os.path.dirname(os.path.dirname(__file__))]\n        the_old_runner_space = the_python_runner.space()",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "selected_space_name",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "selected_space_name = globals().get('selected_space_name') or \"&self\"\nargmode = None\nsys_argv_length = len(sys.argv)\nif the_python_runner is None:  #MakeInteractiveMeTTa() #def MakeInteractiveMeTTa(): #global the_python_runner,the_old_runner_space,the_new_runner_space,sys_argv_length\n    try:\n        the_python_runner = InteractiveMeTTa()\n        #the_python_runner = MeTTa()\n        the_python_runner.cwd = [os.path.dirname(os.path.dirname(__file__))]\n        the_old_runner_space = the_python_runner.space()\n        the_new_runner_space = the_python_runner.space()",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "argmode",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "argmode = None\nsys_argv_length = len(sys.argv)\nif the_python_runner is None:  #MakeInteractiveMeTTa() #def MakeInteractiveMeTTa(): #global the_python_runner,the_old_runner_space,the_new_runner_space,sys_argv_length\n    try:\n        the_python_runner = InteractiveMeTTa()\n        #the_python_runner = MeTTa()\n        the_python_runner.cwd = [os.path.dirname(os.path.dirname(__file__))]\n        the_old_runner_space = the_python_runner.space()\n        the_new_runner_space = the_python_runner.space()\n        print_cmt(\"The sys.argv list is:\", sys.argv)",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "sys_argv_length",
        "kind": 5,
        "importPath": "metta_vspace.metta_learner_no_panda",
        "description": "metta_vspace.metta_learner_no_panda",
        "peekOfCode": "sys_argv_length = len(sys.argv)\nif the_python_runner is None:  #MakeInteractiveMeTTa() #def MakeInteractiveMeTTa(): #global the_python_runner,the_old_runner_space,the_new_runner_space,sys_argv_length\n    try:\n        the_python_runner = InteractiveMeTTa()\n        #the_python_runner = MeTTa()\n        the_python_runner.cwd = [os.path.dirname(os.path.dirname(__file__))]\n        the_old_runner_space = the_python_runner.space()\n        the_new_runner_space = the_python_runner.space()\n        print_cmt(\"The sys.argv list is:\", sys.argv)\n        vspace_init()",
        "detail": "metta_vspace.metta_learner_no_panda",
        "documentation": {}
    },
    {
        "label": "timeFrom",
        "kind": 2,
        "importPath": "metta_vspace.panda_util",
        "description": "metta_vspace.panda_util",
        "peekOfCode": "def timeFrom(w, t0):\n    elapsed_ns = monotonic_ns() - t0\n    elapsed_s = elapsed_ns / 1e9\n    elapsed_ms = elapsed_ns / 1e6\n    elapsed_us = elapsed_ns / 1e3\n    if elapsed_s >= 1:\n        print_cmt(f\"{w} took {elapsed_s:.5f} seconds\")\n    elif elapsed_ms >= 1:\n        print_cmt(f\"{w} took {elapsed_ms:.5f} milliseconds\")\n    else:",
        "detail": "metta_vspace.panda_util",
        "documentation": {}
    },
    {
        "label": "redirect_stdout",
        "kind": 2,
        "importPath": "metta_vspace.panda_util",
        "description": "metta_vspace.panda_util",
        "peekOfCode": "def redirect_stdout(inner_function):\n    old_stdout = sys.stdout # Save the current stdout stream\n    new_stdout = io.StringIO() # Create a new StringIO buffer\n    sys.stdout = new_stdout # Redirect stdout to the new buffer\n    try:\n        inner_function() # Execute the inner function\n    finally:\n        sys.stdout = old_stdout # Restore the original stdout stream\n    output = new_stdout.getvalue() # Retrieve the output from the new buffer\n    new_stdout.close() # Close the new buffer",
        "detail": "metta_vspace.panda_util",
        "documentation": {}
    },
    {
        "label": "flush_console",
        "kind": 2,
        "importPath": "metta_vspace.panda_util",
        "description": "metta_vspace.panda_util",
        "peekOfCode": "def flush_console():\n    try:\n      if sys.__stdout__ is not None: sys.__stdout__.flush()\n    except Exception: \"\"\n    try:\n      if sys.__stderr__ is not None: sys.__stderr__.flush()\n    except Exception: \"\"\n    try:\n      if sys.stderr is not None and not (sys.stderr is sys.__stderr__): sys.sys.stderr.flush()\n    except Exception: \"\"",
        "detail": "metta_vspace.panda_util",
        "documentation": {}
    },
    {
        "label": "detect_encoding",
        "kind": 2,
        "importPath": "metta_vspace.panda_util",
        "description": "metta_vspace.panda_util",
        "peekOfCode": "def detect_encoding(file_path, sample_size=20000):\n    with open(file_path, 'rb') as f:\n        raw = f.read(sample_size)\n    return chardet.detect(raw)['encoding']\nfrom collections.abc import Iterable\ndef is_lisp_dashed(s):\n    pattern = re.compile('^[A-Za-z0-9-_:]+$')\n    return bool(pattern.match(s))\ndef item_string(lst, functor=\"\"):\n    if isinstance(lst, str):",
        "detail": "metta_vspace.panda_util",
        "documentation": {}
    },
    {
        "label": "is_lisp_dashed",
        "kind": 2,
        "importPath": "metta_vspace.panda_util",
        "description": "metta_vspace.panda_util",
        "peekOfCode": "def is_lisp_dashed(s):\n    pattern = re.compile('^[A-Za-z0-9-_:]+$')\n    return bool(pattern.match(s))\ndef item_string(lst, functor=\"\"):\n    if isinstance(lst, str):\n        if len(lst) == 0:\n            return '\"\"'\n        if any(char in lst for char in [' ', '\"', \"'\", \"(\", \")\", \".\", \"\\\\\"]):\n            return json.dumps(lst)\n        if isinstance(lst, (int, float)):",
        "detail": "metta_vspace.panda_util",
        "documentation": {}
    },
    {
        "label": "item_string",
        "kind": 2,
        "importPath": "metta_vspace.panda_util",
        "description": "metta_vspace.panda_util",
        "peekOfCode": "def item_string(lst, functor=\"\"):\n    if isinstance(lst, str):\n        if len(lst) == 0:\n            return '\"\"'\n        if any(char in lst for char in [' ', '\"', \"'\", \"(\", \")\", \".\", \"\\\\\"]):\n            return json.dumps(lst)\n        if isinstance(lst, (int, float)):\n            return repr(lst)\n        if is_float_string(lst):\n            return repr(float(lst))",
        "detail": "metta_vspace.panda_util",
        "documentation": {}
    },
    {
        "label": "list_string",
        "kind": 2,
        "importPath": "metta_vspace.panda_util",
        "description": "metta_vspace.panda_util",
        "peekOfCode": "def list_string(lst, functor=\"# \"):\n    try:\n        if isinstance(lst, Iterable) and not isinstance(lst, str):\n            if len(lst) == 0:\n                return '()'\n            return '(' + functor + ' '.join([item_string(vv) for vv in lst]) + ')'\n        else:\n            return item_string(lst)\n    except TypeError:\n        return item_string(lst)",
        "detail": "metta_vspace.panda_util",
        "documentation": {}
    },
    {
        "label": "is_float_string",
        "kind": 2,
        "importPath": "metta_vspace.panda_util",
        "description": "metta_vspace.panda_util",
        "peekOfCode": "def is_float_string(s):\n    return bool(re.fullmatch(r'[-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?', s))\nimport pandas as pd\ndef update_dataframe_skipping_first_row(df):\n    \"\"\"\n    Takes a DataFrame, skips the first row, recalculates unique counts and value counts,\n    and infers the most appropriate datatypes for each column.\n    Parameters:\n    df (pandas.DataFrame): The original DataFrame.\n    Returns:",
        "detail": "metta_vspace.panda_util",
        "documentation": {}
    },
    {
        "label": "update_dataframe_skipping_first_row",
        "kind": 2,
        "importPath": "metta_vspace.panda_util",
        "description": "metta_vspace.panda_util",
        "peekOfCode": "def update_dataframe_skipping_first_row(df):\n    \"\"\"\n    Takes a DataFrame, skips the first row, recalculates unique counts and value counts,\n    and infers the most appropriate datatypes for each column.\n    Parameters:\n    df (pandas.DataFrame): The original DataFrame.\n    Returns:\n    pandas.DataFrame: A DataFrame with the first row removed, updated with recalculated\n    uniqueness and value counts, and with inferred datatypes.\n    \"\"\"",
        "detail": "metta_vspace.panda_util",
        "documentation": {}
    },
    {
        "label": "analyze_csv_basename",
        "kind": 2,
        "importPath": "metta_vspace.panda_util",
        "description": "metta_vspace.panda_util",
        "peekOfCode": "def analyze_csv_basename(file_path, sep=None):\n    base_name = os.path.basename(file_path)\n    base_name = base_name.replace('.tsv', '')\n    base_name = base_name.replace('.fb', '')\n    # Remove a sequence like _fb_####_## (where # represents a digit)\n    base_name = re.sub(r'_fb_\\d{4}_\\d{2}', '', base_name)\n    # Remove a sequence like ####_## at any place\n    base_name = re.sub(r'\\d{4}_\\d{2}', '', base_name)\n    # Replace periods with underscores, if not part of a file extension\n    base_name = re.sub(r'\\.(?=.*\\.)', '_', base_name)",
        "detail": "metta_vspace.panda_util",
        "documentation": {}
    },
    {
        "label": "analyze_csv",
        "kind": 2,
        "importPath": "metta_vspace.panda_util",
        "description": "metta_vspace.panda_util",
        "peekOfCode": "def analyze_csv(base_name, file_path, sep=None):\n    print_cmt(\";;------------------------------------------------------------------------------------------------------------------\")\n    print_cmt(f\"Analyzing file: {file_path}\")\n    missing_values_list = [\"\",\"-\",\" \",\"|\",\",\",\"#\",  \"*\",  \"\\\"\\\"\",  \"+\", \"NULL\", \"N/A\", \"--\",\n                         \"NaN\",\"EMPTY\",\"None\",\"n/a\",\"(none)\",\n                         # \"0\",\"Dmel\",\"-1\",\n                          \"MISSING\", \"?\", \"undefined\", \"unknown\", \"none\", \"[]\", \".\"]\n    def read_csv(enc, skip_rows, header_option):\n            false_values_list = [\"F\", \"f\", \"False\", \"false\", \"N\", \"No\", \"no\", \"FALSE\"]\n            true_values_list = [\"T\", \"t\", \"True\", \"true\", \"Y\", \"Yes\", \"yes\", \"TRUE\"]",
        "detail": "metta_vspace.panda_util",
        "documentation": {}
    },
    {
        "label": "import_metta_file",
        "kind": 2,
        "importPath": "metta_vspace.panda_util",
        "description": "metta_vspace.panda_util",
        "peekOfCode": "def import_metta_file(string):\n    global argmode\n    if argmode==\"mettalog\":\n        load_vspace()\n        swip_exec(f\"load_metta_file('{selected_space_name}','{string}')\")\n    else: the_python_runner.import_file(string)\nimport os\nimport sys\ndef vspace_main(*args):\n    is_init=False",
        "detail": "metta_vspace.panda_util",
        "documentation": {}
    },
    {
        "label": "vspace_main",
        "kind": 2,
        "importPath": "metta_vspace.panda_util",
        "description": "metta_vspace.panda_util",
        "peekOfCode": "def vspace_main(*args):\n    is_init=False\n    #os.system('clear')\n    t0 = monotonic_ns()\n    flush_console()\n    #if is_init==False: load_vspace()\n    #if is_init==False: load_flybase()\n    #if is_init==False:\n    if isinstance(args, str):\n        handle_arg(args)",
        "detail": "metta_vspace.panda_util",
        "documentation": {}
    },
    {
        "label": "vspace_main_from_python",
        "kind": 2,
        "importPath": "metta_vspace.panda_util",
        "description": "metta_vspace.panda_util",
        "peekOfCode": "def vspace_main_from_python(sysargv1toN):\n    vspace_main(sysargv1toN)\ndef handle_arg(string, skip_filetypes=['.metta', '.md','.pl', '.png', '.jpg', '.obo']):\n        lower = string.lower()\n        if lower in [\"--metta\",\"--mettalog\",\"--python\"]:\n            global argmode\n            argmode = lower.lstrip('-')\n            if verbose>0: print(\"; argmode=\", argmode)\n            return\n        if os.path.isfile(string):",
        "detail": "metta_vspace.panda_util",
        "documentation": {}
    },
    {
        "label": "handle_arg",
        "kind": 2,
        "importPath": "metta_vspace.panda_util",
        "description": "metta_vspace.panda_util",
        "peekOfCode": "def handle_arg(string, skip_filetypes=['.metta', '.md','.pl', '.png', '.jpg', '.obo']):\n        lower = string.lower()\n        if lower in [\"--metta\",\"--mettalog\",\"--python\"]:\n            global argmode\n            argmode = lower.lstrip('-')\n            if verbose>0: print(\"; argmode=\", argmode)\n            return\n        if os.path.isfile(string):\n            if lower.endswith('.metta'):\n                if verbose>0: print(\"; import_metta_file=\", string)",
        "detail": "metta_vspace.panda_util",
        "documentation": {}
    },
    {
        "label": "print_cmt",
        "kind": 2,
        "importPath": "metta_vspace.panda_util",
        "description": "metta_vspace.panda_util",
        "peekOfCode": "def print_cmt(*args, prefix=\";; \"):\n   for arg in args:\n       println(arg, prefix=prefix)\n       flush_console()\ndef println(orig, prefix=\"\"):\n    \"\"\"\n    Prints the given object and returns it.\n    Args:\n        orig: The object to be printed.\n    Returns:",
        "detail": "metta_vspace.panda_util",
        "documentation": {}
    },
    {
        "label": "println",
        "kind": 2,
        "importPath": "metta_vspace.panda_util",
        "description": "metta_vspace.panda_util",
        "peekOfCode": "def println(orig, prefix=\"\"):\n    \"\"\"\n    Prints the given object and returns it.\n    Args:\n        orig: The object to be printed.\n    Returns:\n        The same object that was passed in.\n    \"\"\"\n    try:\n      prefix_print(prefix, orig)",
        "detail": "metta_vspace.panda_util",
        "documentation": {}
    },
    {
        "label": "prefix_print",
        "kind": 2,
        "importPath": "metta_vspace.panda_util",
        "description": "metta_vspace.panda_util",
        "peekOfCode": "def prefix_print(prefix, orig):\n    obj = orig\n    if isinstance(obj, str):\n        objlns = obj.splitlines()\n        for r in objlns:\n            print(prefix, r)\n        return\nis_init=False\nif __name__ == \"__main__\":\n    vspace_main_from_python(sys.argv[1:])",
        "detail": "metta_vspace.panda_util",
        "documentation": {}
    },
    {
        "label": "VSPACE_VERBOSE",
        "kind": 5,
        "importPath": "metta_vspace.panda_util",
        "description": "metta_vspace.panda_util",
        "peekOfCode": "VSPACE_VERBOSE = os.environ.get(\"VSPACE_VERBOSE\")\n# 0 = for scripts/demos\n# 1 = developer\n# 2 = debugger\nverbose = 1\nif VSPACE_VERBOSE is not None:\n try: verbose = int(VSPACE_VERBOSE) # Convert it to an integer\n except ValueError: \"\"\ndef timeFrom(w, t0):\n    elapsed_ns = monotonic_ns() - t0",
        "detail": "metta_vspace.panda_util",
        "documentation": {}
    },
    {
        "label": "verbose",
        "kind": 5,
        "importPath": "metta_vspace.panda_util",
        "description": "metta_vspace.panda_util",
        "peekOfCode": "verbose = 1\nif VSPACE_VERBOSE is not None:\n try: verbose = int(VSPACE_VERBOSE) # Convert it to an integer\n except ValueError: \"\"\ndef timeFrom(w, t0):\n    elapsed_ns = monotonic_ns() - t0\n    elapsed_s = elapsed_ns / 1e9\n    elapsed_ms = elapsed_ns / 1e6\n    elapsed_us = elapsed_ns / 1e3\n    if elapsed_s >= 1:",
        "detail": "metta_vspace.panda_util",
        "documentation": {}
    },
    {
        "label": "needed_Skip",
        "kind": 5,
        "importPath": "metta_vspace.panda_util",
        "description": "metta_vspace.panda_util",
        "peekOfCode": "needed_Skip = 0\ndef analyze_csv(base_name, file_path, sep=None):\n    print_cmt(\";;------------------------------------------------------------------------------------------------------------------\")\n    print_cmt(f\"Analyzing file: {file_path}\")\n    missing_values_list = [\"\",\"-\",\" \",\"|\",\",\",\"#\",  \"*\",  \"\\\"\\\"\",  \"+\", \"NULL\", \"N/A\", \"--\",\n                         \"NaN\",\"EMPTY\",\"None\",\"n/a\",\"(none)\",\n                         # \"0\",\"Dmel\",\"-1\",\n                          \"MISSING\", \"?\", \"undefined\", \"unknown\", \"none\", \"[]\", \".\"]\n    def read_csv(enc, skip_rows, header_option):\n            false_values_list = [\"F\", \"f\", \"False\", \"false\", \"N\", \"No\", \"no\", \"FALSE\"]",
        "detail": "metta_vspace.panda_util",
        "documentation": {}
    }
]